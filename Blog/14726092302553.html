
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  转载iOS MJ讲解面试题,并修改里面错误 - 李小争
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="记录开发中遇到的一些问题">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="李小争" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">李小争</a></h1>
  
    <h2>记录开发中遇到的一些问题</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.citynight.cn/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div>
	<article class="hentry" role="article">
	<header>
			  	<h1 class="entry-title">转载iOS MJ讲解面试题,并修改里面错误</h1>
				<p class="meta"><time datetime="2016-08-31T10:07:10+08:00" pubdate data-updated="true">2016/8/31</time></p>
			 </header>
		  	<div class="entry-content">
			  	<blockquote>
<p>原文链接:<a href="http://www.jianshu.com/p/9050e523e278">http://www.jianshu.com/p/9050e523e278</a></p>
</blockquote>
<h4><a id="1%E3%80%81kvo%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、KVO内部实现原理</h4>
<ul>
<li>1.KVO是基于runtime机制实现的</li>
<li>2.当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法。<br />
派生类在被重写的setter方法实现真正的通知机制（Person-&gt;NSKVONotifying_Person）</li>
</ul>
<h4><a id="2%E3%80%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%BE%E5%9C%A8nsnotificationcenter%E4%B8%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、是否可以把比较耗时的操作放在NSNotificationCenter中</h4>
<ul>
<li>通知中心所做的操作在主线程，比较耗时的一般开启一个线程单独去跑</li>
</ul>
<h4><a id="3%E3%80%81kvo%E3%80%81nsnotification%E3%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E9%82%A3%E4%B8%AA%EF%BC%9F%E5%A6%82%E6%9E%9C%E7%94%A8protocol%E5%92%8Cdelegate%EF%BC%88%E6%88%96%E8%80%85delegate%E7%9A%84array%EF%BC%89%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%AF%E8%83%BD%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%83%BD%EF%BC%8C%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E6%BD%9C%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、KVO、NSNotification、代理的区别和用法是什么？什么时候该用那个？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果能，会有什么潜在的问题？如果不能，为什么？</h4>
<h5><a id="%E7%AD%94%E6%A1%88%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>答案：</h5>
<p>参考：<a href="http://blog.csdn.net/dqjyong/article/details/7685933">http://blog.csdn.net/dqjyong/article/details/7685933</a></p>
<h6><a id="%E9%80%9A%E7%9F%A5%EF%BC%88nsnotification%EF%BC%89%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通知（NSNotification）：</h6>
<ul>
<li>比较灵活（1个通知能被多个对象接受，多个对象能接受多个通知）</li>
<li>没有耦合性（Ａ发出的通知，谁去接收并不知道）</li>
<li>缺点通知的Key容易被写错</li>
</ul>
<h6><a id="kvo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>KVO</h6>
<ul>
<li>性能不好（底层对会Runtime动态产成新的类NSNotifying_xx）</li>
<li>局限性（只能监听某个对象属性的改变，不推荐实用）</li>
<li>1个对象的属性能被多个对象监听，1个对象能监听多个对象的其他属性</li>
</ul>
<h6><a id="%E4%BB%A3%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代理</h6>
<ul>
<li>比较规范，所以安全性高</li>
<li>默认是1对1监听，可以用代理数组 a.delegates = @[b, c, d];(千万别这样写，违背的设计模式，这样写还不如同消息通知)</li>
</ul>
<h4><a id="4%E3%80%81runtime%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%B9%B2%E5%98%9B%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E4%BD%A0%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E6%9F%90%E4%BA%9B%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、Runtime实现的机制是什么，怎么用，一般用于干嘛，你还记得你所使用的相关的头文件或者某些方法的名称吗？</h4>
<p>运行时机制，runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量，动态改变类的方法实现，为类动态添加新的方法等，需要导入</p>
<h5><a id="1%E4%BB%80%E4%B9%88%E6%98%AF-runtime" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.什么是Runtime</h5>
<ul>
<li>runtime是一套比较低层的纯C语言API，属于1个C语言库，包含许多C底层的C语言的API</li>
<li>平时编写的OC代码，在程序 运行过程中，其实最终都转换成了runtime的C语言代码，runtime算是OC的幕后工作者<br />
举例：<br />
OC:<br />
<code> [MJPerson alloc]init];</code><br />
runtime：<br />
<code> objc_msgSend(objc_msgSend(&quot;MJPerson&quot;, &quot;alloc&quot;), &quot;init&quot;)</code></li>
</ul>
<h5><a id="2%E7%94%A8%E8%BF%87%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.用过么？怎么用？</h5>
<ul>
<li>1.runtime是属于OC底层，可以进行 一些非常的操作（OC无法实现的，不容易实现的）
<ul>
<li>在程序运行过程中，动态创建一个类（比如KVO底层实现）</li>
<li>在程序运行过程中，动态地为某个类 添加属性、方法，修改属性值、方法</li>
<li>便利一个类的 所以成员变量（属性）、方法</li>
</ul>
</li>
</ul>
<h5><a id="3%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.相关应用</h5>
<ul>
<li>
<p>1.头文件</p>
<p>调用底层的消息发送方法</p>
</li>
<li>
<p>2.相关应用</p>
<ul>
<li>NSCoding（归档和解档，利用runtime遍历模型对象的所有属性）</li>
<li>字典 -&gt;模型 （利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上）</li>
<li>KVO（利用runtime动态产生一个类）</li>
<li>用于封装框架（想怎么改，就怎么改）</li>
</ul>
</li>
<li>
<p>3.相关函数</p>
<ul>
<li>objc_msgSend ： 给对象发送消息</li>
<li>class_copyMethodList ： 遍历某个所有方法</li>
<li>class_copyIvarList ： 遍历某个类所以的成员变量</li>
<li>class_addMethod ： 动态添加方法</li>
<li>class_addIval ：动态添加成员变量</li>
<li>class_.... class_开头的方法,是操作类的</li>
</ul>
</li>
</ul>
<h6><a id="%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8runtime%E5%BD%92%E6%A1%A3%E5%92%8C%E8%A7%A3%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>例：利用Runtime归档和解档</h6>
<pre><code>//  MJPerson.m
//  runtime进行归档和解档
//
//  Created by Zhanbo on 16/7/7.
//  Copyright © 2016年 Zhanbo. All rights reserved.
//

#import &quot;MJPerson.h&quot;
#import &lt;objc/runtime.h&gt;
@implementation MJPerson

- (void)encodeWithCoder:(NSCoder *)aCoder {

   unsigned int count = 0;
  //参数1：那个类
  //参数2：有几个成员变量
   Ivar *ivars = class_copyIvarList([MJPerson class], &amp;count);

    for (int i = 0; i &lt;count; i++) {
        //取出i位置对应的成员变量
        Ivar ivar = ivars[i];

        //查看成员变量
        const char *name = ivar_getName(ivar);
        NSLog(@&quot;%s&quot;, name);

        //归档
        NSString *key = [NSString stringWithUTF8String:name];
        id value = [self valueForKey:key];
        [aCoder encodeObject:value forKey:key];

    }
    //在C语言中使用copy要释放
    free(ivars);
}

- (instancetype)initWithCoder:(NSCoder *)aDecoder {

    if (self = [super init]) {

        unsigned int count = 0;
        Ivar *ivars = class_copyIvarList([MJPerson class], &amp;count);

        for (int i = 0; i &lt;count; i++) {
            //取出i位置对应的成员变量
            Ivar ivar = ivars[i];

            //查看成员变量
            const char *name = ivar_getName(ivar);
            NSLog(@&quot;%s&quot;, name);

            //解档
            NSString *key = [NSString stringWithUTF8String:name];
            id value = [aDecoder decodeObjectForKey:key];

            //设置到成员变量身上
            [self setValue:value forKey:key];

        }
        //在C语言中使用copy要释放
        free(ivars);
    }
    return self;
}

@end
</code></pre>
<h5><a id="4%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.必备常识</h5>
<ul>
<li>1.Ivar ： 成员变量</li>
<li>
<ol>
<li>Method ： 成员方法</li>
</ol>
</li>
</ul>
<h4><a id="5%E3%80%81foundation%E5%AF%B9%E8%B1%A1%E4%B8%8Ecore-foundation%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5、Foundation对象与Core Foundation对象有什么区别？</h4>
<ul>
<li>
<p>1.Foundation对象是OC的，Core Foundation对象是C对象</p>
</li>
<li>
<p>2.数据类型之间的转换(桥接)</p>
<ul>
<li>
<p>ARC：bridge_retained、 _bridge_transfer</p>
<pre><code>CFArrayRef array3 = CFArrayCreate(NULL, NULL, 10, NULL);

//Foundetion -&gt; Core Fountdation
(__bridge_retained )

//Core Fountdation -&gt; Foundetion
(__bridge_transfer )
NSArray *array4 = (__bridge_transfer NSArray *)array3);
</code></pre>
</li>
<li>
<p>MRC: _bridge</p>
<pre><code>Foundation -&gt; Core Foundation
NSArray *array1 = [NSArray array];
CFArrayRef array2 = (__bridge CFArrayRef)array1;
//记得释放内存
[array1 release];
</code></pre>
</li>
</ul>
</li>
</ul>
<h4><a id="6%E3%80%81%E4%B8%8D%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%EF%BC%8C%E7%94%A8%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2a%E5%92%8Cb%E7%9A%84%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6、不用中间变量，用两种方法交换A和B的值</h4>
<ul>
<li>
<ol>
<li>A = A + B<br />
B = A - B<br />
A = A- B</li>
</ol>
</li>
<li>2.使用位运算^能交换两个变量的值</li>
</ul>
<h4><a id="7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%EF%BC%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7、 什么是动态，举例说名</h4>
<ul>
<li>1.在线程运行过程才执行的操作，如Runtime动态创建成员变量和方法</li>
</ul>
<h4><a id="8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8、什么是多态</h4>
<ul>
<li>
<p>1.父类指针指向子类对象</p>
<pre><code>NSObject *obj = [NSArray array];
</code></pre>
</li>
</ul>
<h4><a id="9%E3%80%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E6%B1%A0%E6%BB%A1%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88cell%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>9、怎么解决缓存池满的问题（cell）</h4>
<ul>
<li>iOS中不存在缓存池满的情况，应为通常我们在iOS开发，对象都是在需要的时候才会创建，有种常用的说法叫懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会创建新对象，缓存池里最多就一两个对象，缓存池满的这中情况一般在开发Java中比较常见，Java中一般把最近最少使用的对象先释放</li>
<li>如果缓存池满了，判断哪个位置的cell是不经常使用的，先释放掉</li>
</ul>
<h3><a id="10%E3%80%81%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84uilabel" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>10、如何渲染自定义格式字符串的UILabel</h3>
<ul>
<li>
<p>1.通过NSAttributedString类</p>
<pre><code>  //1种写法，也可以用字典
NSMutableAttributedString *str = [[NSMutableAttributedString alloc]initWithString:@&quot;哈哈哈啦啦啦哇哇哇&quot;];
  //设置文字颜色
  [str addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 3)];
  [str addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(6, 3)];
  //设置字体
  [str addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(3, 3)];

  _label.attributedText = str;
</code></pre>
</li>
</ul>
<p><img src="media/14726092302553/1240." alt="" /></p>
<p>效果</p>
<h4><a id="11%E3%80%81scrollview%E7%9A%84contentsize%E8%83%BD%E5%9C%A8viewdidload%E9%87%8C%E8%AE%BE%E7%BD%AE%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>11、scrollView的contentSize能在ViewDidLoad里设置吗，为什么？</h4>
<ul>
<li>1.能，在哪里都能设置</li>
<li>2.但是最好不要在viewDidLoad里设置，因为视图刚创建不一定是我们想要的尺寸，在iPad开发中横竖屏是很好的例子</li>
</ul>
<h4><a id="12%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8view%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>12、控制器View的生命周期及相关函数什么？你在开发中是如何用的？</h4>
<ul>
<li>1.首先判断控制器是否有视图，如果没有就调用<strong>loadView</strong>方法创建：通过storyboard或者代码</li>
<li>2.随后调用<strong>viewDidLoad</strong>，可以进行下一步的初始化操作：只会被调用一次</li>
<li>3.在视图显示之前（即将显示）调用<strong>viewWillAppear</strong>，该函数可以多次调用</li>
<li>4.在视图显示，会调用<strong>viewDidAppear</strong></li>
<li>5.视图即将消失，调用<strong>viewWillDisappear</strong></li>
<li>6.视图已经消失，调用<strong>viewDidDisappear</strong></li>
<li>7.在布局变化前后，调用<strong>viewWillDidLayoutSubviews</strong>处理相关信息</li>
</ul>
<h4><a id="13%E3%80%81block%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>13、Block的内存管理</h4>
<ul>
<li>1.默认情况下，block的内存是在栈中
<ul>
<li>它不会对所引用的对象进行任何操作</li>
</ul>
</li>
<li>2.如果对block做一次copy操作，block的内存就会在堆中
<ul>
<li>它会对所引用的对象做一次retain操作</li>
<li>ARC ：如果所引用的对象用了**__unsafe_unretained<strong>或者</strong>__weak**修饰，就不会做retain操作</li>
<li>非ARC(MRC) ： 如果所引用的对象用**__block**修饰，就不会做retain操作；MRC记得释放blockBlock_release(_block);</li>
</ul>
</li>
</ul>
<pre><code>- (void)dealloc {
    //MRC记得在dealloc释放blcok，[super dealloc];要写最后
    Block_release(_block);
    [super dealloc];
}
</code></pre>
<h4><a id="14%E3%80%81mrc%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%BC%80%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>14、MRC中如何做开发</h4>
<p>1.MRC中retain相当于ARC中strong<br />
assign相当于ARC中weak<br />
2.只要声明对象属性就要写retain</p>
<pre><code>@property (nonatomic, retain)NSArray *array; +1(计数器 = 1)
</code></pre>
<p>3.声明控件、协议用assgin</p>
<p>4.MRC的内存管理原则</p>
<ul>
<li>如果调用了alloc、new、copy产生了一个新对象，最后肯定要调用1次releace或者autorelease</li>
<li>如果让一个对象做了retain操作（计数器+1），最后肯定要调用1次release或者autorelease</li>
<li>原则：有+ 就有-</li>
</ul>
<pre><code>self.array = [NSArray alloc]init]autorelease];
alloc后 +1(计数器 = 2)； autorelease后 -1(计数器 = 1)
//或者这样写，就不需要写autorelease，系统内部自动写好
self.array = [NSArray array];
</code></pre>
<ul>
<li>最后要在dealloc释放内存</li>
</ul>
<pre><code>//当控制器将被释放的时候对调用
- (void)dealloc {
//最好这样写
self.array = nil;
-1(计数器 = 0)

//也可以这样写
self.array = [array release];
//最后调用
[supe dealloc];
}
</code></pre>
<p>如果是iOS版本在5.0之前要在3个地方释放内存</p>
<pre><code>//控制器的View被卸载，会调用
- (void)viewDidUnload {

    [super viewDidUnload];
    self.array = nil;
}

//接收到内存警告，会调用
- (void)didReceiveMemoryWarning {

    [super didReceiveMemoryWarning];
    self.array = nil;
}

- (void)dealloc {

    self.array = nil;

    [super dealloc];
}
</code></pre>
<h4><a id="15%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BA%BF%E4%B9%8B%E9%97%B4%E9%80%9A%E8%AE%AF%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>15、多线程如何进行线之间通讯？</h4>
<pre><code>//在主线程执行某个方法，传参（该方法用于子线程对主线程进行通讯）
[self performSelectorOnMainThread: withObject: waitUntilDone:]

//指定线程，调用方法，传参
[self performSelector: onThread: withObject: waitUntilDone: modes: *)#&gt;

//GCD在异步线程做事情
dispatch_async(, )
</code></pre>
<h4><a id="16%E3%80%81%E7%94%A8nsoperation%E5%92%8Cnsoperationqueue%E5%A4%84%E7%90%86a-b-c%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%A6%81%E6%B1%82%E6%89%A7%E8%A1%8C%E5%AE%8Ca-b%E6%89%8D%E8%83%BD%E6%89%A7%E8%A1%8Cc%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>16、用NSOperation和NSOperationQueue处理A,B,C三个线程，要求执行完A,B才能执行C，怎么做？</h4>
<ul>
<li>1.第一种方法添加依赖</li>
</ul>
<pre><code>//创建列队
NSOperationQueue *queue = [NSOperationQueue alloc]init];
//创建3个操作
NSOperation *a = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation1....&quot;);
}];

NSOperation *c = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation2....&quot;);
}];

NSOperation *b = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation3....&quot;);
}];
//======添加依赖=======
//只有当a操作执行完毕后，才会执行c操作
[c addDependency:a];
//只有当b操作执行完毕后，才会执行c操作
[c addDependency:b];

[queue addOperation:a];
[queue addOperation:b];
[queue addOperation:c];
</code></pre>
<ul>
<li>2.第二种方法 可 以设置优先级</li>
</ul>
<pre><code>- (NSOperationQueuePriority)queuePriority;
</code></pre>
<h4><a id="17%E3%80%81gcd%E5%86%85%E9%83%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>17、GCD内部怎么实现的</h4>
<ul>
<li>1.iSO和OS X的核心是XNU内核，GCD是基于XNU内核实现的</li>
<li>2.GCD的API全部在libdispatch库中</li>
<li>3.GCD的底层实现主要有Dispatch Queue和 Dispatch Source
<ul>
<li>Disatch Queue ：管理block（操作，block里的代码块，根据类型在哪个线程执行）</li>
<li>Disatch Source ： 处理事件（底层实现，处理线程之间的事件，如主线程会到什么线程，异步线程回到什么线程）</li>
</ul>
</li>
</ul>
<h4><a id="18%E3%80%81nsoperatinqueue%E5%92%8Ccgd%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8nsoperationqueue%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8gcd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>18、NSOperatinQueue和CGD的区别，什么情况下用NSOperationQueue，什么情况下用GCD</h4>
<ul>
<li>1.GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本封装</li>
<li>2.GCD只支持FIFO的列队（先进先出），NSOperationQueue可以很方便地调整执行顺序（设置优先级 ），设置最大并发数量</li>
<li>3.NSOperatinQueue可以轻松在Operation间设置依赖关系，而GCD需要些很多代码才能实现</li>
<li>4.NSOperationQueue支持KVO，可以监听operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）；系统内部已经做好的KVO</li>
<li>5.GCD的执行速度比NSOperationQueue快</li>
<li>什么时候，用哪个
<ul>
<li>1.任务之间有依赖/或者要监听任务的执行情况：NSOperatinQueue（任务需要时刻监听；任务严格需要按顺序执行）</li>
<li>2.任务之间不太相互依赖就用：CGD</li>
</ul>
</li>
</ul>
<h4><a id="19%E3%80%81%E6%97%A2%E7%84%B6%E8%AF%B4%E5%88%B0gcd%EF%BC%8C%E9%82%A3%E4%B9%88%E9%97%AE%E4%B8%8B%E5%9C%A8%E4%BD%BF%E7%94%A8gcd%E5%B7%B2%E7%BB%8Fblock%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>19、既然说到GCD，那么问下在使用GCD已经block需要注意什么？</h4>
<ul>
<li>1.GCD的注意18题已有说明</li>
<li>2.Block的使用注意
<ul>
<li>1.block的内存管理(13题已有说明)</li>
<li>2.防止循环retain
<ul>
<li>ARC：**weak/**unsafe_unretained</li>
<li>MRC: __block 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><a id="20%E3%80%81%E5%A6%82%E6%9E%9C%E5%90%8E%E6%9C%9F%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%BD%BF%E7%94%A8coredata%E5%91%A2%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>20、如果后期需要增加数据库中的字段怎么实现，如果不使用CoreData呢？</h4>
<p>编写SQL语句来操作原来表中的字段</p>
<ul>
<li>1.增加表字段<br />
ALTER TABLE 表名 DROP COLUMN 字段名 字段类型</li>
<li>2.删除表字段<br />
ALTER TABLE 表名 DROP COLUMN 字段名</li>
<li>3.修改表字段<br />
ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名</li>
</ul>
<h4><a id="21%E3%80%81%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>21、简单描述下客户端的缓存机制</h4>
<ul>
<li>1.缓存可以分为：内存数据缓存、数据库缓存、文件缓存</li>
<li>2.每次想获取数据的时候
<ul>
<li>先检测内存中有无缓存</li>
<li>在检测本地有无缓存（数据库/文件）</li>
<li>最终发送网络请求</li>
<li>将服务器返回的网络数据进行缓存（内存、数据库、文件），已便下次读取</li>
</ul>
</li>
</ul>
<h4><a id="22%E3%80%81%E6%9C%89%E4%BA%9B%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%AF%94%E8%BE%83%E6%85%A2%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>22、有些图片加载的比较慢怎么处理？你是怎么优化程序的性能的？</h4>
<ul>
<li>1.图片下载放在异步线程</li>
<li>2.图片下载过程中使用占位图，提高用户的天</li>
<li>3.如果图片比较大，可以考虑多线程断点下载（开辟多个线程下载一张图片，需要服务器设置请求体信息）</li>
</ul>
<h4><a id="23%E3%80%81%E4%BD%A0%E5%AE%9E%E7%8E%B0%E8%BF%87%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6%E6%88%96%E8%80%85%E5%BA%93%E4%BB%A5%E4%BE%9B%E5%88%AB%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E8%AF%B7%E8%B0%88%E4%B8%80%E8%B0%88%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6%E6%88%96%E8%80%85%E5%BA%93%E6%97%B6%E5%80%99%E7%9A%84%E7%BB%8F%E9%AA%8C%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%EF%BC%8C%E8%AF%B7%E8%AE%BE%E6%83%B3%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E7%9A%84public%E7%9A%84api%EF%BC%8C%E5%B9%B6%E6%8C%87%E5%87%BA%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E5%A6%82%E4%BD%95%E5%81%9A%E3%80%81%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%80%E4%BA%9B%E4%BB%80%E4%B9%88%E6%96%B9%E9%9D%A2%EF%BC%8C%E6%9D%A5%E4%BD%BF%E5%88%AB%E4%BA%BA%E5%AE%B9%E6%98%93%E5%9C%B0%E4%BD%BF%E7%94%A8%E4%BD%A0%E7%9A%84%E6%A1%86%E6%9E%B6%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>23、你实现过一个框架或者库以供别人使用吗？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。</h4>
<ul>
<li>1.提供给外界的接口功能是否实用、够用</li>
<li>2.别人使用我的框架时，能不能根据类名、方法名就猜出接口的具体作用</li>
<li>3.别人调用接口时，提供的参数是否够用、调用起来是否简单</li>
<li>4.别人使用我的框架时，要不要再导入依赖其他的框架</li>
</ul>
<h4><a id="24%E3%80%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%BE%E5%9C%A8nsnotificationcenter%E4%B8%AD%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>24、是否可以把比较耗时的操作放在NSNotificationCenter中？</h4>
<ul>
<li>1.如果在异步线程发的通知，那么可以执行比较耗时的操作</li>
<li>2.如果在主线程发的通知，那么就不可以执行比较耗时的操作<br />
补充：NSNotificationCenter默认是主线程的，但是在异步线程发通知，那么NSNotificationCenter就会变成异步线程</li>
</ul>
<h4><a id="25%E3%80%81sdwebimage%E5%85%B7%E4%BD%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>25、SDWebImage具体如何实现</h4>
<ul>
<li>1.利用NSOperationQueue和NSOperation下载图片，还使用了GCD的一些函数（解码GIF图片）</li>
<li>2.利用URL作为key，NSOperation作为value</li>
<li>3.利用URL作为key，UIImage作为value</li>
</ul>
<h4><a id="26%E3%80%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3sqlite%E9%94%81%E5%AE%9A%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>26、怎么解决sqlite锁定的问题</h4>
<ul>
<li>1.设置数据库锁定的处理函数</li>
</ul>
<pre><code>当数据库被锁时，会调用该方法
//参数1传入数据库，
//参数2传入函数名(在该函数中做操作)
int sqlite3_busy_handler(sqlite3*, test);
</code></pre>
<ul>
<li>
<p>2.设置锁定时的等待时间</p>
<pre><code>int sqlite3_busy_timeout(sqlite3*, int ms);
</code></pre>
</li>
</ul>
<h4><a id="27%E3%80%81cocoa%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%AF%B9%E5%87%A0%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%B9%B6%E8%B0%88%E8%B0%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>27、cocoa中常见对几种多线程的实现，并谈谈多线程安全的几种解决办法及多线程安全怎么控制？</h4>
<ul>
<li>1.只在主线程刷新访问UI</li>
<li>2.如果要防止资源抢夺，得用synchroized进行加锁保护</li>
<li>3.如果异步操作要保证线程安全等问题，尽量使用GCD（有些函数默认就是安全的）</li>
</ul>
<h4><a id="28%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFrun-loop%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>28、什么是run loop？</h4>
<ul>
<li>1.runloop是消息循环，内部有定时源和输入源来运作</li>
<li>2.在创建的程序不需要显示的创建run loop；每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象，主线程会自行创建并运行run loop</li>
<li>3.run loop处理的输入事件有两种不同的来源：输入源（input source）和定时源（timer source）</li>
<li>4.输入源处理传递异步消息，通常来自于其他线程或者程序。定时源则处理传递同步消息，在特定时间或者一定的时间间隔发生</li>
</ul>

			</div>

		
	  
		<footer>
		 <p class="meta">

			
			<span class="categories">
			 
			</span>
		    </p>
		    <p class="meta">
		      
		 </p>
	    
		<div class="sharing">
		  
          

          

		</div>

	    <p class="meta">
	    
	        <a class="basic-alignment left" href="14726525723684.html" 
	        title="Previous Post: KVO内部实现原理">&laquo; KVO内部实现原理</a>
	    
	    
	        <a class="basic-alignment right" href="14719458588528.html" 
	        title="Next Post: MKNetWork简介">MKNetWork简介 &raquo;</a>
	    
	    </p>
	  </footer>
	</article>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.html"><strong>原理探究&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8A%80%E5%B7%A7.html"><strong>技巧&nbsp;(34)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%95%99%E7%A8%8B.html"><strong>教程&nbsp;(23)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%81%87%E5%88%B0Bug.html"><strong>遇到Bug&nbsp;(12)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%9D%82%E8%AE%B0.html"><strong>杂记&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Swift.html"><strong>Swift&nbsp;(23)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="C/C++.html"><strong>C/C++&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Linux.html"><strong>Linux&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Documentation.html"><strong>Documentation&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Java.html"><strong>Java&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LeetCode.html"><strong>LeetCode&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Flutter.html"><strong>Flutter&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="16293704418629.html">AbsorbPointer和IgnorePointer</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16293384343104.html">了解Scrollable</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16292522945585.html">避免和WillPopScope与iOS手势冲突</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16291783311992.html">方便实用的小组件</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16267829476143.html">Flutter 中 TabBarView 点击切换，监听会调用多出</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



  













<script src="asset/prism.js"></script>


<style type="text/css">
  
/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript */
/*
 Solarized Color Schemes originally by Ethan Schoonover
 http://ethanschoonover.com/solarized

 Ported for PrismJS by Hector Matos
 Website: https://krakendev.io
 Twitter Handle: https://twitter.com/allonsykraken)
*/

/*
SOLARIZED HEX
--------- -------
base03    #002b36
base02    #073642
base01    #586e75
base00    #657b83
base0     #839496
base1     #93a1a1
base2     #eee8d5
base3     #fdf6e3
yellow    #b58900
orange    #cb4b16
red       #dc322f
magenta   #d33682
violet    #6c71c4
blue      #268bd2
cyan      #2aa198
green     #859900
*/

code[class*="language-"],
pre[class*="language-"] {
  color: #657b83; /* base00 */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;

  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  background: #073642; /* base02 */
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  background: #073642; /* base02 */
}

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
  border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdf6e3; /* base3 */
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #93a1a1; /* base1 */
}

.token.punctuation {
  color: #586e75; /* base01 */
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #268bd2; /* blue */
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.url,
.token.inserted {
  color: #2aa198; /* cyan */
}

.token.entity {
  color: #657b83; /* base00 */
  background: #eee8d5; /* base2 */
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #859900; /* green */
}

.token.function,
.token.class-name {
  color: #b58900; /* yellow */
}

.token.regex,
.token.important,
.token.variable {
  color: #cb4b16; /* orange */
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>
  
    


</body>
</html>