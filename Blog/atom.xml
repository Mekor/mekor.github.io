<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2016-10-26T22:04:34+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[计算老虎机中奖等级-NSCountedSet]]></title>
    <link href="http://www.citynight.cn/Blog/14778318573153.html"/>
    <updated>2016-10-30T20:50:57+08:00</updated>
    <id>http://www.citynight.cn/Blog/14778318573153.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>NSCountedSet这个一直没有用过,看到其他人使用在此记录下.<br/>
计算老虎机中奖等级的问题：老虎机有四列，每列四个图案，如果四个相同就是等级1，三个相同就是等级2，以此类推。说是用<code>if else</code>太麻烦，有没有什么比较快捷的方法，首先想到的是用KVC中剔除重复数据的办法。比如：</p>
</blockquote>

<pre><code>NSArray *array = @[@2, @2, @2, @1];
NSLog(@&quot;%@&quot;, [array valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;]);
</code></pre>

<p>然后得到数组的个数为2，看起来很合理，如果数组是<code>NSArray *array = @[@2, @1, @2, @1];</code>这时候计算出来的数组个数是也是2，但是正确结果应该是等级3，后来突然想起一个类:NSCountedSet</p>

<pre><code>    NSArray *array = @[@1, @2, @2, @1];
    NSCountedSet *set = [[NSCountedSet alloc]initWithArray:array];

    [set enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
        NSLog(@&quot;%@ =&gt; %d&quot;, obj, [set countForObject:obj]);
    }];

</code></pre>

<pre><code>1 =&gt; 2
2 =&gt; 2
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Qt创建桌面应用程序]]></title>
    <link href="http://www.citynight.cn/Blog/14771170894039.html"/>
    <updated>2016-10-22T14:18:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/14771170894039.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>如果Xcode8下无法正常使用Qt,解决办法参见:<a href="http://www.citynight.cn/Blog/14761943627170.html">http://www.citynight.cn/Blog/14761943627170.html</a></p>
</blockquote>

<p>最终实现的效果:<br/>
<img src="media/14771170894039/14771178501064.jpg" alt=""/></p>

<p><img src="media/14771170894039/14771179340151.jpg" alt=""/></p>

<p>选择桌面应用程序<br/>
<img src="media/14771170894039/14771179611437.jpg" alt=""/></p>

<p><img src="media/14771170894039/14771180181773.jpg" alt=""/></p>

<p>OK,现在项目创建好了&hellip;.接下来就是写代码了&hellip;</p>

<p><img src="media/14771170894039/14771173227361.jpg" alt=""/></p>

<p>然后在<code>mainwindow.cpp</code>文件中编写代码:<br/>
引入需要的头文件</p>

<pre><code>#include &lt;QPainter&gt;
#include &lt;QPen&gt;
#include &lt;math.h&gt;
</code></pre>

<p>在<code>MainWindow</code>中设置窗口位置</p>

<pre><code>    // 设置在桌面上显示的位置&amp;大小
    this-&gt;setGeometry(600,300,600,300);
</code></pre>

<pre><code>void MainWindow::paintEvent(QPaintEvent *e){
        // 定义画笔
        QPainter painter(this);

        // 定义画坐标笔的,宽度,颜色
        QPen pen;
        pen.setWidth(2);
        pen.setColor(Qt::black);

        // 设置属性生效
        painter.setPen(pen);

        // 画坐标
        painter.drawLine(0,150,600,150);
        painter.drawLine(100,0,100,300);

        //将绘画的坐标原点,转移到(100,150)的位置
        painter.translate(100,150);



        //重新设置画正弦颜色和样式

        pen.setColor(Qt::red);

        pen.setStyle(Qt::SolidLine);

        //使设置生效
        painter.setPen(pen);

        //采集 360 个点用于绘图
        QVector&lt;QPointF&gt;pVector;

        for(int i=0; i&lt;360; i++)
        {
            pVector.push_back(QPointF(i,-sin(3.14/180*i)*70));//y 轴坐标,相反

        }

        // 画多点线条
        painter.drawPolyline(pVector);
}
</code></pre>

<p>开心的run下吧..</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 chisel 提高 LLDB 调试效率]]></title>
    <link href="http://www.citynight.cn/Blog/14766672567296.html"/>
    <updated>2016-10-17T09:20:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/14766672567296.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><a href="https://github.com/facebook/chisel">https://github.com/facebook/chisel</a> 英文版使用说明</p>
</blockquote>

<h2 id="toc_0">安装</h2>

<ol>
<li>安装 <a href="http://brew.sh/index_zh-cn.html">Homebrew</a> (如果已经安装了,可以跳过这一步)</li>
</ol>

<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<ol>
<li>更新 Homebrew (如果已经最新了,可以跳过这一步)</li>
</ol>

<pre><code>brew update
</code></pre>

<ol>
<li>通过 Homebrew 安装 chisel</li>
</ol>

<pre><code>brew install chisel
</code></pre>

<ol>
<li>添加 chisel 命令至 ~/.lldbinit</li>
</ol>

<pre><code>touch ~/.lldbinit echo &quot;command script import /usr/local/opt/chisel/libexec/fblldb.py&quot; &gt;&gt; ~/.lldbinit
</code></pre>

<ol>
<li>更新 chisel</li>
</ol>

<pre><code>brew upgrade chisel
</code></pre>

<h2 id="toc_1">使用</h2>

<ol>
<li>通过 <code>pviews</code> 命令直接查看页面层级关系</li>
</ol>

<hr/>

<p>未完&hellip; </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView优化方案(收集)]]></title>
    <link href="http://www.citynight.cn/Blog/14766308131126.html"/>
    <updated>2016-10-16T23:13:33+08:00</updated>
    <id>http://www.citynight.cn/Blog/14766308131126.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">相关文章/博客</h2>

<p><a href="http://www.cocoachina.com/ios/20150906/13212.html">一次 TableView 性能优化经历</a><br/>
<a href="http://blog.jobbole.com/37984/">iOS应用性能调优的25个建议和技巧</a><br/>
<a href="http://longxdragon.github.io/2015/05/26/UITableView%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/">UITableView优化技巧</a><br/>
<a href="http://blog.csdn.net/shang_ri_la/article/details/25954383">UITableView 滚动流畅性优化</a> (备注:这个原始网站挂了,幸好有朋友转载过.)</p>

<h2 id="toc_1">注意点:</h2>

<h4 id="toc_2">1. 列表卡顿问题最好真机测试，有条件的尽量选择低版本硬件和系统进行测试；</h4>

<h4 id="toc_3">2. 使用 Instruments 的 Time Profiler 工具定位造成卡顿时间消耗的位置；</h4>

<h4 id="toc_4">3. 避免 UITableView 的多次刷新( reloadData )，尤其 Xib 加载 UITableView 时避免首次自动加载；</h4>

<h4 id="toc_5">4. 为 Cell 专门定义显示 Model；</h4>

<h4 id="toc_6">5. Model 需要包含已提前计算出的 Cell 高度；</h4>

<h4 id="toc_7">6. 对于显示的 NSString，提前在 Model 中组装完成，避免在 Cell 中组装转换；</h4>

<h4 id="toc_8">7. 对于需要加载的网络图片链接，提前在 Model 中组装完成 NSURL,避免在 Cell 中组装转换；</h4>

<h4 id="toc_9">8. 尽量减少 Cell 中的逻辑判断和运算并使用正确的数据格式;</h4>

<h4 id="toc_10">9. 避免在 Cell 中反复创建 View,最好在初始化时一并创建，通过设置 Hidden 属性控制显示和隐藏;</h4>

<h4 id="toc_11">10. 对于 UIImageView ,注意加载的图片大小是否与控件大小一致，尽量保持一致；</h4>

<h4 id="toc_12">11. 正确使用 reuseIdentifier</h4>

<pre><code>static NSString *CellIdentifier = @&quot;MyFancyCell&quot;;
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];

</code></pre>

<h4 id="toc_13">12. 尽量把所有的 UIView 以及其子类控件设置为不透明（Opaque = YES）,你可以在模拟器中用Debug\Color Blended Layers选项来发现哪些view没有被设置为opaque。目标就是，能设为opaque的就全设为opaque!</h4>

<h4 id="toc_14">13. 尽量避免图片压缩，模拟器条件下使用 Debug\Color Misaligned Images 选项检查像素是否对其:如果图片边界没有与目标像素完美对齐，该功能可为图片叠加上一层品红色。如果图片使用确定的比例大小绘制，那么该功能会为图片添加一层黄色叠加。真机条件下使用 Instrument 中的 Core Animation 工具检查；</h4>

<h4 id="toc_15">14. 使用 shadowPath 来画阴影;</h4>

<pre><code>#import &lt;QuartzCore/QuartzCore.h&gt;

// Somewhere later ...
UIView *view = [[UIView alloc] init];

// Setup the shadow ...
view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);
view.layer.shadowRadius = 5.0f;
view.layer.shadowOpacity = 0.6;
</code></pre>

<h4 id="toc_16">15. 减少 subviews 的数量;</h4>

<h4 id="toc_17">16. 尽量不使用 cellForRowAtIndexPath: ，如果你需要用到它，只用一次然后缓存结果；</h4>

<h4 id="toc_18">17. 使用 Autorelease Pool；</h4>

<pre><code>NSArray *urls = &lt;# An array of file URLs #&gt;;
for (NSURL *url in urls) {
    @autoreleasepool {
        NSError *error;
        NSString *fileContents = [NSString stringWithContentsOfURL:url
                                         encoding:NSUTF8StringEncoding error:&amp;error];
    }
}
</code></pre>

<h4 id="toc_19">18. 选择是否需要缓存；</h4>

<pre><code>UIImage *img = [UIImage imageNamed:@&quot;myImage&quot;]; // caching

// or
 UIImage *img = [UIImage imageWithContentsOfFile:@&quot;myImage&quot;]; // no caching
</code></pre>

<p>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用 imageWithContentsOfFile 足矣，这样不会浪费内存来缓存它。然而，在图片反复重用的情况下 imageNamed 是一个好得多的选择。</p>

<h4 id="toc_20">19. 避免日期格式转换；相关日期显示应该在 Model 中定义完成。</h4>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UILabel边缘出现黑线]]></title>
    <link href="http://www.citynight.cn/Blog/14766298858600.html"/>
    <updated>2016-10-16T22:58:05+08:00</updated>
    <id>http://www.citynight.cn/Blog/14766298858600.html</id>
    <content type="html"><![CDATA[
<p>问题:代码实现 UILabel 时出现的边缘黑线问题<br/>
原因:当 UILabel 的宽高出现浮点型数字时,在高清屏下有可能出现右侧边缘黑线问题, 解决方法是使用 <code>CGRectIntegral()</code> 方法确保 <code>frame</code> 中不存在非整形数值</p>

<pre><code>label.frame = CGRectIntegral(CGRectMake(0, 0, ceil(width),40));
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 模拟器 添加图片到相册的小技巧]]></title>
    <link href="http://www.citynight.cn/Blog/14765420394973.html"/>
    <updated>2016-10-15T22:33:59+08:00</updated>
    <id>http://www.citynight.cn/Blog/14765420394973.html</id>
    <content type="html"><![CDATA[
<p>把图片拖到模拟器主屏幕,或者Safari中,保存图片7 <br/>
<img src="media/14765420394973/tips.gif" alt="tips"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串frame相关]]></title>
    <link href="http://www.citynight.cn/Blog/14765391593705.html"/>
    <updated>2016-10-15T21:45:59+08:00</updated>
    <id>http://www.citynight.cn/Blog/14765391593705.html</id>
    <content type="html"><![CDATA[
<p>开发中常用到计算字符串的size或者rect</p>

<p>经常见到如下接口:</p>

<pre><code>- (CGSize)sizeWithAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs NS_AVAILABLE(10_0, 7_0);

- (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context NS_AVAILABLE(10_11, 7_0);
</code></pre>

<p>项目中使用的例子:</p>

<pre><code>    // shopNameLabel frame
    {
        CGSize stringSize = [self.shopNameLabel.text sizeWithAttributes:@{NSFontAttributeName: self.shopNameLabel.font}];
        self.shopNameLabel.frame = CGRectMake(margin, margin, ceil(stringSize.width), ceil(stringSize.height));
    }
</code></pre>

<pre><code>    // addressLabel frame
    {
        CGFloat lwidth = width - imageWH - 3*margin;
        
        CGSize stringSize = [self.addressLabel.text boundingRectWithSize:CGSizeMake(lwidth, self.addressLabel.font.lineHeight *self.addressLabel.numberOfLines) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName: self.addressLabel.font} context:nil].size;
        self.addressLabel.frame = CGRectMake(margin, ceil(CGRectGetMaxY(self.juliLabel.frame) + margin), stringSize.width, stringSize.height);
    }

</code></pre>

<p>由于经常使用,所以我把这些都抽取成代码块,方便调用.</p>

<p>其中由于需要预估字符串的高度,<code>boundingRectWithSize</code>,由于iOS所提供的默认字体是可能变化的,所以这里我们不能凭借经验10号字体默认高度就是10,这是不准确的.使用<code>self.addressLabel.font.lineHeight</code>应该使用行高来计算.并且显示的行数也不要写死,需要写成 <code>self.addressLabel.numberOfLines</code>.这样做才能得到想要的效果.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim 学习]]></title>
    <link href="http://www.citynight.cn/Blog/14764220018619.html"/>
    <updated>2016-10-14T13:13:21+08:00</updated>
    <id>http://www.citynight.cn/Blog/14764220018619.html</id>
    <content type="html"><![CDATA[
<p>开发中如果遇到修改配置文件的时候经常用到 vim .今天把常用到的 vim 命令进行简单的总结</p>

<h2 id="toc_0">开始学习 vim</h2>

<p>在 terminal 中输入  <code>vimtutor -g zh</code> 就会开始 vim  学习教程 </p>

<h2 id="toc_1">简单总结</h2>

<h3 id="toc_2">vim 编辑器中有三种状态模式</h3>

<p><img src="media/14764220018619/14768675919240.jpg" alt=""/></p>

<h3 id="toc_3">vim 编辑器的启动与退出</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>释意</th>
</tr>
</thead>

<tbody>
<tr>
<td>$ vim</td>
<td>直接进入编辑环境</td>
</tr>
<tr>
<td>$ vim myfile</td>
<td>进入编辑环境并打开(新建)文件</td>
</tr>
<tr>
<td>:q</td>
<td>退出 vi 编辑环境</td>
</tr>
</tbody>
</table>

<h3 id="toc_4">文件操作</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>释意</th>
</tr>
</thead>

<tbody>
<tr>
<td>:w</td>
<td>保存对 vim 编辑器中已打开文件的修改</td>
</tr>
<tr>
<td>:w myfile</td>
<td>将 vim 编辑器中的内容另存为指定文件名</td>
</tr>
<tr>
<td>:wq</td>
<td>对 vim 编辑器中的文件进行保存并退出 vim 编辑器</td>
</tr>
<tr>
<td>:q!</td>
<td>放弃对文件内容的修改,并退出 vi 编辑器</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">光标移动操作</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>光标操作</th>
<th>释意</th>
</tr>
</thead>

<tbody>
<tr>
<td>光标移动</td>
<td>h</td>
<td>向左移动光标</td>
</tr>
<tr>
<td></td>
<td>l</td>
<td>向右移动光标</td>
</tr>
<tr>
<td></td>
<td>k</td>
<td>向上移动光标</td>
</tr>
<tr>
<td></td>
<td>j</td>
<td>向下移动光标</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>翻页</td>
<td>Ctrl + f</td>
<td>向下翻整页</td>
</tr>
<tr>
<td></td>
<td>Ctrl + b</td>
<td>向上翻整页</td>
</tr>
<tr>
<td></td>
<td>Ctrl + u</td>
<td>向上翻半页</td>
</tr>
<tr>
<td></td>
<td>Ctrl + d</td>
<td>向下翻半页</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>行内移动光标</td>
<td>^</td>
<td>将光标快速跳转到本行的行首字符</td>
</tr>
<tr>
<td></td>
<td>$</td>
<td>将光标快速跳转到本行的行尾字符</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>文件内跳转</td>
<td>:set nu</td>
<td>在编辑器中显示行号</td>
</tr>
<tr>
<td></td>
<td>:set nonu</td>
<td>取消编辑器中的行号显示</td>
</tr>
<tr>
<td></td>
<td>1G(gg)</td>
<td>跳转到文件的首行</td>
</tr>
<tr>
<td></td>
<td>G</td>
<td>跳转到文件的末尾行</td>
</tr>
<tr>
<td></td>
<td>#G</td>
<td>跳转到文件中的第#行</td>
</tr>
</tbody>
</table>

<h3 id="toc_6">编辑操作</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>光标操作</th>
<th>释意</th>
</tr>
</thead>

<tbody>
<tr>
<td>进入输入模式</td>
<td>i</td>
<td>在当前光标处进入插入状态</td>
</tr>
<tr>
<td></td>
<td>a</td>
<td>在当前光标后进入插入状态</td>
</tr>
<tr>
<td></td>
<td>o</td>
<td>在当前行的下面插入新行,光标移动到新行的行首,进入插入状态</td>
</tr>
<tr>
<td></td>
<td>O</td>
<td>在当前行的上面插入新行,光标移动到新行的行首,进入插入状态</td>
</tr>
<tr>
<td></td>
<td>c(n)w</td>
<td>删除当前光标到所在单词尾部的字符,并进入插入状态</td>
</tr>
<tr>
<td></td>
<td>c$</td>
<td>删除当前光标到行尾的字符,并进入插入状态</td>
</tr>
<tr>
<td></td>
<td>c^</td>
<td>命令删除当前光标之前(不包括光标上的字符)到行首的字符,并进入插入状态</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>删除操作</td>
<td>x</td>
<td>删除光标处的单个字符</td>
</tr>
<tr>
<td></td>
<td>(n)dd</td>
<td>删除光标所 n 行</td>
</tr>
<tr>
<td></td>
<td>:3,5 d</td>
<td>删除从第 3 行到第 5 行的内容</td>
</tr>
<tr>
<td></td>
<td>dw</td>
<td>删除当前字符到单词尾(包括空格)的所有字符</td>
</tr>
<tr>
<td></td>
<td>de</td>
<td>删除当前字符到单词尾(不包括单词尾部的空格)的所有字符</td>
</tr>
<tr>
<td></td>
<td>d$</td>
<td>删除当前字符到行尾的所有字符</td>
</tr>
<tr>
<td></td>
<td>d^</td>
<td>删除当前字符到行首的所有字符</td>
</tr>
<tr>
<td></td>
<td>J(大写)</td>
<td>删除光标所在行行尾的换行符,相当于合并当 前行和下一行的内容</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>拷贝和粘贴</td>
<td>(n)yy</td>
<td>复制当前行整行的内容到 vi 缓冲区</td>
</tr>
<tr>
<td></td>
<td>:3,6 co(m) 12</td>
<td>复制(剪切)3-6 行,到第 12 行处</td>
</tr>
<tr>
<td></td>
<td>p</td>
<td>读取 vi 缓冲区中的内容,并粘贴到光标当前的位置(不覆盖文件已有的内容)</td>
</tr>
<tr>
<td></td>
<td>u</td>
<td>取消最近一次的操作,并恢复操作结果可以多次使用 u命令恢复已进行的多步操作</td>
</tr>
<tr>
<td></td>
<td>U</td>
<td>取消对当前整行进行的所有操作</td>
</tr>
<tr>
<td></td>
<td>Ctrl + r</td>
<td>对使用 u 命令撤销的操作进行恢复</td>
</tr>
</tbody>
</table>

<h3 id="toc_7">查找与替换操作</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>光标操作</th>
<th>释意</th>
</tr>
</thead>

<tbody>
<tr>
<td>查找</td>
<td>/word</td>
<td>从上而下在文件中查找字符串“word”</td>
</tr>
<tr>
<td></td>
<td>?word</td>
<td>从下而上在文件中查找字符串“word”</td>
</tr>
<tr>
<td></td>
<td>n</td>
<td>定位下一个匹配的被查找字符串</td>
</tr>
<tr>
<td></td>
<td>N</td>
<td>定位上一个匹配的被查找字符串</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>替换</td>
<td>:s/old/new</td>
<td>将当前行中查找到的第一个字符“old” 串替换为“new”</td>
</tr>
<tr>
<td></td>
<td>:s/old/new/g</td>
<td>将当前行中查找到的所有字符串“old” 替换为“new”</td>
</tr>
<tr>
<td></td>
<td>:#,#s/old/new/g</td>
<td>在行号“#,#”范围内替换所有的字符串“old”为“new”</td>
</tr>
<tr>
<td></td>
<td>:%s/old/new/g</td>
<td>在整个文件范围内替换所有的字符串“old”为“new”</td>
</tr>
</tbody>
</table>

<h2 id="toc_8">简易配置</h2>

<p>输入 vim ~/.vimrc 该文件是一个隐藏文件,如果没有则 创建它,该文件中保存一些,vim 的常用配置。</p>

<pre><code>set nu //代码显示行号
syntax on //关键词高亮显示
set cindent //c 语法自动缩进
set autoindent //新行自动缩进
set shiftwidth=4 //缩进宽度 4
set tabstop=4 //tab 键宽度 4
set softtabstop=4 //制表符宽度 4
set nobackup //不备份
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在包含UITableView视图中添加单击手势]]></title>
    <link href="http://www.citynight.cn/Blog/14762437833792.html"/>
    <updated>2016-10-12T11:43:03+08:00</updated>
    <id>http://www.citynight.cn/Blog/14762437833792.html</id>
    <content type="html"><![CDATA[
<p>如果在包含UITableView视图中添加单击手势，这个单击手势会屏蔽掉UITableView的</p>

<pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>可以利用<code>UIGestureRecognizer</code>的<code>Delegate</code>中的</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;
</code></pre>

<p>在单击点位于UITableView内的时候取消响应</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
    CGPoint point = [gestureRecognizer locationInView:self];
    if(CGRectContainsPoint(menuTableView.frame, point)){
        return NO;
    }
    return YES;
}
</code></pre>

<p>或者将单击手势的cancelsTouchesInView设置为NO</p>

<pre><code>singleTap.cancelsTouchesInView = NO;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级到Xcode8后Qt无法正常使用]]></title>
    <link href="http://www.citynight.cn/Blog/14761943627170.html"/>
    <updated>2016-10-11T21:59:22+08:00</updated>
    <id>http://www.citynight.cn/Blog/14761943627170.html</id>
    <content type="html"><![CDATA[
<p>错误信息:</p>

<blockquote>
<p>Project ERROR: Xcode not set up properly. You may need to confirm the license agreement by running /usr/bin/xcodebuild.</p>
</blockquote>

<p>解决办法:<br/>
<strong>&gt;= Xcode 8</strong></p>

<p>In Xcode 8, as Bruce said, this happens when Qt tries to find <code>xcrun</code> when it should be looking for <code>xcodebuild</code>.</p>

<p><strong>Step 1:</strong></p>

<p>Open the file:</p>

<pre><code>Qt_install_folder/5.7/clang_64/mkspecs/features/mac/default_pre.prf
</code></pre>

<p><strong>Step 2:</strong></p>

<p>Replace:</p>

<pre><code>isEmpty($$list($$system(&quot;/usr/bin/xcrun -find xcrun 2&gt;/dev/null&quot;)))
</code></pre>

<p>With:</p>

<pre><code>isEmpty($$list($$system(&quot;/usr/bin/xcrun -find xcodebuild 2&gt;/dev/null&quot;)))
</code></pre>

<p><strong>~&gt; Xcode 8</strong></p>

<p>Before Xcode 8, this problem occurs when command line tools are installed after Xcode is installed. What happens is the <code>Xcode-select</code> developer directory gets pointed to <code>/Library/Developer/CommandLineTools</code>.</p>

<p><strong>Step 1:</strong></p>

<p>Point <code>Xcode-select</code> to the correct Xcode Developer directory with the command:</p>

<pre><code>sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer
</code></pre>

<p><strong>Step 2:</strong></p>

<p>Confirm the license agreement with the command:</p>

<pre><code>xcodebuild -license
</code></pre>

<p>This will prompt you to read through the license agreement.</p>

<p>Enter <code>agree</code> to accept the terms.</p>

<p>详见stackoverflow 中 <a href="http://stackoverflow.com/questions/33728905/qt-creator-project-error-xcode-not-set-up-properly-you-may-need-to-confirm-t">Qt Creator - Project ERROR: Xcode not set up properly. You may need to confirm the license agreement by running /usr/bin/xcodebuild</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优秀文章链接收藏]]></title>
    <link href="http://www.citynight.cn/Blog/14760921807707.html"/>
    <updated>2016-10-10T17:36:20+08:00</updated>
    <id>http://www.citynight.cn/Blog/14760921807707.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">优化</h2>

<p><a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-3-imp-deluxe.html">极致优化</a></p>

<p>美团点评技术团队: <a href="http://tech.meituan.com/DiveIntoMethodCache.html">深入理解Objective-C：方法缓存</a></p>

<h2 id="toc_1">Runloop</h2>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a>  &mdash; 内部分享文章runloop中使用了该文章中的一张图.</p>

<h2 id="toc_2">GCD</h2>

<p><a href="http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1">GCD 深入理解：第一部分</a> 中文翻译:<a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">译文</a><br/>
<a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md">GCD 深入理解：第二部分</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[怎样让内存缓存变稳定]]></title>
    <link href="http://www.citynight.cn/Blog/14752152861722.html"/>
    <updated>2016-09-30T14:01:26+08:00</updated>
    <id>http://www.citynight.cn/Blog/14752152861722.html</id>
    <content type="html"><![CDATA[
<p>项目中如果显示图片比较多,会遇到内存涨的比较厉害,项目中用到 SDWebImage, 所以可以很简单的让内存缓存变稳定:</p>

<pre><code>-(void)scrollViewDidScroll:(UIScrollView *)scrollView {
    [[SDImageCache sharedImageCache] clearMemory];
}
</code></pre>

<p>原理:</p>

<pre><code>- (void)clearMemory {
    [self.memCache removeAllObjects];
}
</code></pre>

<p>_memCache 是 NSCache 类型的,</p>

<p>没有做任何操作的时候大概是这个样子的<br/>
<img src="media/14752152861722/14752174866625.jpg" alt=""/></p>

<p>添加clearMemory后:<br/>
<img src="media/14752152861722/14752177858503.jpg" alt=""/></p>

<p>这也是为什么滚动后屏幕上还显示图片的原因.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoapods的安装]]></title>
    <link href="http://www.citynight.cn/Blog/14751288042220.html"/>
    <updated>2016-09-29T14:00:04+08:00</updated>
    <id>http://www.citynight.cn/Blog/14751288042220.html</id>
    <content type="html"><![CDATA[
<pre><code>1.先升级Gem
    sudo gem update --system
2.切换cocoapods的数据源
    【先删除，再添加，查看】
    gem sources --remove https://rubygems.org/
    gem sources -a https://ruby.taobao.org/
    gem sources -l
3.安装cocoapods
    sudo gem install cocoapods
    或者（如10.11系统）sudo gem install -n /usr/local/bin cocoapods
4.(可忽略)将Podspec文件托管地址从github切换到国内的oschina
    【先删除，再添加，再更新】
    pod repo remove master
    pod repo add master http://git.oschina.net/akuandev/Specs.git
    pod repo add master https://gitcafe.com/akuandev/Specs.git
    pod repo update
5.设置pod仓库
    pod setup
6.测试
    【如果有版本号，则说明已经安装成功】
    pod --version
7.利用cocoapods来安装第三方框架
    01 进入要安装框架的项目的.xcodeproj同级文件夹
    02 在该文件夹中新建一个文件podfile
    03 在文件中告诉cocoapods需要安装的框架信息
        a.该框架支持的平台
        b.适用的iOS版本
        c.框架的名称
        d.框架的版本
8.安装
pod install --no-repo-update
pod update --no-repo-update

9.说明
platform :ios, &#39;8.0&#39; 用来设置所有第三方库所支持的iOS最低版本
pod &#39;SDWebImage&#39;,&#39;~&gt;2.6&#39; 设置框架的名称和版本号
版本号的规则：
&#39;&gt;1.0&#39;    可以安装任何高于1.0的版本
&#39;&gt;=1.0&#39;   可以安装任何高于或等于1.0的版本
&#39;&lt;1.0&#39;    任何低于1.0的版本
&#39;&lt;=1.0&#39;   任何低于或等于1.0的版本
&#39;~&gt;0.1&#39;   任何高于或等于0.1的版本，但是不包含高于1.0的版本
&#39;~&gt;0&#39;     任何版本，相当于不指定版本，默认采用最新版本号

10.使用pod install命令安装框架后的大致过程：
01 分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么cocoaPods会自动设置一个兼容的版本。
02 下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。
03 生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。
04 整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在UIBarButtonItem上显示数字(BadgeValue)]]></title>
    <link href="http://www.citynight.cn/Blog/14747835330079.html"/>
    <updated>2016-09-25T14:05:33+08:00</updated>
    <id>http://www.citynight.cn/Blog/14747835330079.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原因：项目中想要实现购物车右上角显示购物车中上品数量，但是直接用UIBarButtonItem不能实现要求</p>
</blockquote>

<p>这里是实现后的效果图：</p>

<p><img src="media/14747835330079/strip." alt="购物车动画"/></p>

<p>一开始直接创建的UIBarButtonItem，但是不能直接往上面添加想要的效果，因为</p>

<pre><code>NS_CLASS_AVAILABLE_IOS(2_0) @interface UIBarButtonItem : UIBarItem &lt;NSCoding&gt;
</code></pre>

<p>而且</p>

<pre><code>NS_CLASS_AVAILABLE_IOS(2_0) @interface UIBarItem : NSObject &lt;NSCoding, UIAppearance&gt;
</code></pre>

<p>退而求其次，我们知道UIBarButtonItem有一个属性</p>

<pre><code>@property(nullable, nonatomic,strong)  __kindof UIView     *customView;       // default is nil
</code></pre>

<p>这说明我们可以使用UIButton来代替UIBarButtonItem，在UIButton上面添加想要的动画效果。</p>

<pre><code>    static CGFloat const kButtonWidth = 43.0f;
    static CGFloat const kButtonHeight = 43.0f;

    UIImage *cartImage = [[UIImage imageNamed:@&quot;iconfont-cart&quot;]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];

    UIButton *cartButton = [UIButton buttonWithType:UIButtonTypeCustom];
    cartButton.frame = CGRectMake(0.0f, 0.0f, kButtonWidth, kButtonHeight);
    cartButton.backgroundColor = [UIColor clearColor];
    [cartButton setImage:cartImage forState:UIControlStateNormal];
    [cartButton setImageEdgeInsets:UIEdgeInsetsMake(0.0f,(kButtonHeight- cartImage.size.width), 0.0f, 0.0f)];
    [cartButton addTarget:self action:@selector(changeStatus:) forControlEvents:UIControlEventTouchUpInside];
    [cartButton addSubview:self.numberLabel];

    UIBarButtonItem *rightBarButtonItem = [[UIBarButtonItem alloc]initWithCustomView:cartButton];
    self.navigationItem.rightBarButtonItem = rightBarButtonItem;
</code></pre>

<p>创建Label使用懒加载：</p>

<pre><code>#pragma mark 购物车上面显示的按钮
-(UILabel *)numberLabel
{
    if (!_numberLabel) {

        static CGFloat const kNameLabelWidth = 14;
        static CGFloat const kNameLabelHeight = 14;
        static CGFloat const kNameLabelX = 40; // 父视图宽44，UI说改到这个位置
        static CGFloat const kNameLabelY = 6;

        _numberLabel = [UILabel new];
        _numberLabel.hidden = YES;
        _numberLabel.frame = CGRectMake(kNameLabelX, kNameLabelY, kNameLabelWidth, kNameLabelHeight);

        _numberLabel.backgroundColor = [UIColor redColor];
        _numberLabel.textColor = [UIColor whiteColor];
        _numberLabel.font = [UIFont systemFontOfSize:9];
        _numberLabel.textAlignment = NSTextAlignmentCenter;
        _numberLabel.layer.cornerRadius = kNameLabelHeight * 0.5;
        _numberLabel.layer.masksToBounds = YES;

    }
    return _numberLabel;
}
</code></pre>

<p>这里说下为什么设置为hidden，因为要求数量为0的时候不显示，数量不为0显示，如果删除后还要添加不如直接控制hidden。<br/>
其他的就是设置Label显示的数字了，这里就不写了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何解决json字符串中包含制表符]]></title>
    <link href="http://www.citynight.cn/Blog/14747833011771.html"/>
    <updated>2016-09-25T14:01:41+08:00</updated>
    <id>http://www.citynight.cn/Blog/14747833011771.html</id>
    <content type="html"><![CDATA[
<p>错误信息:</p>

<pre><code>Error Domain=NSCocoaErrorDomain Code=3840 &quot;The operation couldn’t be completed. (Cocoa error 3840.)&quot; (Unescaped control character around character 135.) UserInfo=0x170e79d00 {NSDebugDescription=Unescaped control character around character 135.}
</code></pre>

<p><strong>如何处理</strong><br/>
最关键的地方:</p>

<pre><code>-(NSString *)removeUnescapedCharacter:(NSString *)inputStr
{
    NSCharacterSet *controlChars = [NSCharacterSet controlCharacterSet];//获取那些特殊字符
    NSRange range = [inputStr rangeOfCharacterFromSet:controlChars];//寻找字符串中有没有这些特殊字符
    if (range.location != NSNotFound)
        {
        NSMutableString *mutable = [NSMutableString stringWithString:inputStr];
        while (range.location != NSNotFound)
            {
            [mutable deleteCharactersInRange:range];//去掉这些特殊字符
            range = [mutable rangeOfCharacterFromSet:controlChars];
            }
        return mutable;
        }
    return inputStr;
}
</code></pre>

<p>举例:</p>

<pre><code>    NSString *responseString = [NSMutableString stringWithString:[request responseString]];
    responseString =[self removeUnescapedCharacter:responseString];
    NSData *jsonData = [responseString dataUsingEncoding:NSUTF8StringEncoding];
    NSError *error;
    NSDictionary * dic = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;error];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS10 遇到问题总结]]></title>
    <link href="http://www.citynight.cn/Blog/14743674179375.html"/>
    <updated>2016-09-20T18:30:17+08:00</updated>
    <id>http://www.citynight.cn/Blog/14743674179375.html</id>
    <content type="html"><![CDATA[
<p>iOS10 用户权限设置新增，在info.plist文件中，新增字段：</p>

<table>
<thead>
<tr>
<th>权限</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>相册权限</td>
<td>Privacy - Photo Library Usage Description</td>
<td>string类型的文字说明</td>
</tr>
<tr>
<td>相机权限</td>
<td>NSCameraUsageDescription</td>
<td>string类型的文字说明</td>
</tr>
<tr>
<td>麦克风权限</td>
<td>NSMicrophoneUsageDescription</td>
<td>string类型的文字说明</td>
</tr>
<tr>
<td>定位权限</td>
<td>NSLocationWhenInUseUsageDescription</td>
<td>string类型的文字说明</td>
</tr>
</tbody>
</table>

<p>iOS10 新用户下载app，使用以上前3种权限，如果不添加授权描述，会导致程序崩溃</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转发机制]]></title>
    <link href="http://www.citynight.cn/Blog/14733118707964.html"/>
    <updated>2016-09-08T13:17:50+08:00</updated>
    <id>http://www.citynight.cn/Blog/14733118707964.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>基本逻辑来源自官方文档 <a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html">Message Forwarding</a> ,这里只做相关例子的解析.</p>
</blockquote>

<p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以 [object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运 行时才能确定object是否能接收message消息。如果不能，则程序崩溃。<br/>
通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：</p>

<pre><code>if ([self respondsToSelector:@selector(method)]) {
    [self performSelector:@selector(method)];
}
</code></pre>

<p>当不使用<code>respondsToSelector:</code>判断时,就会启动&#39;消息转发(message forwarding)&lsquo;机制,通过这一机制我们可以告诉对象如何处理未知的消息.如果不做任何处理会导致程序崩溃,我们可以看到异常信息如下:</p>

<pre><code>2016-09-08 13:26:53.094 selfsuper[65176:7154658] -[Student eat]: unrecognized selector sent to instance 0x7ff1b9f9f690
2016-09-08 13:26:53.103 selfsuper[65176:7154658] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[Student eat]: unrecognized selector sent to instance 0x7ff1b9f9f690&#39;
</code></pre>

<p>这段异常信息实际上是由NSObject的<code>doesNotRecognizeSelector</code>方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>

<p>消息转发机制基本上分为三个步骤：</p>

<ol>
<li><p>动态方法解析</p></li>
<li><p>备用接收者</p></li>
<li><p>完整转发</p></li>
</ol>

<h2 id="toc_0">动态方法解析</h2>

<p>对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或 者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经 实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。如下代码所示：</p>

<pre><code>// void(*)()
// 默认方法都有两个隐式参数，
void eat(id self,SEL sel)
{
    NSLog(@&quot;%@ %@&quot;,self,NSStringFromSelector(sel));
}

// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.
// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    if (sel == NSSelectorFromString(@&quot;eat&quot;)) {
        // 动态添加eat方法
        
        // 第一个参数：给哪个类添加方法
        // 第二个参数：添加方法的方法编号
        // 第三个参数：添加方法的函数实现（函数地址）
        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd
        class_addMethod(self, NSSelectorFromString(@&quot;eat&quot;), (IMP)eat, &quot;v@:&quot;);
        
    }
    
    return [super resolveInstanceMethod:sel];
}

</code></pre>

<p>不过这种方案更多的是为了实现@dynamic属性。</p>

<h2 id="toc_1">备用接收者</h2>

<p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>

<pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector
</code></pre>

<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p>

<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>

<pre><code>/**
 * 测试消息转发
 */
-(id)forwardingTargetForSelector:(SEL)aSelector {
    NSLog(@&quot;消息转发&quot;);
    NSString *selectorString = NSStringFromSelector(aSelector);
    if ([selectorString isEqualToString:@&quot;eat2&quot;]){
        // 将消息转给 RuntimeHelper 对象,让他来处理
        return [RuntimeHelper new];
    }
    return [super forwardingTargetForSelector:aSelector];
}

</code></pre>

<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。如果需要修改参数和返回值,可以使用完整消息转发.</p>

<h2 id="toc_2">完整消息转发</h2>

<p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法:</p>

<pre><code>- (void)forwardInvocation:(NSInvocation *)anInvocation
</code></pre>

<p>完整代码:</p>

<pre><code>/**
 *  完整的消息转发
 */

/* 必须重写 (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
 * 消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。
 */
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];
    
    if (!signature) {
        if ([RuntimeHelper instancesRespondToSelector:aSelector]) {
            signature = [RuntimeHelper instanceMethodSignatureForSelector:aSelector];
        }
    }
    
    return signature;
}

-(void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([RuntimeHelper instanceMethodSignatureForSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:[RuntimeHelper new]];
    }
}
</code></pre>

<p>关于 NSInvocation 可以参见<a href="https://github.com/Mekor/MKExtension">MKExtension</a>中<code>NSObject+SEL</code>,里面有关于 NSInvocation 的应用.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop]]></title>
    <link href="http://www.citynight.cn/Blog/14731740142157.html"/>
    <updated>2016-09-06T23:00:14+08:00</updated>
    <id>http://www.citynight.cn/Blog/14731740142157.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1. 什么是runloop</h2>

<p>Run loops 是线程相关的的基础框架的一部分。一个 run loop 就是一个事件处理 的循环,用来不停的调度工作以及处理输入事件。使用 run loop 的目的是让你的线程在有工作的时候忙于工作,而没工作的时候处于休眠状态。<br/>
runloop就是运行循环,它的基本作用就是让程序持续运行,处理App中的各种事件(触摸,定时器,Selector).<br/>
main函数中UIApplicationMain内部就启动了一个runloop,这样UIApplicationMain就会一直没有返回值,保持了程序的持续运行.这个默认的runloop是跟主线程相关联的.</p>

<h2 id="toc_1">2. RunLoop与线程</h2>

<p>每条线程都有唯一的一个与之对应的RunLoop对象,主线程的RunLoop启动的时候已经默认创建好了,其他线程的RunLoop需要主动创建(RunLoop在第一次获取的时候创建,在线程结束的时候销毁)</p>

<h2 id="toc_2">3. RunLoop对象</h2>

<h4 id="toc_3">iOS中有2套API来访问和使用runloop</h4>

<ul>
<li> Foundation -&gt; NSRunLoop</li>
<li> Core Foundation -&gt; CFRunLoopRef</li>
</ul>

<p>NSRunLoop和CFRunLoopRef都是runloop对象.NSRunLoop是基于CFRunLoopRef的一层OC封装</p>

<h4 id="toc_4">获得RunLoop对象</h4>

<ul>
<li><p>Foundation </p>

<pre><code class="language-objc">[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象
[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象
</code></pre></li>
<li><p>Core Foundation </p>

<pre><code class="language-objc">CFRunLoopGetCurrent(): // 获得当前线程的RunLoop对象
CFRunLoopGetMain(): //获得主线程的RunLoop对象
</code></pre></li>
</ul>

<h2 id="toc_5">4. RunLoop相关类</h2>

<h3 id="toc_6">Core Foundation中关于RunLoop的5个类</h3>

<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>

<p>网上其他人博客总结(图一):<br/>
<img src="media/14731740142157/14731758243846.jpg" alt=""/></p>

<h3 id="toc_7">CFRunLoopModeRef(Run Loop 模式)</h3>

<p><strong>CFRunLoopModeRef代表RunLoop的运行模式</strong>  一个RunLoop包含若干个Mode,每个Mode又包含若干个Source/Timer/Observer. 每次RunLoop启动时,只能指定其中一个Mode,这个Mode被称之为CurrentMode. 如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入. 这样做主要是为了分隔开不同组的Source/Timer/Observer,让他们互不影响.</p>

<p>Run loop 模式是所有要监视的输入源和定时源以及要通知的 run loop 注册观察者的集合。每次运行你的 run loop,你都要指定(无论显示还是隐式)其运行个模式。在 run loop 运行过程中,只有和模式相关的源才会被监视并允许他们传递事件消息。(类似的,只有和模式相关的观察者会通知 run loop 的进程)。和其他模式关联的源只有在 run loop 运行在其模式下才会运行,否则处于暂停状态。</p>

<h3 id="toc_8">CFRunLoopModeRef</h3>

<p><strong>系统默认注册了5个Mode:</strong></p>

<ul>
<li><p><strong>kCFRunLoopDefaultMode:</strong> App的默认Mode，通常主线程是在这个Mode下运行</p></li>
<li><p><strong>UITrackingRunLoopMode:</strong> 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</p></li>
<li><p><strong>UIInitializationRunLoopMode:</strong> 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</p></li>
<li><p><strong>GSEventReceiveRunLoopMode:</strong> 接受系统事件的内部 Mode，通常用不到</p></li>
<li><p><strong>kCFRunLoopCommonModes:</strong> 这是一个占位用的Mode，不是一种真正的Mode</p></li>
</ul>

<p>Cocoa 和 Core foundation 定义了一个默认的和一些常用的模式,通常在代码中都是用字符串来标识这些模式。当然你也可以给模式名称指定一个字符串来自定义模式.<br/>
runloop一启动就会选中一种模式，当选中了一种模式之后其它的模式就都不鸟。一个mode里面可以添加多个NSTimer(见上面图一),也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。</p>

<h3 id="toc_9">CFRunLoopSourceRef</h3>

<p><strong>CFRunLoopSourceRef是事件源（输入源）</strong></p>

<p>输入源异步的发送消息给你的线程。事件来源取决于输入源的种类:基于端口的输入源和自定义输入源。基于端口的输入源监听程序相应的端口。自定义输入源则监听自定义的事件源。至于 run loop,它不关心输入源的是基于端口的输入源还是自 定义的输入源。系统会实现两种输入源供你使用。两类输入源的区别在于如何显示: 基于端口的输入源由内核自动发送,而自定义的则需要人工从其他线程发送。</p>

<p>当你创建输入源,你需要将其分配给 run loop 中的一个或多个模式。模式只会 在特定事件影响监听的源。大多数情况下,run loop 运行在默认模式下,但是你也 可以使其运行在自定义模式。若某一源在当前模式下不被监听,那么任何其生成的消 息只在 run loop 运行在其关联的模式下才会被传递。</p>

<p>以前的分法:<br/>
Port-Based Sources<br/>
Custom Input Sources<br/>
Cocoa Perform Selector Sources</p>

<p>现在的分法:<br/>
Source0：非基于Port的<br/>
Source1：基于Port的</p>

<h3 id="toc_10">CFRunLoopTimerRef</h3>

<p><strong>CFRunLoopTimerRef是基于时间的触发器</strong></p>

<h4 id="toc_11">NSTimer:</h4>

<pre><code>- (void)timer2
{
    //NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultMode

    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];

    //更改模式
    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];

}

- (void)timer1
{
    //    [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];

    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];

    //定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作
    //    [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];

    //定时器添加到NSDefaultRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作
    //    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];

    //占位模式：common modes标记
    //被标记为common modes的模式 kCFRunLoopDefaultMode  UITrackingRunLoopMode
    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];

    //    NSLog(@&quot;%@&quot;,[NSRunLoop currentRunLoop]);
}

- (void)run
{
    NSLog(@&quot;---run---%@&quot;,[NSRunLoop currentRunLoop].currentMode);
}

- (IBAction)btnClick {

    NSLog(@&quot;---btnClick---&quot;);
}
</code></pre>

<h4 id="toc_12">GCD中的定时器</h4>

<pre><code>//0.创建一个队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

    //1.创建一个GCD的定时器
    /*
     第一个参数：说明这是一个定时器
     第四个参数：GCD的回调任务添加到那个队列中执行，如果是主队列则在主线程执行
     */
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);

    //2.设置定时器的开始时间，间隔时间以及精准度

    //设置开始时间，三秒钟之后调用
    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,3.0 *NSEC_PER_SEC);
    //设置定时器工作的间隔时间
    uint64_t intevel = 1.0 * NSEC_PER_SEC;

    /*
     第一个参数：要给哪个定时器设置
     第二个参数：定时器的开始时间DISPATCH_TIME_NOW表示从当前开始
     第三个参数：定时器调用方法的间隔时间
     第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0
     该参数的意义：可以适当的提高程序的性能
     注意点：GCD定时器中的时间以纳秒为单位（面试）
     */

    dispatch_source_set_timer(timer, start, intevel, 0 * NSEC_PER_SEC);

    //3.设置定时器开启后回调的方法
    /*
     第一个参数：要给哪个定时器设置
     第二个参数：回调block
     */
    dispatch_source_set_event_handler(timer, ^{
        NSLog(@&quot;------%@&quot;,[NSThread currentThread]);
    });

    //4.执行定时器
    dispatch_resume(timer);

    //注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用
    self.timer = timer;

GCD定时器补充
/*
 DISPATCH_SOURCE_TYPE_TIMER         定时响应（定时器事件）
 DISPATCH_SOURCE_TYPE_SIGNAL        接收到UNIX信号时响应

 DISPATCH_SOURCE_TYPE_READ          IO操作，如对文件的操作、socket操作的读响应
 DISPATCH_SOURCE_TYPE_WRITE         IO操作，如对文件的操作、socket操作的写响应
 DISPATCH_SOURCE_TYPE_VNODE         文件状态监听，文件被删除、移动、重命名
 DISPATCH_SOURCE_TYPE_PROC          进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号

 下面两个都属于Mach相关事件响应
    DISPATCH_SOURCE_TYPE_MACH_SEND
    DISPATCH_SOURCE_TYPE_MACH_RECV
 下面两个都属于自定义的事件，并且也是有自己来触发
    DISPATCH_SOURCE_TYPE_DATA_ADD
    DISPATCH_SOURCE_TYPE_DATA_OR
 */
</code></pre>

<h3 id="toc_13">CFRunLoopObserverRef</h3>

<p><strong>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</strong></p>

<p>可以监听的时间点有以下几个</p>

<pre><code>/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0),           // 即将进入 Loop
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   // 即将进入休眠
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    // 刚从休眠中唤醒
    kCFRunLoopExit = (1UL &lt;&lt; 7),            // 刚从休眠中唤醒
    kCFRunLoopAllActivities = 0x0FFFFFFFU   // 所有状态改变
};
</code></pre>

<p>如何监听:</p>

<pre><code> //创建一个runloop监听者
    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {

        NSLog(@&quot;监听runloop状态改变---%zd&quot;,activity);
    });

    //为runloop添加一个监听者
    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);

    CFRelease(observer);
</code></pre>

<h2 id="toc_14">5. RunLoop处理逻辑</h2>

<p><img src="media/14731740142157/14732109138343.jpg" alt=""/><br/>
<img src="media/14731740142157/14732110397325.jpg" alt=""/></p>

<p>网友整理如下:<br/>
<img src="media/14731740142157/14732111027007.jpg" alt=""/></p>

<h2 id="toc_15">6.RunLoop应用</h2>

<ul>
<li>NSTimer</li>
<li>ImageView显示  控制方法在特定的模式下可用</li>
<li>PerformSelector</li>
<li>常驻线程 在子线程中开启一个runloop</li>
<li>自动释放池

<ul>
<li>第一次创建：进入runloop的时候</li>
<li>最后一次释放：runloop退出的时候</li>
<li>其它创建和释放：当runloop即将休眠的时候会把之前的自动释放池释放，然后重新创建一个新的释放池</li>
</ul></li>
</ul>

<h3 id="toc_16">参考资料:</h3>

<hr/>

<p>官方文档 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Threading Programming Guide</a><br/><br/>
CFRunLoopRef<a href="http://opensource.apple.com/source/CF/CF-1151.16/">源代码</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIWebView可能的优化方案]]></title>
    <link href="http://www.citynight.cn/Blog/14731574655770.html"/>
    <updated>2016-09-06T18:24:25+08:00</updated>
    <id>http://www.citynight.cn/Blog/14731574655770.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>声明:Socket思想来源于手Q空间团队,Demo中提供了使用Socket模拟HTTP请求.</p>
</blockquote>

<p>我们都知道WebView加载页面非常缓慢,如果页面样式结构比较固定,则可以采用自己的自己封装的网络请求去获取数据,然后拼接成HTML显示.</p>

<p><strong>优点:</strong></p>

<ul>
<li>通常webview首次加载非常慢,使用Native网络请求会很快</li>
<li>离线包＋预加载(静态HTML、静态JS、静态CSS它们的加载、它们离线的东西）,首屏进入可直接加载默认数据</li>
</ul>

<p><strong>缺点:</strong></p>

<ul>
<li>静态资源包离线下载,不能保证100%</li>
</ul>

<h2 id="toc_0">传统H5加载流程</h2>

<p><img src="media/14731574655770/14737415611533.jpg" alt=""/></p>

<h3 id="toc_1"><strong>这里有两个问题：</strong></h3>

<p>WebView的耗时 <br/>
根据手Q的统计数据，Android的WebView平均打开启动的速度耗时是0.8秒，有些Android机型基于系统环境可能需要一点多或者两秒左右；</p>

<p>HTTP协议的网络层 <br/>
HTTP有DNS或者建立链接的耗时，HTTPS有建立SSL链接的耗时。</p>

<p>所以H5通常带给用户的体验是：我点进来不管是怎么时候，是第一次第二次还是第三次，我点进来先等两秒再说，看两秒白屏后页面才可以加载进来，其实这里我们只做了两个事情去优化首次加载流程：</p>

<h4 id="toc_2">1. 把WebView启动和发送请求改成并行</h4>

<p>客户端在启动WebView的时候同时发起HTML的页面请求，这里可以实现一个效果：本来我的耗时是T1+T2，现在为T1或T2的最大值，这样达到并行加载的效果。<br/>
<img src="media/14731574655770/14737420748297.jpg" alt=""/></p>

<p>当然这里还有一个优化的空间，我们其实已经由客户端接管了发送网络请求的事情，以前接管的时候是用HTTP协议，比如像iOS用的是URLSession模块，但已经让客户端接管了，为什么不能够更大胆一些呢？</p>

<h4 id="toc_3">2. Socket通道</h4>

<p>其实我们可以不拘泥于数据传输的方式，所以这里我们把一个HTML的加载从HTTP/HTTPS改造成了一个Socket通道，这是一个App里面长连接的管道，如果手机内部有即时通讯模块的话，我们是用这个长连接的通道来做HTML的传输的，它的作用在于只要你的手机QQ能够收发消息，你的HTML页面就能够加载进来，这样就达到体验上的一致性，同时网络也有比较稳定的提升。 <br/>
<img src="media/14731574655770/14737423231640.jpg" alt=""/></p>

<p>我们基本上做了两个事情就达到首次进入加速的目的，但后面才是一个关键：首次进入我们已经做过优化了，但二次进入怎么去做优化去提高它的显示速度呢？</p>

<h2 id="toc_4">本地缓存</h2>

<p><img src="media/14731574655770/14737426997041.jpg" alt=""/></p>

<h2 id="toc_5">Demo简单介绍</h2>

<blockquote>
<p>关于加载优化Demo,地址:<a href="https://github.com/Mekor/Optimization-of-webView">https://github.com/Mekor/Optimization-of-webView</a></p>
</blockquote>

<h4 id="toc_6">webView加载耗时问题解决方案简介:</h4>

<ol>
<li>如果有界面变动不大,可以吧HTML直接在本地存放一份,然后从网上请求数据,拼接成HTML,这样加载速度会很快.这种可以参考用户版商品的图片简介.</li>
<li>如果内部动态变化的,但是样式和交互式规定好的,可以在本地存放一份,当然也可以每次启动app的时候更新本地存放的静态资源.这样的好处就是每次只替换更新的内容.</li>
</ol>

<p>下面以网易新闻为例,这里我抓包网易新闻的请求,新闻详情: <a href="http://c.m.163.com/nc/article/C0OBRVC7051789DB/full.html">http://c.m.163.com/nc/article/C0OBRVC7051789DB/full.html</a><br/>
这里我们可以看出,网易新闻也不是直接用webView加载url的方式显示的.</p>

<pre><code>{
    &quot;C0OBRVC7051789DB&quot;: {
        &quot;body&quot;: &quot;&lt;p&gt;　　郭德纲的成功除了自身坚持不懈的努力外，当然也因郭德纲遇到了不少“贵人”的帮助，在这其中有一位也是其“贵人”，郭德纲曾经也在很多场合说其是自己的贵人，他就是大鹏。&lt;/p&gt;&lt;!--IMG#0--&gt;&lt;p&gt;　　不过，此大鹏非彼大鹏。如今一说到大鹏，都会想到导演电影《煎饼侠》的大鹏，那是赵本山的弟子，却和郭德纲没有什么关系。而帮助过郭德纲，使得其相声在北京能广受欢迎的大鹏，则是北京文艺广播《开心茶馆》主持人康大鹏。&lt;/p&gt;&lt;!--IMG#1--&gt;&lt;p&gt;　　康大鹏作为电台节目主持人，在没有听到郭德纲相声之前，给听众播放的也是一些经典的相声段子，不过翻来覆去时间长了也令听众生厌，久而久之就没有了兴趣。在这种情况下，大鹏听了郭德纲的相声后，才感到眼前一亮。&lt;/p&gt;&lt;!--IMG#2--&gt;&lt;p&gt;　　当时的郭德纲，虽然在北京也开始站住了脚跟，但是仅限于小部分观众知道，并且据说还备受各方打击，所以才会在相声中经常有“怨言”。在大鹏看了德云社郭德纲的相声后，认为这是个机会，德云社也需要听众，也需要帮助。&lt;/p&gt;&lt;!--IMG#3--&gt;&lt;p&gt;　　于是，大鹏就开始到德云社录音，然后播放给听众听。这在当时，也是一个不小的举动。毕竟郭德纲在当时还名不见经传，而为郭德纲录音还需要大鹏自己掏腰包购买录音器材，至于播出后效果如何也担有一定风险。&lt;/p&gt;&lt;!--IMG#4--&gt;&lt;p&gt;　　也正如大鹏所想象，郭德纲的相声在电台播出后便反响强烈，使得很多观众都开始迷上了相声，也迷上了郭德纲。在拥有了大批粉丝后，据说郭德纲随后开办了一场大型纪念演出，当时有不少电视台和电台的领导观看，而在郭德纲相声结束后，大鹏还给台下领导来了一个惊人的一跪。&lt;/p&gt;&lt;!--IMG#5--&gt;&lt;p&gt;　　虽然只是单膝点地，但在当时的报纸也给出了惊天一跪的标题，而大鹏的这一跪，也使得郭德纲和电视台结缘。尽管郭德纲的成名和大鹏有着不可分割的关系，但大鹏还是很谦虚的说两者是相互的关系，因为节目需要听众。&lt;/p&gt;&lt;!--IMG#6--&gt;&lt;p&gt;　　在郭德纲进入北京电视台主持《星夜故事秀》节目时，这也是郭德纲和北京电视台合作最好的时期，堪称两者的“蜜月期”。只是随着郭德纲的成名，郭德纲后来又转战到了天津卫视，自己在北京电视台的节目则交给了何云伟和李菁来做。&lt;/p&gt;&lt;!--IMG#7--&gt;&lt;p&gt;　　这其中的原因，有人说是因为报酬方面产生了分歧，说白了其他电视台给了更高的价钱。所以北京电视台才会批郭德纲“忘恩负义”，因北京电视台为郭德纲的宣传做了很大的努力，但也有人说是因郭德纲的加盟，才使得北京电视台节目火了起来。谁是谁非莫衷一是。&lt;/p&gt;&lt;!--IMG#8--&gt;&lt;p&gt;　　至于后来，两者闹得更是不可开交，直到最后变成了“冤家”。而和北京电视台闹分裂后，对原电台主持人大鹏自然也是有很大的影响，毕竟电视台和电台也是一脉相承的关系，不可能不对大鹏产生影响。&lt;/p&gt;&lt;!--IMG#9--&gt;&lt;p&gt;　　对与错是与非都是难以说清，正如大鹏所说，郭德纲的相声给其节目带来了听众，而电台也给郭德纲带去了名气，两者也是相辅相成。但不管怎样，大鹏的确是郭德纲演艺路上的一位“恩人”，起码让其早点脱颖而出扬眉吐气了。&lt;/p&gt;&lt;p&gt; 特别声明：本文为网易自媒体平台“网易号”作者上传并发布，仅代表该作者观点。网易仅提供信息发布平台。&lt;/p&gt;&quot;,
        &quot;users&quot;: [],
        &quot;replyCount&quot;: 1893,
        &quot;ydbaike&quot;: [],
        &quot;link&quot;: [],
        &quot;shareLink&quot;: &quot;http://c.m.163.com/news/a/C0OBRVC7051789DB.html?spss=newsapp&amp;spsw=1&quot;,
        &quot;votes&quot;: [],
        &quot;img&quot;: [
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#0--&gt;&quot;,
                &quot;pixel&quot;: &quot;400*263&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/s9VWjHPwFtTeqKoYJBULaIbs5TmzcYeGFQeljU0IFvZrD1473633706236.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#1--&gt;&quot;,
                &quot;pixel&quot;: &quot;412*256&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/6DXnTuxZs2jvgFJLMW2svrKoh1=KTYXhGwGUH2JlqdpZq1473633736663.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#2--&gt;&quot;,
                &quot;pixel&quot;: &quot;380*246&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/H5jHhCfSD5uhRhMFrHwze4LgrK97qwcG1GkwWGRZcOeqe1473633752645.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#3--&gt;&quot;,
                &quot;pixel&quot;: &quot;360*286&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/udjNFCksz6Fc7fCFAzCBwzUYxWB1TJUVis97X5ZRHpqg61473633775305.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#4--&gt;&quot;,
                &quot;pixel&quot;: &quot;407*255&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/7mbZrlli2D70eS9WHoRmd54RDkr6onqv8Zl1h6V5zJraj1473633824123compressflag.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#5--&gt;&quot;,
                &quot;pixel&quot;: &quot;400*266&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/HVmr=qRm5YReXaRAJBcSaI6WJpMn6DkKHJIVJBdbqMOYY1473633850729compressflag.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#6--&gt;&quot;,
                &quot;pixel&quot;: &quot;380*232&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/HQUW=i7soYmJqlUDaS1iv6pGBI9NzCdFqYU=yC=QT8BDQ1473633896632.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#7--&gt;&quot;,
                &quot;pixel&quot;: &quot;294*220&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/lEs43YivpKRxQqZPlmaIo=SpEOdRTqeYUywHCLqwIqR111473633914904.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#8--&gt;&quot;,
                &quot;pixel&quot;: &quot;402*238&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/bhzvrmx8JUQHVViXI5VKqvHG=c5RIIxx0dssbfTNM7mfE1473633962043.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#9--&gt;&quot;,
                &quot;pixel&quot;: &quot;329*220&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/tN7dLuyOJ0SU3kXoPRrLdXkVMZGJtiS97Qh46opqH2Q0N1473634186617.jpg&quot;
            }
        ],
        &quot;digest&quot;: &quot;&quot;,
        &quot;topiclist_news&quot;: [],
        &quot;dkeys&quot;: &quot;null&quot;,
        &quot;topiclist&quot;: [
            {
                &quot;hasCover&quot;: false,
                &quot;subnum&quot;: &quot;2.8万&quot;,
                &quot;alias&quot;: &quot;娱乐八卦、影视评论&quot;,
                &quot;tname&quot;: &quot;娱乐大嘴&quot;,
                &quot;ename&quot;: &quot;T1439876075818&quot;,
                &quot;tid&quot;: &quot;T1439876075818&quot;,
                &quot;cid&quot;: &quot;C1374475306828&quot;
            }
        ],
        &quot;docid&quot;: &quot;C0OBRVC7051789DB&quot;,
        &quot;picnews&quot;: true,
        &quot;title&quot;: &quot;郭德纲从他的节目走红 此“贵人”却不求回报&quot;,
        &quot;sourceinfo&quot;: {
            &quot;alias&quot;: &quot;娱乐八卦、影视评论&quot;,
            &quot;ename&quot;: &quot;T1439876075818&quot;,
            &quot;tname&quot;: &quot;娱乐大嘴&quot;,
            &quot;tid&quot;: &quot;T1439876075818&quot;
        },
        &quot;tid&quot;: &quot;&quot;,
        &quot;template&quot;: &quot;normal1&quot;,
        &quot;threadVote&quot;: 108,
        &quot;askbar&quot;: [
            {
                &quot;title&quot;: &quot;主持人&quot;,
                &quot;headpicurl&quot;: &quot;http://dingyue.nosdn.127.net/27vmGgL=A4BbmMAUJIEOEJ2vUlnvIGE9Ufum0roxEDigT1472456332076.jpg&quot;,
                &quot;alias&quot;: &quot; 我是河北交通广播主持人月色，关于主持、情感和各种天马行空的问题，问我吧！ &quot;,
                &quot;expertId&quot;: &quot;EX880112773195081120&quot;,
                &quot;name&quot;: &quot;月色&quot;,
                &quot;concernCount&quot;: 6341
            }
        ],
        &quot;threadAgainst&quot;: 49,
        &quot;boboList&quot;: [],
        &quot;articleTags&quot;: &quot;网易号&quot;,
        &quot;replyBoard&quot;: &quot;dy_wemedia_bbs&quot;,
        &quot;source&quot;: &quot;娱乐大嘴&quot;,
        &quot;huati&quot;: [
            {
                &quot;topicId&quot;: &quot;SJ02345751487819348812&quot;,
                &quot;topicName&quot;: &quot;郭德纲&quot;
            },
            {
                &quot;topicId&quot;: &quot;SJ1851570047893940154&quot;,
                &quot;topicName&quot;: &quot;赵本山&quot;
            }
        ],
        &quot;hasNext&quot;: false,
        &quot;voicecomment&quot;: &quot;off&quot;,
        &quot;apps&quot;: [],
        &quot;relative_sys&quot;: [
            {
                &quot;id&quot;: &quot;C0RN7O7N00034VR2&quot;,
                &quot;title&quot;: &quot;郭德纲的综艺版图:交人脉、捧新人、强化德云IP&quot;,
                &quot;source&quot;: &quot;网易娱乐专稿&quot;,
                &quot;imgsrc&quot;: &quot;http://cms-bucket.nosdn.127.net/a11079eb004f445abdb7146850e4810d20160913141047.jpeg&quot;,
                &quot;docID&quot;: &quot;C0RN7O7N00034VR2&quot;,
                &quot;from&quot;: &quot;HZ&quot;,
                &quot;type&quot;: &quot;doc&quot;,
                &quot;ptime&quot;: &quot;2016-09-13 14:13:21&quot;,
                &quot;href&quot;: &quot;&quot;
            },
            {
                &quot;id&quot;: &quot;C0DBP4LV0517ACQ1&quot;,
                &quot;title&quot;: &quot;老梁说天下：郭德纲为什么这么能“惹事儿”&quot;,
                &quot;source&quot;: &quot;纵横娱乐&quot;,
                &quot;imgsrc&quot;: &quot;http://dingyue.nosdn.127.net/sYo3zfohiqrXHHZIhYV0wqZTpE7RavK7qWneE4BsRH6O=1473265404780compressflag.png&quot;,
                &quot;docID&quot;: &quot;C0DBP4LV0517ACQ1&quot;,
                &quot;from&quot;: &quot;HZ&quot;,
                &quot;type&quot;: &quot;doc&quot;,
                &quot;ptime&quot;: &quot;2016-09-08 00:23:46&quot;,
                &quot;href&quot;: &quot;&quot;
            },
            {
                &quot;id&quot;: &quot;C0R1QGIN051789DB&quot;,
                &quot;title&quot;: &quot;唯一被戏称德云社第一女弟子女星，却是郭德纲铁杆粉丝&quot;,
                &quot;source&quot;: &quot;娱乐大嘴&quot;,
                &quot;imgsrc&quot;: &quot;http://dingyue.nosdn.127.net/I=T7AyADVhb6T8KiCoR0Yw0mKqBXyzUNKWyafBy9PRvxF1473724249899.jpg&quot;,
                &quot;docID&quot;: &quot;C0R1QGIN051789DB&quot;,
                &quot;from&quot;: &quot;HZ&quot;,
                &quot;type&quot;: &quot;doc&quot;,
                &quot;ptime&quot;: &quot;2016-09-13 08:01:08&quot;,
                &quot;href&quot;: &quot;&quot;
            }
        ],
        &quot;ptime&quot;: &quot;2016-09-12 06:59:42&quot;
    }
}
</code></pre>

<p>我们可以看出, <code>body</code> 里面是配置好的html,同时里面也给出了图片占位符类似于 <code>&lt;!--IMG#0--&gt;</code>,通过 <code>img</code> 数组里面的的内容进行替换,img里面提供类似 </p>

<pre><code>{
    &quot;ref&quot;: &quot;&lt;!--IMG#0--&gt;&quot;, 
    &quot;pixel&quot;: &quot;400*263&quot;, 
    &quot;alt&quot;: &quot;&quot;, 
    &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/s9VWjHPwFtTeqKoYJBULaIbs5TmzcYeGFQeljU0IFvZrD1473633706236.jpg&quot;
},
</code></pre>

<p>提供了 <code>body</code> 里面的占位符,同时还提供了,pixel,alt,src等.这时我们可以做的事情就多了,根据占位符替换 <code>body</code> 中的占位,通过原生网络下载图片等等.Demo中我只做了简单的HTML拼接.拼接好HTML在把本地的模板添加进去,比如css,js等.最后直接把拼接好的完整的HTML给webView,让其显示.具体Demo已经提供了,仅供参考.效果图:</p>

<p><img src="media/14731574655770/14738361521187.gif" alt=""/><br/>
(仅供参考,css我只是简单的按照大概写的,勿喷)</p>

<h4 id="toc_7">Socket模拟HTTP请求</h4>

<p>第二个Demo中模拟了Socket发送HTTP请求的方式,当然我这里只是猜测手Q的实现方式.需要注意的地方就是拼接请求头.</p>

<pre><code>    //拼接http请求
    NSString *request = @&quot;GET / HTTP/1.1\n&quot;
    &quot;Connection: Close\n&quot;
    &quot;Host: m.baidu.com\n&quot;
    //告诉服务器客户端是mac
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36\n\n&quot;;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[runtime(内部分享草稿)]]></title>
    <link href="http://www.citynight.cn/Blog/14727863232294.html"/>
    <updated>2016-09-02T11:18:43+08:00</updated>
    <id>http://www.citynight.cn/Blog/14727863232294.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本文涉及到的Demo地址 <a href="https://github.com/Mekor/runtimeDemo">https://github.com/Mekor/runtimeDemo</a></p>
</blockquote>

<h2 id="toc_0">理解self,super,class,superclass</h2>

<p>创建一个Person里面有一个类方法:</p>

<pre><code class="language-objc">#import &quot;Person.h&quot;

@implementation Person
+(void)study {
    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
}
@end
</code></pre>

<p>Student继承自Person,重写父类方法</p>

<pre><code class="language-objc">#import &quot;Student.h&quot;

@implementation Student
+(void)study {
    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
}
@end
</code></pre>

<!--more-->

<p>这两个输出的都是什么?<br/>
<img src="media/14727863232294/14729913552743.jpg" alt=""/></p>

<p>这时,我们在Student中用这样写:</p>

<pre><code class="language-objc">#import &quot;Student.h&quot;

@implementation Student
+(void)study {
//    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
    
    [super study];
}
@end
</code></pre>

<p>打断点我们可以看到:<br/>
<img src="media/14727863232294/14729934417192.jpg" alt=""/></p>

<p>可以看出:</p>

<pre><code class="language-objc">super：是编译器指示符，仅仅是一个标志,并不是指针，仅仅是标志的当前对象去调用父类的方法，本质还是当前对象调用
super:并不是让父类对象调用方法，调用者还是本身
class：获取方法调用者的类
superclass:获取方法调用者的父类
</code></pre>

<p>消息机制:(来自:<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">官方文档</a>)<br/>
<img src="media/14727863232294/messaging1.gif" alt="消息框架"/></p>

<p>当对象收到消息时,消息函数首先根据该对象的 isa 指针找到该对象所对应的类的方法表,并从表中寻找 该消息对应的方法选标。如果找不到,objc_msgSend 将继续从父类中寻找,直到 NSObject 类。一旦找到了方法选标, objc_msgSend 则以消息接收者对象为参数调用,调用该选标对应的方法实现。</p>

<h2 id="toc_1">self是从哪里来的?</h2>

<blockquote>
<p>官方解释:<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">Objective-C Runtime Programming Guide</a><img src="media/14727863232294/14729941396965.jpg" alt=""/></p>
</blockquote>

<p>简单说每个方法都存在并且隐藏的两个参数(self,_cmd),随便写个方法看下:<br/>
Student中写个text方法,然后打印下这两个隐藏参数.<br/>
<img src="media/14727863232294/14729960900273.jpg" alt=""/><br/>
<img src="media/14727863232294/14729961142923.jpg" alt=""/></p>

<h2 id="toc_2">动态添加方法</h2>

<p>上面说了一些貌似和runtime没有什么关系,runtime基础知识类似类的构成,对象的构成这里不再介绍,可以自己去看定义.当然也可以去<a href="http://opensource.apple.com/source/objc4/objc4-680/runtime/">苹果的开源网站</a>查看,如果网站不方便可以去苹果的<a href="https://github.com/opensource-apple/objc4">github</a>下载开源代码研究&hellip;  &hellip;继续&hellip;那么根据上面所说的方法说下动态添加方法.</p>

<blockquote>
<p>思考一下,咱们new项目中将采用路由模式进行页面跳转,从网页跳转进入app调用一个方法,一般情况下都是移动端和后台协议好的内容,这样跳转不会出现问题.但是如果后台写错了或者传输中出现问题导致url中包含的方法名不是规定的方法名.这时怎么办?</p>
</blockquote>

<pre><code class="language-objc">    Student *s = [Student new];
    
    // 1. 比如我们要调用 Student中的eat方法, 默认这样写[s eat]; 但是不行,因为我们没有定义.
//    [s eat];
    // 2. 也可以这样调用[s performSelector:@selector(eat)];这样没有问题,@selector中参数是字符串,这个参考swift
//    [s performSelector:@selector(eat)];
    // 3. 使用string创建SEL
    
#pragma clang diagnostic push
#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;
    [s performSelector:NSSelectorFromString(@&quot;eat&quot;)];
#pragma clang diagnostic pop
    
    // 上面这样调用会报错,我们在对象调用未实现方法的时候动态的创建一个方法,避免抛出异常.
</code></pre>

<p>怎么忽略编译器警告已经分享过,可以参考:<a href="http://www.citynight.cn/Blog/14676105703423.html">http://www.citynight.cn/Blog/14676105703423.html</a></p>

<h3 id="toc_3">怎么动态添加方法呢?</h3>

<p><img src="media/14727863232294/14729983827897.jpg" alt=""/><br/>
上面是动态添加对象方法的例子,动态添加类方法也是一样的<code>+(BOOL)resolveClassMethod:(SEL)sel</code><br/>
<strong>注意:</strong>上面函数类型,有人可能好奇这块为什么写成&quot;v@:&ldquo;  ?参见:函数类型, 更多关于转发机制参见:<a href="http://www.citynight.cn/Blog/14733118707964.html">转发机制</a></p>

<h3 id="toc_4">关于函数类型</h3>

<p>先看文档:<br/>
<img src="media/14727863232294/14730056768742.jpg" alt=""/><br/>
查看<code>Objective-C type encodings</code> <img src="media/14727863232294/14730058881001.jpg" alt=""/><br/>
所以上面void eat(&hellip;)应该表述成 <code>&quot;v@:&quot;</code></p>

<p><strong>补充:</strong> 动态调用方法系统默认提供一到两个参数的方法调用, <del>这里封装了一个无限参数的方法调用.<a href="https://github.com/Mekor/NSObject-SEL">NSObject-SEL****</a></del>  我把一些扩展进行了总结,还不完善,地址<a href="https://github.com/Mekor/MKExtension">MKExtension</a></p>

<h3 id="toc_5">关于IMP(函数指针)</h3>

<pre><code class="language-objc">/// A pointer to the function of a method implementation. 
#if !OBJC_OLD_DISPATCH_PROTOTYPES
typedef void (*IMP)(void /* id, SEL, ... */ ); 
#else
typedef id (*IMP)(id, SEL, ...); 
#endif
</code></pre>

<p>当前版本Xcode如果使用IMP的话,默认是选择第一个也就是无参无返回值.如果需要参数有返回值的话,需要修改配置文件.如下:</p>

<h2 id="toc_6">方法交换(Method Swizzling:传说中的黑魔法)</h2>

<p>一般使用方法交换都是想给系统提供的方法添加一些其他的功能的时候使用.new中使用方法交换的例子:</p>

<pre><code class="language-objc">#import &quot;UIActionSheet+Front.h&quot;

#import &lt;objc/runtime.h&gt;

@implementation UIActionSheet (Front)
- (void)customShowInView:(UIView *)view{
    for(UIWindow * tmpWin in [[UIApplication sharedApplication] windows]){
        [tmpWin endEditing:NO];
    }
    [self customShowInView:view];
}
+ (void)load{
    swizzleAllActionSheet();
}
@end

void swizzleAllActionSheet(){
    Class c = [UIActionSheet class];
    SEL origSEL = @selector(showInView:);
    SEL newSEL = @selector(customShowInView:);
    Method origMethod = class_getInstanceMethod(c, origSEL);
    Method newMethod = class_getInstanceMethod(c, newSEL);
    method_exchangeImplementations(origMethod, newMethod);
}
</code></pre>

<p>关于方法交换,在new项目中已经封装好了,代码如下:</p>

<pre><code class="language-objc">// ObjcRuntime.h文件
void Swizzle(Class c, SEL origSEL, SEL newSEL);

//ObjcRuntime.m文件
//静态就交换静态，实例方法就交换实例方法
void Swizzle(Class c, SEL origSEL, SEL newSEL)
{
    Method origMethod = class_getInstanceMethod(c, origSEL);
    Method newMethod = nil;
    if (!origMethod) {
        origMethod = class_getClassMethod(c, origSEL);
        if (!origMethod) {
            return;
        }
        newMethod = class_getClassMethod(c, newSEL);
        if (!newMethod) {
            return;
        }
    }else{
        newMethod = class_getInstanceMethod(c, newSEL);
        if (!newMethod) {
            return;
        }
    }
    
    //自身已经有了就添加不成功，直接交换即可
    if(class_addMethod(c, origSEL, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))){
        class_replaceMethod(c, newSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
    }else{
        method_exchangeImplementations(origMethod, newMethod);
    }
}
</code></pre>

<p>用法(还是以Student为例):<br/>
Student中添加两个对象方法,一个run,一个sleep.我们的目的是交换两个方法的实现</p>

<pre><code class="language-objc">-(void)run {
    NSLog(@&quot;跑🏃&quot;);
}
-(void)sleep {
    NSLog(@&quot;睡觉😴&quot;);
}
+(void)load {
    Swizzle(self, @selector(run), @selector(sleep));
}
</code></pre>

<p>控制器调用的结果:<br/>
<img src="media/14727863232294/14730042652865.jpg" alt=""/></p>

<h2 id="toc_7">添加属性</h2>

<p>动态添加属性用的最多的地方应该是给分类添加属性.  <del>我在项目中添加过一个分类<code>UIView+Tap</code>这个也可以在这里查看<a href="https://github.com/Mekor/UIView-Tap">UIView-Tap</a></del>  我把一些扩展进行了总结,还不完善,地址<a href="https://github.com/Mekor/MKExtension">MKExtension</a></p>

<pre><code class="language-objc">#import &quot;UIView+Tap.h&quot;
#import &lt;objc/runtime.h&gt;

static const void* tagValue = &amp;tagValue;

@interface UIView ()
@property (nonatomic, copy) void(^tapAction)(id);
@end

@implementation UIView (Tap)
- (void)tap{
    if (self.tapAction) {
        self.tapAction(self);
    }
}
- (void)addTapBlock:(void(^)(id obj))tapAction{
    self.tapAction = tapAction;
    if (![self gestureRecognizers]) {
        self.userInteractionEnabled = YES;
        UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];
        [self addGestureRecognizer:tap];
    }
}

-(void)setTapAction:(void (^)(id))tapAction {
    objc_setAssociatedObject(self, tagValue, tapAction, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
-(void (^)(id))tapAction {
    return objc_getAssociatedObject(self, tagValue);
}
@end
</code></pre>

<p>主要是set&amp;get方法,这点注意了也就没啥了..</p>

<h2 id="toc_8">其他</h2>

<ol>
<li>系统中常见的使用到runtime的地方:
<a href="http://www.citynight.cn/Blog/14726525723684.html">KVO内部实现原理</a></li>
<li>日常开发中使用到runtime的地方:</li>
<li>字典转模型: 可以参看<code>MJExtension</code> 它的核心代码在:<code>NSObject+MJProperty.m</code>第150行开始</li>
</ol>

<pre><code class="language-objc">#pragma mark - 公共方法
+ (NSMutableArray *)properties
{
    NSMutableArray *cachedProperties = [self dictForKey:&amp;MJCachedPropertiesKey][NSStringFromClass(self)];
    
    if (cachedProperties == nil) {
        cachedProperties = [NSMutableArray array];
        
        [self mj_enumerateClasses:^(__unsafe_unretained Class c, BOOL *stop) {
            // 1.获得所有的成员变量
            unsigned int outCount = 0;
            objc_property_t *properties = class_copyPropertyList(c, &amp;outCount);
            
            // 2.遍历每一个成员变量
            for (unsigned int i = 0; i&lt;outCount; i++) {
                MJProperty *property = [MJProperty cachedPropertyWithProperty:properties[i]];
                // 过滤掉Foundation框架类里面的属性
                if ([MJFoundation isClassFromFoundation:property.srcClass]) continue;
                property.srcClass = c;
                [property setOriginKey:[self propertyKey:property.name] forClass:self];
                [property setObjectClassInArray:[self propertyObjectClassInArray:property.name] forClass:self];
                [cachedProperties addObject:property];
            }
            
            // 3.释放内存
            free(properties);
        }];
        
        [self dictForKey:&amp;MJCachedPropertiesKey][NSStringFromClass(self)] = cachedProperties;
    }
    
    return cachedProperties;
}
</code></pre>

<p>自定义字典转模型中log的输出可以参见Xcode插件<code>ESJsonFormat</code>中<code>ESJsonFormatManager.m</code>第47行:</p>

<pre><code class="language-objc">/**
 *  格式化OC属性字符串
 *
 *  @param key       JSON里面key字段
 *  @param value     JSON里面key对应的NSDiction或者NSArray
 *  @param classInfo 类信息
 *
 *  @return
 */
+ (NSString *)formatObjcWithKey:(NSString *)key value:(NSObject *)value classInfo:(ESClassInfo *)classInfo{
    NSString *qualifierStr = @&quot;copy&quot;;
    NSString *typeStr = @&quot;NSString&quot;;
    //判断大小写
    if ([ESUppercaseKeyWords containsObject:key] &amp;&amp; [ESJsonFormatSetting defaultSetting].uppercaseKeyWordForId) {
        key = [key uppercaseString];
    }
    if ([value isKindOfClass:[NSString class]]) {
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[@(YES) class]]){
        //the &#39;NSCFBoolean&#39; is private subclass of &#39;NSNumber&#39;
        qualifierStr = @&quot;assign&quot;;
        typeStr = @&quot;BOOL&quot;;
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ %@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[NSNumber class]]){
        qualifierStr = @&quot;assign&quot;;
        NSString *valueStr = [NSString stringWithFormat:@&quot;%@&quot;,value];
        if ([valueStr rangeOfString:@&quot;.&quot;].location!=NSNotFound){
            typeStr = @&quot;CGFloat&quot;;
        }else{
            NSNumber *valueNumber = (NSNumber *)value;
            if ([valueNumber longValue]&lt;2147483648) {
                typeStr = @&quot;NSInteger&quot;;
            }else{
                typeStr = @&quot;long long&quot;;
            }
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ %@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[NSArray class]]){
        NSArray *array = (NSArray *)value;
        
        //May be &#39;NSString&#39;，will crash
        NSString *genericTypeStr = @&quot;&quot;;
        NSObject *firstObj = [array firstObject];
        if ([firstObj isKindOfClass:[NSDictionary class]]) {
            ESClassInfo *childInfo = classInfo.propertyArrayDic[key];
            genericTypeStr = [NSString stringWithFormat:@&quot;&lt;%@ *&gt;&quot;,childInfo.className];
        }else if ([firstObj isKindOfClass:[NSString class]]){
            genericTypeStr = @&quot;&lt;NSString *&gt;&quot;;
        }else if ([firstObj isKindOfClass:[NSNumber class]]){
            genericTypeStr = @&quot;&lt;NSNumber *&gt;&quot;;
        }
        
        qualifierStr = @&quot;strong&quot;;
        typeStr = @&quot;NSArray&quot;;
        if ([ESJsonFormatSetting defaultSetting].useGeneric &amp;&amp; [ESUtils isXcode7AndLater]) {
            return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@%@ *%@;&quot;,qualifierStr,typeStr,genericTypeStr,key];
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }else if ([value isKindOfClass:[NSDictionary class]]){
        qualifierStr = @&quot;strong&quot;;
        ESClassInfo *childInfo = classInfo.propertyClassDic[key];
        typeStr = childInfo.className;
        if (!typeStr) {
            typeStr = [key capitalizedString];
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }
    return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
}

</code></pre>

]]></content>
  </entry>
  
</feed>
