<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李小争]]></title>
  <link href="http://www.citynight.cn/Blog/atom.xml" rel="self"/>
  <link href="http://www.citynight.cn/Blog/"/>
  <updated>2021-06-25T19:36:12+08:00</updated>
  <id>http://www.citynight.cn/Blog/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[Flutter 中 listView 嵌套 listView]]></title>
    <link href="http://www.citynight.cn/Blog/16267690953146.html"/>
    <updated>2021-07-20T16:18:15+08:00</updated>
    <id>http://www.citynight.cn/Blog/16267690953146.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16267690953146/Simulator%20Screen%20Shot%20-%20iPhone%2012%20-%202021-07-20%20at%2016.18.53.png" alt="Simulator Screen Shot - iPhone 12 - 2021-07-20 at 16.18.53"/></p>

<p>实现上述嵌套效果只需要在里面的listView中使用</p>

<pre><code class="language-text">      shrinkWrap: true,
      physics: NeverScrollableScrollPhysics(),
</code></pre>

<p><img src="media/16267690953146/16267694115272.jpg" alt="" style="width:498px;"/><br/>
被嵌套的listView<br/>
<img src="media/16267690953146/16267694690429.jpg" alt="" style="width:637px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flutter中Row中的子控件左右两端对齐]]></title>
    <link href="http://www.citynight.cn/Blog/16261554677251.html"/>
    <updated>2021-07-13T13:51:07+08:00</updated>
    <id>http://www.citynight.cn/Blog/16261554677251.html</id>
    <content type="html"><![CDATA[
<p>假如我们要实现这样一个效果：两个子控件（例如2个文本）在一行显示，但我们想让它们分别左右两侧对齐，也就是左右一边一个。如何实现呢？<br/>
  方法一：<br/>
  设置 spaceBetween 对齐方式 设置 Row 控件的属性 mainAxisAlignment： mainAxisAlignment: MainAxisAlignment.spaceBetween,<br/>
  方法二：Expanded 填充 使用 Expanded 中间填充布局空间：<br/>
   new Row( children: [ new Text(&quot;开始日期：&quot;), Expanded(child: SizedBox()), new Text(“2020-12-29&quot;), ],),<br/>
   方法三：使用 Spacer() 填充<br/>
    new Row( children: [ new Text(&quot;开始日期：&quot;), Spacer(), new Text(“2020-12-29&quot;), ],), <br/>
    方法四：使用 Flexible <br/>
    new Row( children: [ new Text(&quot;开始日期：&quot;), Flexible(fit: FlexFit.tight, child: SizedBox()), new Text(“2020-12-29&quot;), ],), </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[flutter 多环境设置]]></title>
    <link href="http://www.citynight.cn/Blog/16246203092572.html"/>
    <updated>2021-06-25T19:25:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/16246203092572.html</id>
    <content type="html"><![CDATA[
<p>Flutter开发中我们需要切换不同的环境进行数据处理</p>

<h2 id="toc_0">原理</h2>

<p>根据Dart-Define进行参数控制</p>

<p>具体接收参数的实现在 env_config.dart 文件中</p>

<p>代码如下：<img src="media/16246203092572/image2021-6-25%2019_15_8.png" alt="image2021-6-25 19_15_8"/></p>

<h2 id="toc_1">传递参数</h2>

<p>我们可以直接输入命令行进行运行，可以使用shell进行脚本封装，也可以使用开发工具进行设置。</p>

<h3 id="toc_2">shell脚本启动方式</h3>

<p>已经写好了简单的执行脚本位置如下：</p>

<p><img src="media/16246203092572/image-20210625182202555.png" alt="image-20210625182202555"/></p>

<p><strong>使用方式</strong></p>

<ol>
<li><p>先赋予脚本读、执行权限 <code>chmod 755 ./scripts/run.sh</code></p></li>
<li><p>执行对应的脚本</p>
<pre><code class="language-shell"># 开发环境
./script/run.sh dev<br/>
# 测试环境<br/>
./script/run.sh test<br/>
# 发布环境<br/>
./script/run.sh release
</code></pre>
<p>当然也可以直接在命令行中直接输入运行。</p>
<h3 id="toc_3">使用Android Studio 进行设置</h3></li>
<li><p>编辑配置信息<img src="media/16246203092572/image-20210625171212841.png" alt="image-20210625171212841"/></p></li>
<li><p>设置参数<img src="media/16246203092572/image-20210625171413373.png" alt="image-20210625171413373"/></p></li>
<li><p>设置其他环境的参数<img src="media/16246203092572/image-20210625181701520.png" alt="image-20210625181701520"/></p></li>
<li><p>配置完成<img src="media/16246203092572/image-20210625181827464.png" alt="image-20210625181827464"/></p></li>
<li><p>开发中选择对应的环境执行<br/>
<img src="media/16246203092572/image-20210625182807269.png" alt="image-20210625182807269"/></p></li>
</ol>

<h3 id="toc_4">VSCode环境配置</h3>

<p><img src="media/16246203092572/image-20210625184614465.png" alt="image-20210625184614465"/></p>

<p>执行的时候选择对应的环境进行执行</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发环境配置]]></title>
    <link href="http://www.citynight.cn/Blog/16189060168232.html"/>
    <updated>2021-04-20T16:06:56+08:00</updated>
    <id>http://www.citynight.cn/Blog/16189060168232.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>安装Xcode(Version 12.4)</p>
<p>不要去App Store下载安装，因为App Store会自动更新，为了确保Xcode版本一致需要去开发者网站下载 <a href="https://developer.apple.com/download/more/">Apple Developer</a></p></li>
<li><p>安装brew</p>
<ol>
<li><p>由于访问外网太慢，建议从gitee安装</p>
<pre><code class="language-shell">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;
</code></pre></li>
<li><p>可以选择科大的源也可以选择清华的源，我一般用清华的源</p></li>
</ol></li>
<li><p>安装rbenv </p>
<ol>
<li><p>rbenv是 Ruby 环境管理工具 <code>brew install rbenv</code></p></li>
<li><p>更新配置文件</p>
<pre><code class="language-bash">export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot; 
eval &quot;$(rbenv init -)&quot;
</code></pre></li>
<li><p>我现在用的Ruby环境是2.7.1</p>
<pre><code class="language-shell">$ cd $(PROJECT_DIR)
$ rbenv install 2.7.1<br/>
$ rbenv local 2.7.1
</code></pre></li>
</ol></li>
<li><p>安装Bundler</p>
<ol>
<li><p>执行<code>gem install bundler</code>命令进行，之后，再执行<code>bundle init</code>就可以生成一个 Gemfile 文件</p></li>
<li><p>添加CocoaPods 和 fastlane 等依赖包</p>
<pre><code class="language-shell">source &quot;https://rubygems.org&quot;
gem &quot;cocoapods&quot;, &quot;1.10.1&quot;<br/>
gem &quot;fastlane&quot;,&quot;2.180.1&quot;
</code></pre></li>
</ol></li>
<li><p>使用脚本确认环境</p>
<pre><code class="language-shell"># Install ruby using rbenv
ruby_version=`cat .ruby-version`<br/>
if [[ ! -d &quot;$HOME/.rbenv/versions/$ruby_version&quot; ]]; then<br/>
 rbenv install $ruby_version;<br/>
fi<br/>
# Install bunlder<br/>
gem install bundler<br/>
# Install all gems<br/>
bundle install<br/>
# Install all pods<br/>
bundle exec pod install
</code></pre>
<p>​    脚本主要做了四件事情，第一步是在 rbenv 下安装特定版本的 Ruby 开发环境，然后通过 RubyGems 安装 Bunlder，接着使用 Bundler 安装 CocoaPods 和 fastlane 等依赖包，最后安装各个 Pod。这样，一个统一的项目环境就搭建完成了，接下来开发者就可以打开 <strong>项目名.xcworkspace</strong>进行开发了.</p></li>
<li><p>项目添加gitignore</p>
<p>可以去gitignore.io 输入Xcode，Swift等关键字生成.gitignore文件</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AR 模型格式转换和导入]]></title>
    <link href="http://www.citynight.cn/Blog/16158207840706.html"/>
    <updated>2021-03-15T23:06:24+08:00</updated>
    <id>http://www.citynight.cn/Blog/16158207840706.html</id>
    <content type="html"><![CDATA[
<p>需要软件：Reality Converter 去 <a href="https://developer.apple.com/download/">https://developer.apple.com/download/</a> 下载<br/>
<img src="media/16158207840706/16158208366495.jpg" alt="" style="width:1086px;"/></p>

<p>AR创作中使用USD格式，然后使用Reality Converter 转换成 USDZ格式</p>

<p>模型来源，除了自己制作外还可以通过网上其他人分享的模型来用，比如在 <a href="https://sketchfab.com/">https://sketchfab.com/</a> 中可以搜索自己喜欢的模型。</p>

<p>比如这个模型是gltf格式的，可以下载后把解压后的文件夹拖拽到 Reality Converter 中<br/>
<img src="media/16158207840706/16158221517356.jpg" alt="" style="width:900px;"/><br/>
然后选择文件-&gt; 导出  这时就导出了usdz格式的模型。 </p>

<p><img src="media/16158207840706/16158224521993.jpg" alt="" style="width:448px;"/><br/>
打开后选择文件-&gt; 新建</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[节流防抖]]></title>
    <link href="http://www.citynight.cn/Blog/16158207797865.html"/>
    <updated>2021-03-15T23:06:19+08:00</updated>
    <id>http://www.citynight.cn/Blog/16158207797865.html</id>
    <content type="html"><![CDATA[
<p>节流和防抖演示网站： <a href="http://demo.nimius.net/debounce_throttle/">http://demo.nimius.net/debounce_throttle/</a></p>

<p><strong>防抖 Debounce</strong></p>

<p>防抖的情况，有点像一个极度珍惜 执行机会的人，只要时间段内，有任务来，就再等一会。<br/>
等到最后一次，超过一定时间，确定没有新任务了，才去做执行。<br/>
    1. 列表刷新，为避免短时间内反复 reload，可以多次合并为一次<br/>
    2. TCP 流量控制</p>

<p><strong>节流 Throttle</strong></p>

<p>节流比较好理解，在一定时间段内，丢弃掉其它触发，就做一次执行<br/>
    1. 防止多次点击<br/>
    2. 重复发多个网络请求</p>

<pre><code class="language-text">import Foundation

/// 防抖
public class Debouncer {
    public let label: String
    public let interval: DispatchTimeInterval
    private let queue: DispatchQueue
    private let semaphore: DispatchSemaphoreWrapper
    private var workItem: DispatchWorkItem?
    
    
    public init(label: String, interval: Float, qos: DispatchQoS = .userInteractive) {
        self.interval         = .milliseconds(Int(interval * 1000))
        self.label         = label
        self.queue = DispatchQueue(label: &quot;cn.citynight.debouncer.internalqueue.\(label)&quot;, qos: qos)
        self.semaphore = DispatchSemaphoreWrapper(withValue: 1)
    }
    
    
    public func call(_ callback: @escaping (() -&gt; ())) {
        
        self.semaphore.sync  { () -&gt; () in
            
            
            self.workItem?.cancel()
            
            self.workItem = DispatchWorkItem {
                callback()
            }
            
            if let workItem = self.workItem {
                
                self.queue.asyncAfter(deadline: .now() + self.interval, execute: workItem)
            }
        }
    }
    
}
 

/// 节流
public class Throttler {
    
    private let queue: DispatchQueue = DispatchQueue.global(qos: .background)
    
    private var job: DispatchWorkItem = DispatchWorkItem(block: {})
    private var previousRun: Date = Date.distantPast
    private var maxInterval: Int
    private let semaphore: DispatchSemaphoreWrapper
    
    init(seconds: Int) {
        self.maxInterval = seconds
        self.semaphore = DispatchSemaphoreWrapper(withValue: 1)
    }
    
    
    func throttle(block: @escaping () -&gt; ()) {
        
        self.semaphore.sync  { () -&gt; () in
            job.cancel()
            job = DispatchWorkItem(){ [weak self] in
                self?.previousRun = Date()
                block()
            }
            let delay = Date.second(from: previousRun) &gt; maxInterval ? 0 : maxInterval
            queue.asyncAfter(deadline: .now() + Double(delay), execute: job)
        }
        
    }
}
 

/// DispatchSemaphore保证线程安全
public struct DispatchSemaphoreWrapper {
    
    private let semaphore: DispatchSemaphore
    
    public init(withValue value: Int) {
        
        self.semaphore = DispatchSemaphore(value: value)
    }
    
    public func sync&lt;R&gt;(execute: () throws -&gt; R) rethrows -&gt; R {
        
        _ = semaphore.wait(timeout: DispatchTime.distantFuture)
        defer { semaphore.signal() }
        return try execute()
    }
}

private extension Date {
    static func second(from referenceDate: Date) -&gt; Int {
        return Int(Date().timeIntervalSince(referenceDate).rounded())
    }
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flutter 环境变量设置]]></title>
    <link href="http://www.citynight.cn/Blog/16154734553187.html"/>
    <updated>2021-03-11T22:37:35+08:00</updated>
    <id>http://www.citynight.cn/Blog/16154734553187.html</id>
    <content type="html"><![CDATA[
<p>我把flutter文件夹拖到资源库中<br/>
<img src="media/16154734553187/16154735272429.jpg" alt="" style="width:920px;"/></p>

<p>然后更改环境变量</p>

<pre><code class="language-text">code ~/.bash_profile
</code></pre>

<p>在环境变量后面添加flutter的环境变量</p>

<pre><code class="language-text">export PATH=/Users/logan/Library/flutter/bin:$PATH
</code></pre>

<p>然后看下版本号</p>

<pre><code class="language-text">flutter --version
</code></pre>

<p>然后看到输出类似</p>

<pre><code class="language-text">Flutter 2.0.1 • channel stable • https://github.com/flutter/flutter.git
Framework • revision c5a4b4029c (7 days ago) • 2021-03-04 09:47:48 -0800
Engine • revision 40441def69
Tools • Dart 2.12.0
</code></pre>

<p>这样就没有问题了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH 免密登录设置]]></title>
    <link href="http://www.citynight.cn/Blog/16153819894563.html"/>
    <updated>2021-03-10T21:13:09+08:00</updated>
    <id>http://www.citynight.cn/Blog/16153819894563.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16153819894563/IMG_1E8AAA2E770B-1.jpeg" alt="IMG_1E8AAA2E770B-1"/></p>

<ol>
<li>首先进入 ssh 文件夹
<code>
cd ~/.ssh
</code></li>
<li>然后生成公钥和私钥
<code>
ssh-keygen
</code>
按三次回车，这样就生成了公钥和私钥，</li>
<li>把生成的公钥追加到服务器的授权文件的尾部
<code>
ssh-copy-id root@192.168.1.7 
</code>
这样就完成了免密登录的设置
<img src="media/16153819894563/16153824552757.jpg" alt="" style="width:606px;"/></li>
</ol>

<p>追加完后我们可以看下是否一致<br/>
<img src="media/16153819894563/16153840301369.jpg" alt="" style="width:606px;"/><br/>
我们能看到服务端授权文件追加的公钥就是我们客户端生成的公钥。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flutter 相关网站]]></title>
    <link href="http://www.citynight.cn/Blog/16152544377232.html"/>
    <updated>2021-03-09T09:47:17+08:00</updated>
    <id>http://www.citynight.cn/Blog/16152544377232.html</id>
    <content type="html"><![CDATA[
<p><a href="https://github.com/flutter/flutter/issues">github地址</a></p>

<p><a href="https://flutterchina.club/">Flutter中文网</a></p>

<p>三方库网站  <a href="https://pub.dev">https://pub.dev</a></p>

<h1 id="toc_0">使用Flutter 技术的App</h1>

<ul>
<li>MOO 腾讯音乐App <a href="https://mp.weixin.qq.com/s/ChbXxcd_k6_CSvI6VxwTyg">https://mp.weixin.qq.com/s/ChbXxcd_k6_CSvI6VxwTyg</a></li>
<li>闲鱼App  闲鱼Flutter技术文章专栏：<a href="https://www.zhihu.com/column/xytech">https://www.zhihu.com/column/xytech</a>  被吐槽 <a href="https://maimai.cn/web/feed_detail?fid=1573956025&amp;efid=H20EJR0aOjBt9e_HmpcW5g&amp;use_rn=1">https://maimai.cn/web/feed_detail?fid=1573956025&amp;efid=H20EJR0aOjBt9e_HmpcW5g&amp;use_rn=1</a></li>
<li>飞猪App <a href="https://juejin.cn/post/6937254156776243231">https://juejin.cn/post/6937254156776243231</a></li>
<li>美团（美团外卖App上有应用，美团主要用原生+RN） <a href="https://tech.meituan.com/tags/flutter.html">https://tech.meituan.com/tags/flutter.html</a></li>
</ul>

<h1 id="toc_1">Flutter趋势</h1>

<p>flutter热词搜索情况 <a href="https://trends.google.com/trends/explore?date=today%205-y&amp;geo=US&amp;q=flutter">https://trends.google.com/trends/explore?date=today%205-y&amp;geo=US&amp;q=flutter</a></p>

<p><img src="media/16152544377232/16152544977518.jpg" alt="" style="width:1675px;"/><br/>
<img src="media/16152544377232/16152545180865.jpg" alt="" style="width:1679px;"/></p>

<p>百度指数</p>

<p><img src="media/16152544377232/16152545369692.jpg" alt="" style="width:1317px;"/></p>

<h1 id="toc_2">设备、系统使用情况</h1>

<p>百度统计情况：<a href="https://tongji.baidu.com/research/app">https://tongji.baidu.com/research/app</a></p>

<p>苹果手机</p>

<p><img src="media/16152544377232/16152545486874.jpg" alt="" style="width:508px;"/></p>

<p><img src="media/16152544377232/16152545614616.jpg" alt="" style="width:473px;"/></p>

<p>安卓手机：</p>

<p><img src="media/16152544377232/16152545701527.jpg" alt="" style="width:490px;"/><br/>
<img src="media/16152544377232/16152545805059.jpg" alt="" style="width:473px;"/></p>

<h1 id="toc_3">系统使用情况</h1>

<p><img src="media/16152544377232/16152545904534.jpg" alt="" style="width:527px;"/><br/>
<img src="media/16152544377232/16152546057902.jpg" alt="" style="width:479px;"/><br/>
<img src="media/16152544377232/image-20210308223439673.png" alt="image-20210308223439673"/><br/>
<img src="media/16152544377232/16152548733751.jpg" alt="" style="width:478px;"/></p>

<h1 id="toc_4">结论</h1>

<p>阿里巴巴淘系技术的回答 - 知乎 <a href="https://www.zhihu.com/question/374113031/answer/1252582543">https://www.zhihu.com/question/374113031/answer/1252582543</a></p>

<p>TechLead Show 的观点 <a href="https://www.youtube.com/watch?v=AvXSFUi022s">https://www.youtube.com/watch?v=AvXSFUi022s</a></p>

<p>目前存在问题：</p>

<ol>
<li> <a href="https://github.com/flutter/flutter/issues">https://github.com/flutter/flutter/issues</a>  ，好多问题没有解决，同时也说明反馈的人多热度不错。</li>
<li>同时也能发现大厂的主要应用暂时没有使用Flutter，在新业务场景中开始尝试使用Flutter。</li>
<li>需要学习Dart语言，适应新的UI开发（大约需要一周多适应）</li>
</ol>

<p>目前公司产品中，我认为供应链项目，食堂App（客户端和商家端）完全可以使用Flutter进行开发，iPad点菜系统我认为不太合适。Flutter在动画和手势方面比原生还是有差距，而且在老旧设备的兼容性上面Flutter还不太行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用iOS模拟器测试“磁盘空间不足”情况的实用方法是什么？]]></title>
    <link href="http://www.citynight.cn/Blog/16026633643718.html"/>
    <updated>2020-10-14T16:16:04+08:00</updated>
    <id>http://www.citynight.cn/Blog/16026633643718.html</id>
    <content type="html"><![CDATA[
<p>创建一个小磁盘映像:</p>

<pre><code class="language-text">hdiutil create -size 2m -fs HFS+ /tmp/2meg.dmg
</code></pre>

<p>将其挂载到模拟器应用程序中的相关目录，例如:</p>

<pre><code class="language-text">hdiutil attach /tmp/2meg.dmg -mountpoint /Users/.../Library/Developer/CoreSimulator/Devices/.../data/Applications/.../Library/Caches
</code></pre>

<p>运行应用程序并执行测试。也可以在应用运行时完成此操作。在这种情况下，您可能不想直接将其安装为<code>Caches</code>或<code>Documents</code>目录，因为这会将当前文件隐藏在那些文件夹中。改为挂载到子目录。如果在不更改应用程序路径的情况下很难做到这一点，请在将映像挂载到非空目录之上之前，将映像挂载到其他位置并复制数据。</p>

<p>卸载:</p>

<pre><code class="language-text">hdiutil detach /Users/.../Library/Developer/CoreSimulator/Devi...
</code></pre>

<p>但是，请注意，如果移动安装点，则分离操作将失败。这总是发生，因为每次运行应用程序时，Apple都会在iOS 8上重命名模拟器目录。在这种情况下，请使用<code>mount</code>命令查找已安装的设备，例如<code>/dev/disk3s1 /Users/.../Library/...</code>，然后使用设备名称而不是安装点来卸载磁盘映像:</p>

<pre><code class="language-text">hdiutil detach disk3s1
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JDBC Class.forName vs DriverManager.registerDriver]]></title>
    <link href="http://www.citynight.cn/Blog/15990466411900.html"/>
    <updated>2020-09-02T19:37:21+08:00</updated>
    <id>http://www.citynight.cn/Blog/15990466411900.html</id>
    <content type="html"><![CDATA[
<p>要使用JDBC与数据库连接，需要选择获取相应数据库的驱动程序并注册该驱动程序,有两种方式可以注册</p>

<pre><code class="language-text">DriverManager.registerDriver(new com.mysql.jdbc.Driver());
</code></pre>

<pre><code class="language-text">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
</code></pre>

<p>当然现在也可以不用执行上面的操作也能正常执行,原因就是<code>SPI机制</code><br/>
<a href="https://juejin.im/post/6844903605695152142">Java SPI机制详解</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java开发环境搭建的准备工作]]></title>
    <link href="http://www.citynight.cn/Blog/15989690336270.html"/>
    <updated>2020-09-01T22:03:53+08:00</updated>
    <id>http://www.citynight.cn/Blog/15989690336270.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">网络配置（修改hosts）</h3>

<h4 id="toc_1">什么时候需要</h4>

<p>比如我们在安装<a href="https://brew.sh">homeBrew</a>的时候会遇到</p>

<pre><code class="language-text">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
</code></pre>

<p>发现脚本需要到 <code>raw.githubusercontent.com</code>上拉取代码,但是域名的DNS解析被污染，导致DNS解析过程不能获取正确的IP地址。</p>

<h4 id="toc_2">怎样找替换</h4>

<p>打开 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a> 输入访问不了的域名,即<code>raw.githubusercontent.com</code><br/>
可以看到<br/>
<img src="media/15989690336270/15989690890684.jpg" alt=""/><br/>
<img src="media/15989690336270/15989691067248.jpg" alt=""/></p>

<p>把找到的IP直接在<code>hosts</code>中映射就好了</p>

<h4 id="toc_3">怎样进行hosts文件修改</h4>

<p>为了方便进行网络资源访问比如<code>github</code>我们需要对<code>hosts</code>文件进行修改，对于Mac常规的方式是在<code>Finder</code>中使用 快捷键<code>command + shift + G</code>。<br/>
<img src="media/15989690336270/15989691425407.jpg" alt=""/></p>

<p>这里我推荐用第二种<a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a><br/>
<img src="media/15989690336270/15989691528858.jpg" alt=""/></p>

<h3 id="toc_4">开发环境</h3>

<h4 id="toc_5">Java环境搭建</h4>

<h5 id="toc_6">JDK下载</h5>

<p>Google <code>jdk download</code> 我们会找到Oracle网站，选择<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">jdk8版本下载</a></p>

<h5 id="toc_7">Java配置环境变量</h5>

<p>打开<code>terminal</code>,我喜欢用 <a href="https://iterm2.com/">iTerm2</a> 搭配<a href="https://ohmyz.sh/">Oh My Zsh</a>. 输入<code>code .bash_profile</code>(code 是vscode命令,怎么配置用vscode在terminal中使用见<a href="https://code.visualstudio.com/docs/setup/mac">Visual Studio Code on macOS<br/>
</a>)</p>

<p><img src="media/15989690336270/15989691773089.jpg" alt=""/></p>

<p>如果是第一次配置环境变量，使用命令 <code>touch .bash_profile</code> 创建一个名为 <strong>.bash_profile</strong> 隐藏配置文件(怎么查看隐藏文件(快捷键 <code>command + shift + .</code>));</p>

<p>查看当前安装的Java版本号<br/>
在<code>terminal</code>中输入<code>java -version</code><br/>
<img src="media/15989690336270/15989691952963.jpg" alt=""/></p>

<p>在配置文件中输入下面的内容：</p>

<pre><code class="language-shell">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home
PATH=$JAVA_HOME/bin:$PATH:.
CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH
</code></pre>

<p>JAVA_Home 中版本号就是上面terminal中显示的版本号,当然这个办法比较土，也可以按照苹果开发者网站上的办法找<a href="https://developer.apple.com/library/archive/qa/qa1170/_index.html">Important Java Directories on Mac OS </a><br/>
在terminal中输入<code>ls -l /usr/libexec/java_home</code><br/>
<img src="media/15989690336270/15989692092687.jpg" alt=""/></p>

<p>出现文件的时候可以按住<code>command</code>点击目录跳转也就会显示出上面截图中的路径</p>

<h5 id="toc_8">阅读公司技术文档</h5>

<p>文档地址：<a href="http://10.10.70.44:7202/pages/viewpage.action?pageId=13729808">SpringCloud微服务架构</a></p>

<p>这篇文档中说明了项目的模块划分和环境信息等</p>

<h5 id="toc_9">快速导包(Maven)</h5>

<p>第一运行下载依赖包非常慢，然后同事把他电脑中的资源直接打包发给我替换掉原有的资源就完成了依赖包的下载过程。<br/>
<img src="media/15989690336270/15989692306566.jpg" alt=""/></p>

<p>进入该文件夹，然后替换资源文件<br/>
<img src="media/15989690336270/15989692404224.jpg" alt=""/></p>

<hr/>

<p>到这里所有的前期准备工作都做完了可以运行项目了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[529. Minesweeper（529. 扫雷游戏）]]></title>
    <link href="http://www.citynight.cn/Blog/15978901087507.html"/>
    <updated>2020-08-20T10:21:48+08:00</updated>
    <id>http://www.citynight.cn/Blog/15978901087507.html</id>
    <content type="html"><![CDATA[
<p>题目地址:<a href="https://leetcode-cn.com/problems/minesweeper/">529. 扫雷游戏</a></p>

<p>Let&#39;s play the minesweeper game (<a href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)">Wikipedia</a>, <a href="http://minesweeperonline.com/">online game</a>)!</p>

<p>You are given a 2D char matrix representing the game board. <strong>&#39;M&#39;</strong> represents an <strong>unrevealed</strong> mine, <strong>&#39;E&#39;</strong> represents an <strong>unrevealed</strong> empty square, <strong>&#39;B&#39;</strong> represents a ** revealed** blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (&#39;1&#39; to &#39;8&#39;) represents how many mines are adjacent to this ** revealed** square, and finally <strong>&#39;X&#39;</strong> represents a ** revealed** mine.</p>

<p>Now given the next click position (row and column indices) among all the <strong>unrevealed</strong> squares (<strong>&#39;M&#39;</strong> or <strong>&#39;E&#39;</strong>), return the board after revealing this position according to the following rules:</p>

<ol>
<li>If a mine (<strong>&#39;M&#39;</strong>) is ** revealed**, then the game is over - change it to <strong>&#39;X&#39;</strong>.</li>
<li>If an empty square (<strong>&#39;E&#39;</strong>) with <strong>no adjacent mines</strong> is revealed, then change it to revealed blank (<strong>&#39;B&#39;</strong>) and all of its adjacent <strong>unrevealed</strong> squares should be revealed recursively.</li>
<li>If an empty square (<strong>&#39;E&#39;</strong>) with <strong>at least one adjacent mine</strong> is revealed, then change it to a digit (&#39;1&#39; to &#39;8&#39;) representing the number of adjacent mines.</li>
<li><p>Return the board when no more squares will be ** revealed**.</p>
<p><strong>Example 1:</strong></p></li>
</ol>

<p><strong>Input:</strong></p>

<pre><code class="language-text">[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],
 [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]

Click : [3,0]
</code></pre>

<p><strong>Output:</strong></p>

<pre><code class="language-text">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]

</code></pre>

<p><strong>Explanation:</strong><br/>
 <img src="media/15978901087507/15978907322780.png" alt="" style="width:532px;"/></p>

<ul>
<li><strong>Example 2:</strong></li>
</ul>

<p><strong>Input:</strong></p>

<pre><code class="language-text">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]

Click : [1,2]
</code></pre>

<p><strong>Output:</strong></p>

<pre><code class="language-text">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],
 [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]

</code></pre>

<p><strong>Explanation:</strong><br/>
<img src="media/15978901087507/15978909318647.png" alt="" style="width:511px;"/></p>

<p><strong>Note:</strong></p>

<ol>
<li>The range of the input matrix&#39;s height and width is [1,50].</li>
<li>The click position will only be an unrevealed square (&#39;M&#39; or &#39;E&#39;), which also means the input board contains at least one clickable square.</li>
<li>The input board won&#39;t be a stage when game is over (some mines have been revealed).</li>
<li>For simplicity, not mentioned rules should be ignored in this problem. For example, you don&#39;t need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li>
</ol>

<p>思路：<br/>
深度优先</p>

<pre><code class="language-java">public class Solution {
    // 坐标相邻的8个方向 上，下，左，右，左上，左下，右上，右下
    private int[][] dirs = {{0,1},{0,-1},{-1,0},{1,0},{-1,1},{-1,-1},{1,1},{1,-1}};
    public char[][] updateBoard(char[][] board, int[] click) {
        // 获取当前坐标
        int row = click[0], col = click[1];
        // 边界条件
        int m = board.length, n = board[0].length;

        // 如果找到M（未挖出的雷）或者X（已挖出的雷）游戏结束
        if (board[row][col] == &#39;M&#39; || board[row][col] == &#39;X&#39;) {
            board[row][col] = &#39;X&#39;;
            return board;
        }

        // 找周边有几个雷
        int num = 0;
        for (int[] dir : dirs) {
            int newRow = dir[0] + row;
            int newCol = dir[1] + col;
            // 如果周围是未被揭开的雷，周围雷的数量递增
            if (newRow &gt;= 0 &amp;&amp; newCol &gt;= 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &lt; n &amp;&amp; board[newRow][newCol] == &#39;M&#39;) {
                num++;
            }
        }

        // 如果周围有雷
        if (num &gt; 0) {
            board[row][col] = (char) (num + &#39;0&#39;);
            return board;
        }

        // 如果一个没有相邻地雷的空方块（&#39;E&#39;）被挖出，修改它为（&#39;B&#39;）
        board[row][col] = &#39;B&#39;;
        for (int[] dir : dirs) {
            int newRow = dir[0] + row;
            int newCol = dir[1] + col;
            // 所有和其相邻的未挖出方块都应该被递归地揭露。
            if (newRow &gt;= 0 &amp;&amp; newCol &gt;= 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &lt; n &amp;&amp; board[newRow][newCol] == &#39;E&#39;) {
                updateBoard(board,new int[]{newRow,newCol});
            }
        }

        return board;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[647. Palindromic Substrings]]></title>
    <link href="http://www.citynight.cn/Blog/15978472756793.html"/>
    <updated>2020-08-19T22:27:55+08:00</updated>
    <id>http://www.citynight.cn/Blog/15978472756793.html</id>
    <content type="html"><![CDATA[
<p>题目地址:<a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a><br/>
Given a string, your task is to count how many palindromic substrings in this string.</p>

<p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p>

<ul>
<li><strong>Example 1:</strong></li>
</ul>

<pre><code class="language-text">Input: &quot;abc&quot;
Output: 3
Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.
</code></pre>

<ul>
<li><strong>Example 2:</strong></li>
</ul>

<pre><code class="language-text">Input: &quot;aaa&quot;
Output: 6
Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.
</code></pre>

<p><strong>Note:</strong><br/>
The input string length won&#39;t exceed 1000.</p>

<p>解题思路：</p>

<p>使用中心扩展方法,每个字符都是一个中心，或者两个相邻一样的字符是一个中心，然后向左右分别递进判断能否形成回文</p>

<p>举个🌰</p>

<pre><code class="language-text">  比如字符串是   a   b   a
  遍历字符串   &lt;-⬆-&gt;             回文子串 a  左边没有数据所以只有这一个
                 &lt;-⬆-&gt;          回文子串 b  一个指针向左走一个指针向右走 判断是否还有对应的子串（aba）， 左边 a 右边 a 能形成字串，再走没有数据
                     &lt;-⬆-&gt;     回文字串 a 右边没有数据所以结束
  根据上面的流程 最终的字串为  a，b, aba, a 共4个
 
  当然还有两个字符一样的情况
  比如字符串是   a   b   b   a
  这样就需要      &lt;-⬆  ⬆-&gt;      从中间两个向外判断是否能形成回文子串  
</code></pre>

<p>参考代码：</p>

<pre><code class="language-java">class Solution {
    // 回文字串数量
    int count = 0;
    public int countSubstrings(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        for (int i = 0; i &lt; s.length(); i++) {
            // aba -&gt; i 为 b位置
            helper(s,i,i);
            // abba -&gt; i 为第一个b位置
            helper(s,i,i+1);
        }
        return count;
    }

    private void helper(String s, int left, int right) {
        while (left &gt;= 0 &amp;&amp; right &lt;= s.length() - 1 &amp;&amp; s.charAt(left) == s.charAt(right)) {
            count++;
            left--;
            right++;
        }
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[setProperty 应用]]></title>
    <link href="http://www.citynight.cn/Blog/15966161528946.html"/>
    <updated>2020-08-05T16:29:12+08:00</updated>
    <id>http://www.citynight.cn/Blog/15966161528946.html</id>
    <content type="html"><![CDATA[
<p>项目中使用<code>Nacos</code>,想覆盖nacos的默认配置,配置信息如下:</p>

<pre><code class="language-text">/**
 * @author cloud
 * @date 2019-10-31
 * &lt;p&gt;
 * 覆盖nacos 默认配置
 */
public interface ConfigConstants {
    /**
     * The System property name of  Standalone mode
     */
    String STANDALONE_MODE = &quot;nacos.standalone&quot;;

    /**
     * tomcat 目录
     */
    String TOMCAT_DIR = &quot;server.tomcat.basedir&quot;;

    /**
     * tomcat 日志配置
     */
    String TOMCAT_ACCESS_LOG = &quot;server.tomcat.accesslog.enabled&quot;;

    /**
     * 是否开启认证
     */
    String AUTH_ENABLED = &quot;nacos.core.auth.enabled&quot;;
}
</code></pre>

<p>在启动类中设置想要覆盖配置的值</p>

<pre><code class="language-text">/**
 * @author nacos
 * &lt;p&gt;
 * nacos console 源码运行，方便开发
 * 生产建议从官网下载最新版配置运行
 */
@EnableScheduling
@SpringBootApplication
public class CloudNacosApplication {

    public static void main(String[] args) {
        System.setProperty(ConfigConstants.TOMCAT_DIR, &quot;logs&quot;);
        System.setProperty(ConfigConstants.TOMCAT_ACCESS_LOG, &quot;false&quot;);
        System.setProperty(ConfigConstants.STANDALONE_MODE, &quot;true&quot;);
        System.setProperty(ConfigConstants.AUTH_ENABLED, &quot;false&quot;);
        SpringApplication.run(CloudNacosApplication.class, args);
    }
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[devtools 热启动]]></title>
    <link href="http://www.citynight.cn/Blog/15965236438323.html"/>
    <updated>2020-08-04T14:47:23+08:00</updated>
    <id>http://www.citynight.cn/Blog/15965236438323.html</id>
    <content type="html"><![CDATA[
<p>第一步:添加pom</p>

<pre><code class="language-text">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
</code></pre>

<p>第二步 添加插件到父pom中</p>

<pre><code class="language-text">  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;fork&gt;true&lt;/fork&gt;
          &lt;addResources&gt;true&lt;/addResources&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre>

<p>第三步 开启自动编译选项<br/>
Setting-&gt;Build-&gt;Compiler<br/>
<img src="media/15965236438323/15965240806182.jpg" alt="" style="width:475px;"/></p>

<p>第四步: 修改Registry</p>

<p>双击 Shift 选中Action 输入 Registry 打开<br/>
<img src="media/15965236438323/15965244242502.jpg" alt="" style="width:655px;"/><br/>
修改为选中<br/>
<img src="media/15965236438323/15965245587023.jpg" alt="" style="width:950px;"/><br/>
第五步: 重启IDEA</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[@Slf4j注解实现日志输出]]></title>
    <link href="http://www.citynight.cn/Blog/15965198984201.html"/>
    <updated>2020-08-04T13:44:58+08:00</updated>
    <id>http://www.citynight.cn/Blog/15965198984201.html</id>
    <content type="html"><![CDATA[
<p>最近看到B站上有人写代码没有定义log(<code>private final Logger log = LoggerFactory.getLogger(XXX.class);</code>)就能直接用<code>log</code></p>

<p>查了下可能的方案:</p>

<ol>
<li>pom引入 <code>lombok</code></li>
</ol>

<pre><code class="language-text">            &lt;dependency&gt;
                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
                &lt;artifactId&gt;lombok&lt;/artifactId&gt;
                &lt;version&gt;${lombok.version}&lt;/version&gt;
                &lt;optional&gt;true&lt;/optional&gt;
            &lt;/dependency&gt;
</code></pre>

<ol>
<li>在目标类上添加<code>@Slf4j</code>注解</li>
<li>然后直接在方法中使用<code>log.info(&quot;*****插入结果：&quot;+result);</code></li>
<li>如果使用的时候没有找到变量<code>log</code>,IDEA需要安装lombok插件</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[632. Smallest Range Covering Elements from K Lists]]></title>
    <link href="http://www.citynight.cn/Blog/15962945237035.html"/>
    <updated>2020-08-01T23:08:43+08:00</updated>
    <id>http://www.citynight.cn/Blog/15962945237035.html</id>
    <content type="html"><![CDATA[
<p>题目地址:<a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">632. 最小区间</a><br/>
You have <code>k</code> lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the <code>k</code> lists. </p>

<p>We define the range <code>[a,b]</code> is smaller than range <code>[c,d]</code> if <code>b-a &lt; d-c</code> or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p>

<ul>
<li><strong>Example 1:</strong></li>
</ul>

<pre><code class="language-text">Input: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
Output: [20,24]
Explanation: 
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
List 2: [0, 9, 12, 20], 20 is in range [20,24].
List 3: [5, 18, 22, 30], 22 is in range [20,24].
</code></pre>

<p>Note: </p>

<ol>
<li>The given list may contain duplicates, so ascending order means &gt;= here.</li>
<li>1 &lt;= k &lt;= 3500</li>
<li>-10<sup>5</sup> &lt;= value of elements &lt;= 10<sup>5.</sup></li>
</ol>

<p>解题思路：<br/>
先看🌰</p>

<pre><code class="language-text">4,10,15,24,26
0, 9,12,20
5,18,22,30
</code></pre>

<p>因为每个数组中必须有一个数字包含在其中，一开始我们取每个数组中的第一个数字</p>

<pre><code class="language-text">*4*,10,15,24,26
*0*, 9,12,20
*5*,18,22,30
</code></pre>

<p><code>4,0,5</code>最小的是<code>0</code>,最大值是<code>5</code>区间是<code>5-0=5</code><br/>
把第一个最小区间5的坐标记录下来就是<code>[0,5]</code><br/>
去掉最小的值,然后最小值所在的数组向后取一位即</p>

<pre><code class="language-text">*4*,10,15,24,26
0, *9*,12,20
*5*,18,22,30
</code></pre>

<p><code>4,9,5</code>最小的是<code>4</code>,最大值是<code>9</code>区间是<code>9-4=5</code>最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>

<pre><code class="language-text">4,*10*,15,24,26
0, *9*,12,20
*5*,18,22,30
</code></pre>

<p><code>10,9,5</code>最小的是<code>5</code>,最大值是<code>10</code>区间是<code>10-5=5</code>最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>

<pre><code class="language-text">4,*10*,15,24,26
0, *9*,12,20
5,*18*,22,30
</code></pre>

<p><code>10,9,18</code>最小的是<code>9</code>,最大值是<code>18</code>区间是<code>18-9=9</code>,因为<code>9&gt;5</code>不符合规则,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>

<pre><code class="language-text">4,*10*,15,24,26
0, 9,*12*,20
5,*18*,22,30
</code></pre>

<p><code>10,12,18</code>最小的是<code>10</code>,最大值是<code>18</code>区间是<code>18-10=8</code>,因为<code>8&gt;5</code>不符合规则,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>

<pre><code class="language-text">4,10,*15*,24,26
0, 9,*12*,20
5,*18*,22,30
</code></pre>

<p><code>15,12,18</code>最小的是<code>12</code>,最大值是<code>18</code>区间是<code>18-12=6</code>,因为<code>6&gt;5</code>不符合规则,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>

<pre><code class="language-text">4,10,*15*,24,26
0, 9,12,*20*
5,*18*,22,30
</code></pre>

<p><code>15,20,18</code>最小的是<code>15</code>,最大值是<code>20</code>区间是<code>20-15=5</code>,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>

<pre><code class="language-text">4,10,15,*24*,26
0, 9,12,*20*
5,*18*,22,30
</code></pre>

<p><code>24,20,18</code>最小的是<code>18</code>,最大值是<code>24</code>区间是<code>24-18=6</code>,因为<code>6&gt;5</code>不符合规则,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>

<pre><code class="language-text">4,10,15,*24*,26
0, 9,12,*20*
5,18,*22*,30
</code></pre>

<p><code>24,20,22</code>最小的是<code>20</code>,最大值是<code>24</code>区间是<code>24-20=4</code>,因为<code>4&lt;5</code>符合规则,最小区间变更为4,把最小区间4的坐标记录下来就是<code>[20,24]</code>,这时继续向后走,由于最小值是<code>20</code>而<code>20</code>所在的数组已经走到了结尾,不能继续走,再走就不能满足每个数组中必须有一个数包含在其中.<br/>
所以返回最小区间<code>[20,24</code></p>

<p>参考代码:</p>

<pre><code class="language-java">class Solution {
    public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) {
        // 里面存储的是行列数据位置，优先级是列中数据大小
        PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; nums.get(o[0]).get(o[1])));
        int max = Integer.MIN_VALUE, start = 0, end = Integer.MAX_VALUE;
        // 先让每个数组中的第一个数进入 q
        for (int i = 0; i &lt; nums.size(); i++) {
            q.offer(new int[]{i, 0});
            max = Math.max(max, nums.get(i).get(0));
        }
        while (q.size() == nums.size()) {
            // 取出最小的元素获得到行列信息
            int e[] = q.poll(), row = e[0], col = e[1];
            // 比较，如果符合条件就更新最小区间信息
            if (end - start &gt; max - nums.get(row).get(col)) {
                start = nums.get(row).get(col);
                end = max;
            }
            // 防止越界
            if (col + 1 &lt; nums.get(row).size()) {
                q.offer(new int[]{row, col + 1});
                max = Math.max(max, nums.get(row).get(col + 1));
            }
        }
        return new int[]{start, end};
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[# 深入理解 iOS 事件机制]]></title>
    <link href="http://www.citynight.cn/Blog/15654059537017.html"/>
    <updated>2019-08-10T10:59:13+08:00</updated>
    <id>http://www.citynight.cn/Blog/15654059537017.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>原文来自<a href="https://juejin.im/post/5d396ef7518825453b605afa">掘金</a></p>
</blockquote>

<h2 id="toc_0">前言</h2>

<p>这篇文章始于一个需求：我们在 SDK 提供的某个 View 的 Subview 中实现了单击双击等多个 Gesture Recognizer，而客户希望自己在这个 View 上的单击手势不会冲突，同时没有延迟。</p>

<p>借此机会，我们来重温下 iOS 的事件机制和手势冲突，重点介绍下 UIGestureRecognizer 之间以及与原生触摸事件的相互关系。</p>

<h2 id="toc_1">事件的生命周期</h2>

<p>当指尖触碰屏幕时，一个触摸事件就在系统中生成了。经过 IPC 进程间通信，事件最终被传递到了合适的应用。在应用内历经峰回路转的奇幻之旅后，最终被释放。大致经过如下图：</p>

<p><img src="media/15654059537017/15654060901311.jpg" alt=""/></p>

<h3 id="toc_2">系统响应阶段</h3>

<ol>
<li><p>手指触碰屏幕，屏幕感应到触碰后，将事件交由 IOKit 处理。</p></li>
<li><p>IOKit 将触摸事件封装成一个 IOHIDEvent 对象，并通过 mach port 传递给 SpringBoard 进程。</p></li>
</ol>

<blockquote>
<p>mach port 进程端口，各进程之间通过它进行通信。</p>

<p>SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。</p>
</blockquote>

<ol>
<li>SpringBoard 进程因接收到触摸事件，触发了主线程 runloop 的 source1 事件源的回调。此时 SpringBoard 会根据当前桌面的状态，判断应该由谁处理此次触摸事件。因为事件发生时，你可能正在桌面上翻页，也可能正在刷微博。若是前者（即前台无 APP 运行），则触发 SpringBoard 本身主线程 runloop 的 source0 事件源的回调，将事件交由桌面系统去消耗；若是后者（即有 APP 正在前台运行），则将触摸事件通过 IPC 传递给前台 APP 进程，接下来的事情便是 APP 内部对于触摸事件的响应了。</li>
</ol>

<h3 id="toc_3">APP响应阶段</h3>

<ol>
<li><p>APP 进程的 mach port 接受到 SpringBoard 进程传递来的触摸事件，主线程的 runloop 被唤醒，触发了 source1 回调。</p></li>
<li><p>source1 回调又触发了一个 source0 回调，将接收到的 IOHIDEvent 对象封装成 UIEvent 对象，此时 APP 将正式开始对于触摸事件的响应。</p></li>
<li><p>source0 回调内部将触摸事件添加到 UIApplication 对象的事件队列中。事件出队后，UIApplication 开始一个寻找最佳响应者的过程，这个过程又称 Hit-Testing，细节将在下一节阐述。另外，此处开始便是与我们平时开发相关的工作了。</p></li>
<li><p>寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。事实上，事件除了被响应者消耗，还能被手势识别器或是 Target-Action 模式捕捉并消耗掉。其中涉及对触摸事件的响应优先级。</p></li>
<li><p>触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么至死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop 若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。</p></li>
</ol>

<h2 id="toc_4">探测链与响应链</h2>

<h3 id="toc_5">Hit-Testing</h3>

<p>从逻辑上来说，探测链是最先发生的机制，当触摸事件发生后，iOS 系统根据 Hit-Testing 来确定触摸事件发生在哪个视图对象上。其中主要用到了两个 UIView 中的方法：</p>

<pre><code class="language-text">// recursively calls -pointInside:withEvent:. point is in the receiver&#39;s coordinate system
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

// default returns YES if point is in bounds
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;
复制代码
</code></pre>

<p>前者会通过递归调用后者来返回一个适合响应触摸事件的视图，下面这张图描述了这个过程：</p>

<p><img src="media/15654059537017/15654061281073.jpg" alt=""/></p>

<h3 id="toc_6">Responder Chain</h3>

<p>Hit-Testing 找到的视图拥有最先对触摸事件进行处理的机会，如果该视图无法处理这个事件，那么事件对象就会沿着响应器的视图链向上传递，直到找到可以处理该事件的对象为止。下面这张图描述了这个过程：</p>

<p><img src="media/15654059537017/15654061526891.jpg" alt=""/></p>

<h3 id="toc_7">Demo 验证</h3>

<p>接下来我们通过官方文档的 Demo 以代码的方式来进行验证：</p>

<p><img src="media/15654059537017/15654061728509.jpg" alt=""/></p>

<p>对于每个 View，我们重载父类的方法：</p>

<pre><code class="language-text">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    NSLog(@&quot;进入A_View---hitTest withEvent ---&quot;);
    UIView * view = [super hitTest:point withEvent:event];
    NSLog(@&quot;离开A_View--- hitTest withEvent ---hitTestView:%@&quot;,view);
    return view;
}

- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_view--- pointInside withEvent ---&quot;);
    BOOL isInside = [super pointInside:point withEvent:event];
    NSLog(@&quot;A_view--- pointInside withEvent --- isInside:%d&quot;,isInside);
    return isInside;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;A_touchesBegan&quot;);
    [super touchesBegan:touches withEvent:event];
}

- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_touchesMoved&quot;);
    [super touchesMoved:touches withEvent:event];
}

- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_touchesEnded&quot;);
    [super touchesEnded:touches withEvent:event];
}

-(void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;A_touchesCancelled&quot;);
    [super touchesCancelled:touches withEvent:event];
}
复制代码
</code></pre>

<p>点击 View D，log 显示如下，这与探测链与响应链的机制的描述相同。</p>

<pre><code class="language-text">进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
D_touchesBegan
C_touchesBegan
A_touchesBegan
D_touchesEnded
C_touchesEnded
A_touchesEnded
复制代码
</code></pre>

<p>（这里其实 Hit-Testing 进行了两次，关于这个问题，苹果官方有相应的回复）</p>

<blockquote>
<p>Yes, it’s normal. The system may tweak the point being hit tested between the calls. Since hitTest should be a pure function with no side-effects, this should be fine.</p>
</blockquote>

<h3 id="toc_8">小结</h3>

<p><strong>1. 系统通过 <code>hitTest:withEvent:</code> 方法沿视图层级树从底向上（从根视图开始）从后向前（从逻辑上更靠近屏幕的视图开始）进行遍历，最终返回一个适合响应触摸事件的 View。</strong></p>

<p><strong>2. 原生触摸事件从 Hit-Testing 返回的 View 开始，沿着响应链从上向下进行传递。</strong></p>

<p>探测链与响应链的机制总体比较清晰，不再赘述，但熟悉这两个机制并不能帮我们解决任何问题，接下来我们继续深入探究下手势识别器。</p>

<h2 id="toc_9">手势识别器</h2>

<p>我们首先思考一个问题，对于官方文档里的 Demo，我们在每个 View 上添加一个 UITapGestureRecognizer，当点击 View D 时，UITapGestureRecognizer 之间的响应顺序是什么样的，哪个 View 上的 UITapGestureRecognizer 又会最终响应这个事件？</p>

<h3 id="toc_10">官方文档</h3>

<p>我们先来看看官方文档是怎么说的：</p>

<blockquote>
<p>When a view has multiple gesture recognizers attached to it, you may want to alter how the competing gesture recognizers receive and analyze touch events. By default, there is no set order for which gesture recognizers receive a touch first, and for this reason touches can be passed to gesture recognizers in a different order each time. You can override this default behavior to:</p>

<ul>
<li><p>Specify that one gesture recognizer should analyze a touch before another gesture recognizer.</p></li>
<li><p>Allow two gesture recognizers to operate simultaneously.</p></li>
<li><p>Prevent a gesture recognizer from analyzing a touch.</p></li>
</ul>

<p>Use the UIGestureRecognizer class methods, delegate methods, and methods overridden by subclasses to effect these behaviors.</p>
</blockquote>

<p>根据文档的说法，当触摸事件发生时，哪个 UIGestureRecognizer 先收到这个事件并没有固定的顺序，并且文档建议我们使用 UIGestureRecognizer 提供的方法来控制它们之间的顺序和相互关系。</p>

<h3 id="toc_11">UIGestureRecognizer Methods</h3>

<p>所以我们依次看下系统的 UIGestureRecognizer 都提供了哪些与它们之间相互关系有关的方法：</p>

<pre><code class="language-text">// create a relationship with another gesture recognizer that will prevent this gesture&#39;s actions from being called until otherGestureRecognizer transitions to UIGestureRecognizerStateFailed
// if otherGestureRecognizer transitions to UIGestureRecognizerStateRecognized or UIGestureRecognizerStateBegan then this recognizer will instead transition to UIGestureRecognizerStateFailed
// example usage: a single tap may require a double tap to fail
- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer;

// called once per attempt to recognize, so failure requirements can be determined lazily and may be set up between recognizers across view hierarchies
// return YES to set up a dynamic failure requirement between gestureRecognizer and otherGestureRecognizer
//
// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture&#39;s counterpart delegate or subclass methods may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
复制代码
</code></pre>

<p>这三个方法比较常用，它们可以指定 UIGestureRecognizer 之间的依赖关系，区别在于第一个一般适用于在同一个 View 中创建的多个 UIGestureRecognizer 的场景，当 View 层级比较复杂或者 UIGestureRecognizer 处于 Framework 内部时可以用后两个方法动态指定。</p>

<pre><code class="language-text">// called when the recognition of one of gestureRecognizer or otherGestureRecognizer would be blocked by the other
// return YES to allow both to recognize simultaneously. the default implementation returns NO (by default no two gestures can be recognized simultaneously)
//
// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture&#39;s delegate may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;
复制代码
</code></pre>

<p>这个方法可以控制两个 UIGestureRecognizer 之间是否可以同时异步进行，需要注意的是，假设存在两个可能会互相 block 的 UIGestureRecognizer，系统会分别对它们的 delegate 调用这个方法，只要有一个返回 YES，那么这两个 UIGestureRecognizer 就可以同时进行识别，这与 <code>shouldRequireFailureOfGestureRecognizer</code> 是类似的。</p>

<pre><code class="language-text">// called before touchesBegan:withEvent: is called on the gesture recognizer for a new touch. return NO to prevent the gesture recognizer from seeing this touch
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;

// called when a gesture recognizer attempts to transition out of UIGestureRecognizerStatePossible. returning NO causes it to transition to UIGestureRecognizerStateFailed
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;
复制代码
</code></pre>

<p>这两个方法都是用来禁止 UIGestureRecognizer 响应触摸事件的，区别在于，当触摸事件发生时，使用第一个方法可以立即控制 UIGestureRecognizer 是否对其处理，且不会修改 UIGestureRecognizer 的状态机（因为在调用自身的 <code>touchesBegan:withEvent:</code> 之前，详见下），而第二个方法会等待一段时间，在 UIGestureRecognizer 识别手势转换状态时调用，返回 NO 会改变其状态机，使其 state 变为 <code>UIGestureRecognizerStateFailed</code>。</p>

<p>我们看下官方文档对这两个方法的说明：</p>

<blockquote>
<p>When a touch begins, if you can immediately determine whether or not your gesture recognizer should consider that touch, use thegestureRecognizer:shouldReceiveTouch: method. This method is called every time there is a new touch. Returning NO prevents the gesture recognizer from being notified that a touch occurred. The default value is YES. This method does not alter the state of the gesture recognizer.</p>

<p>If you need to wait as long as possible before deciding whether or not a gesture recognizer should analyze a touch, use thegestureRecognizerShouldBegin: delegate method. Generally, you use this method if you have a UIView or UIControl subclass with custom touch-event handling that competes with a gesture recognizer. Returning NO causes the gesture recognizer to immediately fail, which allows the other touch handling to proceed. This method is called when a gesture recognizer attempts to transition out of the Possible state, if the gesture recognition would prevent a view or control from receiving a touch.</p>

<p>You can use the gestureRecognizerShouldBegin:UIView method if your view or view controller cannot be the gesture recognizer’s delegate. The method signature and implementation is the same.</p>
</blockquote>

<p>第二段介绍了通常情况下，当我们的子类 UIView 或 UIControl 有和 UIGestureRecognizer 冲突的自定义触摸事件时，可以使用 <code>gestureRecognizerShouldBegin:</code> 方法让 UIGestureRecognizer 失效来使自定义的触摸事件进行响应。第三段说明了当我们的 View 不是 UIGestureRecognizer 的 delegate 时，可以使用 UIView 中的 <code>gestureRecognizerShouldBegin:</code> 方法。关于这两段的意思我们会在后两节去详细解释。</p>

<pre><code class="language-text">// mirror of the touch-delivery methods on UIResponder
// UIGestureRecognizers aren&#39;t in the responder chain, but observe touches hit-tested to their view and their view&#39;s subviews
// UIGestureRecognizers receive touches before the view to which the touch was hit-tested
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);
复制代码
</code></pre>

<p>与 UIResponder 中的触摸事件相关的方法相同，UIGestureRecognizer 有一套自己的触摸事件的方法，区别在于，UIGestureRecognizer 并不在响应链中，这些方法一般是写用来对特定的手势进行判断和识别的逻辑，例如我们可以在子类中重写这些方法来创建自己的 UIGestureRecognizer。使用 <code>gestureRecognizer:shouldReceiveTouch:</code> 可以让这些方法不被调用。</p>

<p>至此，UIGestureRecognizer 已经为我们提供了足够多的方法来控制它们之间的相互关系了，我们接下来在 Demo 中试试看。</p>

<h3 id="toc_12">Demo 验证</h3>

<p>对于官方文档中的 Demo 的每个 View，我们增加一个继承自 UITapGestureRecognizer 的 ZTTapGestureRecognizer 并实现相应的回调：</p>

<pre><code class="language-text">- (void)singleTapGesture
{
    NSLog(@&quot;A_singleTapGesture&quot;);
}

- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
    NSLog(@&quot;A_view--- gestureRecognizerShouldBegin: %@ ---&quot;, gestureRecognizer.name);
    return YES;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch
{
    NSLog(@&quot;A_view--- gestureRecognizer shouldReceiveTouch: %@ ---&quot;, gestureRecognizer.name);
    return YES;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    NSLog(@&quot;A_view--- gestureRecognizer: %@ otherGestureRecognizer: %@ ---&quot;, gestureRecognizer.name, otherGestureRecognizer.name);
    return YES;
}

- (instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;A_view_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];
    }

    return self;
}
复制代码
</code></pre>

<p>在我们子类 ZTTapGestureRecognizer 中重写父类关于触摸事件的方法：</p>

<pre><code class="language-text">@implementation ZTTapGestureRecognizer

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;%@_touchesBegan&quot;, self.name);
    [super touchesBegan:touches withEvent:event];
}

- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;%@_touchesMoved&quot;, self.name);
    [super touchesMoved:touches withEvent:event];
}

// NSLog 要写在 super 后面来读取 state
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    [super touchesEnded:touches withEvent:event];
    NSLog(@&quot;%@_touchesEndedWithState: %d&quot;, self.name, (int)self.state);
}

// NSLog 要写在 super 后面来读取 state
-(void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    [super touchesCancelled:touches withEvent:event];
    NSLog(@&quot;%@_touchesCancelledWithState: %d&quot;, self.name, (int)self.state);
}

@end
复制代码
</code></pre>

<p>点击 View D，log 显示如下：</p>

<pre><code class="language-text">进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
D_touchesBegan
C_touchesBegan
A_touchesBegan
D_view--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesEndedWithState: 3
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: A_view_tapGestureRecognizer ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: D_view_tapGestureRecognizer ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: A_view_tapGestureRecognizer ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: C_view_tapGestureRecognizer ---
A_singleTapGesture
D_touchesCancelled
C_touchesCancelled
A_touchesCancelled
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>

<p>信息量有点大，我们一点一点来分析（<strong>先忽略 View 响应链里 UIResponder 相关的触摸事件方法，这些会在下一节进行探讨</strong>），首先系统通过 Hit-Testing 机制找到了适合响应的 View D，接下来调用了方法：</p>

<pre><code class="language-text">D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
复制代码
</code></pre>

<p>上文已经对 <code>gestureRecognizer:shouldReceiveTouch:</code> 解释过，先调用它是没有问题的，但是在多次实验中，一直都是 D C A 的顺序，而 UIGestureRecognizer 其他的 Delegate Method 却有可能是不同的顺序，这是为什么呢？</p>

<p>我们来看下 View D 这个方法的调用栈：</p>

<p><img src="media/15654059537017/15654062505074.jpg" alt=""/></p>

<p>可以看到，UITouchesEvent 遍历了一个 View 数组，系统通过 Hit-Testing 过程得到了适合响应触摸事件的 View D，随后会根据这个 View 的层级关系得到一个响应链 View 数组 [D_view, C_view, A_view, ..., ZTWindow] 然后遍历这个数组去依次判断每个 View 上的 UIGestureRecognizer 是否要接收触摸事件，没有绑定到这个响应链 View 数组上的 UIGestureRecognizer 不再有机会去处理触摸事件，关于原因后面会解释。</p>

<p>接下来调用了方法：</p>

<pre><code class="language-text">D_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan

D_view--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesEndedWithState: 3
复制代码
</code></pre>

<p>View A 中 <code>gestureRecognizerShouldBegin:</code> 方法的调用栈：</p>

<p><img src="media/15654059537017/15654062776619.jpg" alt=""/></p>

<p>由于我们的 <code>gestureRecognizer:shouldReceiveTouch:</code> 都返回了 YES，3个 View 上的 UIGestureRecognizer 分别收到了 <code>touchesBegan</code> 和 <code>touchesEnd</code> 等触摸事件相关的 方法并开始对触摸手势进行识别。从调用栈中可以看出，在 <code>touchesEnd</code> 方法中手势识别完成之后即将进行状态转换之前调用了 <code>gestureRecognizerShouldBegin:</code> 方法判断是否应该进行手势识别成功的状态转换，由于我们的方法都返回了 YES，可以看到在 <code>touchesEnd</code> 方法完成之后3个 UIGestureRecognizer 都成功识别了手势并且自身的 state 都变成了 <code>UIGestureRecognizerStateEnded</code>，这些与我们上一小节的描述是相符的。</p>

<p>需要注意的是，对于 A_view_tapGestureRecognizer 和 C_view_tapGestureRecognizer 来说，除了它们各自的 delegate，最上层的 View D 也收到了他们的 <code>gestureRecognizerShouldBegin:</code> 回调，这是为什么呢？回顾上一小节关于这个方法官方文档的解释，UIView 自身也有一个 <code>gestureRecognizerShouldBegin:</code> 方法，当 View 不是 UIGestureRecognizer 的 delegate 时，我们可以使用这个方法来使 UIGestureRecognizer 失效。对于所有绑定到父 View 上的 UIGestureRecognizer，除了它们本身的 delegate 之外，Hit-Testing 返回的 View 也会收到这个方法的调用，关于原因我们会在下一节进行解释。</p>

<p>接下来的 log 是 UIGestureRecognizer 是否可以同时处理触摸事件的回调方法，其中的 null 是系统的手势 UIScreenEdgePanGestureRecognizer，由于 Demo 使用了 UINavigationController 系统会首先判断这个手势法是否能同时响应。可以看到，由于这3个 View 上一共存在3个 UIGestureRecognizer，系统一共调用了6次回调方法才可以确定它们之间的关系，这和我们上文对该方法的描述相符。</p>

<p>需要注意的是，UIGestureRecognizer 触摸事件相关的方法 <code>touchesBegan</code> 等和 <code>gestureRecognizerShouldBegin:</code> 对于 View A C D 来说每次运行顺序是不一样的（<code>gestureRecognizer:shouldReceiveTouch:</code> 每次都是 D C A），但最终 UIGestureRecognizer 的 Action Method 的顺序却一定是 A C D：</p>

<pre><code class="language-text">A_singleTapGesture
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>

<p>同时，当 <code>shouldRecognizeSimultaneouslyWithGestureRecognizer</code> 都返回 NO 时，View D 上的 UIGestureRecognizer 可以响应成功。这又是什么原因呢？</p>

<p>我们在上一步 UITouchesEvent 遍历响应链 View 数组的过程中得到了一个 UIGestureRecognizer 数组 [D_view_tapGestureRecognizer, C_view_tapGestureRecognizer, A_view_tapGestureRecognizer] 随后系统遍历了这个数组来进行处理，这里猜测它们的 <code>touchesBegan</code> 等方法的顺序应该与具体的实现有关（个人猜测可能与 UIGestureEnvironment 里保存的 UIGestureRecognizer 的数据结构实际上不是数组而是图有关系），而 Action Method 的顺序以及最后确保 View D 上的 UIGestureRecognizer 能够响应成功应该也是目前官方未说明的某种机制。</p>

<p>还有一点需要注意的是，<code>gestureRecognizer:shouldReceiveTouch:</code> 与其他的方法不属于相同的调用栈，我们来看下其他方法的调用栈：</p>

<p><img src="media/15654059537017/15654062975213.jpg" alt=""/></p>

<p><img src="media/15654059537017/15654063204292.jpg" alt=""/></p>

<p>可以看到，最先由 UIApplication 通过 <code>sendEvent:</code> 发送了 UIEvent 事件，然后被 UIWindow 转发给了 UIGestureEnvironment，而 UIGestureEnvironment 通过遍历一个 UIGestureRecognizer 数组来调起相关的 UIGestureRecognizer 方法。</p>

<p>到此为止，整个过程仍然有很多疑点，我们重新进行下梳理。</p>

<h3 id="toc_13">UIEvent 与 UIGestureEnvironment</h3>

<p>实际上，系统最先通过 Hit-Testing 机制来对 UIEvent 进行了包装，我们先看下 UIEvent 这个类：</p>

<pre><code class="language-text">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIEvent : NSObject

@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);

@property(nonatomic,readonly) NSTimeInterval  timestamp;

#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;
#else
- (nullable NSSet &lt;UITouch *&gt; *)allTouches;
#endif
- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;
- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;
- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture NS_AVAILABLE_IOS(3_2);

@end
复制代码
</code></pre>

<p>可以看到 UIEvent 所有的属性都是只读以防止被修改，在 View A 的 <code>hitTest:withEvent:</code> 方法中，实际传递的是它的子类 UITouchesEvent：</p>

<p><img src="media/15654059537017/15654063416976.jpg" alt=""/></p>

<p>在 Hit-Testing 阶段，UIEvent 只包含了一个时间戳信息，我们在 View A 的 <code>hitTest:withEvent:</code>方法中打断点来查看下 UITouchesEvent 的内容：</p>

<p><img src="media/15654059537017/15654063597676.jpg" alt=""/></p>

<p>接下来，我们继承 UIWindow 来截获 <code>sendEvent:</code> 事件，并打断点来查看此时 UIEvent 的信息，此时 UIEvent 中多了 UITouch：</p>

<p><img src="media/15654059537017/15654063714528.jpg" alt=""/></p>

<pre><code class="language-text">Printing description of event:
&lt;UITouchesEvent: 0x2819a8120&gt; timestamp: 875742 touches: {(
    &lt;UITouch: 0x11bd35960&gt; phase: Began tap count: 1 force: 0.000 window: &lt;UIWindow: 0x11bd1c610; frame = (0 0; 414 736); gestureRecognizers = &lt;NSArray: 0x2825c94d0&gt;; layer = &lt;UIWindowLayer: 0x282bb5900&gt;&gt; view: &lt;DView: 0x11be2faa0; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x2825f2a60&gt;; layer = &lt;CALayer: 0x282b894a0&gt;&gt; location in window: {234.66665649414062, 482.66665649414062} previous location in window: {234.66665649414062, 482.66665649414062} location in view: {147.66665649414062, 35.666656494140625} previous location in view: {147.66665649414062, 35.666656494140625}
)}
复制代码
</code></pre>

<p>根据 UIEvent 和 UITouchesEvent 的 API 和以上信息，我们可以推断，系统通过 Hit-Testing 记录了适合响应触摸事件的 View 与 Window 等信息，在 Hit-Testing 完成之后，创建了 UITouch 并将其保存在 UIEvent 中进行发送。UIApplication 能够通过 <code>sendEvent:</code> 方法发送事件给正确的 UIWindow 正是由于在 Hit-Testing 过程中系统记录了能够响应触摸事件的 Window。</p>

<p>而 UITouch 中的 UIGestureRecognizer 数组正是通过前面提到的 <code>gestureRecognizer:shouldReceiveTouch:</code> 来生成的，我们来看下在 Hit-Testing 完成之后，<code>sendEvent:</code> 调用之前，View D 的 <code>gestureRecognizer:shouldReceiveTouch:</code> 方法中的 UITouch：</p>

<p><img src="media/15654059537017/15654063890469.jpg" alt=""/></p>

<p>此时，Window 和 DView 已经通过 Hit-Testing 找到，但是 <code>_gestureRecognizers</code> 仍然为空，而在该方法返回 YES 之后，我们在 View C 的 <code>gestureRecognizer:shouldReceiveTouch:</code> 方法中可以看到：</p>

<p><img src="media/15654059537017/15654064024881.jpg" alt=""/></p>

<p>此时 D_view_tapGestureRecognizer 已经被添加到了数组中，同样的，在 View A 的方法中，C_view_tapGestureRecognizer 被添加到了数组中，在最终的 UIEvent 中的 UITouch 里，3个 UIGestureRecognizer 都被保存了起来，所以 UIApplication 才知道如何向正确的 UIGestureRecognizer 发送触摸事件。</p>

<p>接下来说下 UIGestureEnvironment，我们可以认为它是管理所有手势的上下文环境，当调用 <code>addGestureRecognizer:</code> 方法时会将 UIGestureRecognizer 加入到其中。下面是 UIGestureEnvironment 的结构：</p>

<pre><code class="language-text">@interface UIApplication : UIResponder  {
    UIGestureEnvironment * __gestureEnvironment;
    }
@end

@interface UIGestureRecognizer : NSObject {
    UIGestureEnvironment * _gestureEnvironment;
    }
@end

@interface UIGestureEnvironment : NSObject {

    CFRunLoopObserverRef _gestureEnvironmentUpdateObserver;
    NSMutableSet* _gestureRecognizersNeedingUpdate;
    NSMutableSet* _gestureRecognizersNeedingReset;
    NSMutableSet* _gestureRecognizersNeedingRemoval;
    NSMutableArray* _dirtyGestureRecognizers;
    NSMutableArray* _delayedTouches;
    NSMutableArray* _delayedTouchesToSend;
    NSMutableArray* _delayedPresses;
    NSMutableArray* _delayedPressesToSend;
    NSMutableArray* _preUpdateActions;
    bool _dirtyGestureRecognizersUnsorted;
    bool _updateExclusivity;
    UIGestureGraph* _dependencyGraph;
    NSMapTable* _nodesByGestureRecognizer;

}

-(void)addGestureRecognizer:(id)arg1 ;
-(void)removeGestureRecognizer:(id)arg1 ;
-(void)_cancelGestureRecognizers:(id)arg1 ;
-(void)_updateGesturesForEvent:(id)arg1 window:(id)arg2 ;
（省略了很多 API）
-(void)_cancelTouches:(id)arg1 event:(id)arg2 ;
-(void)_cancelPresses:(id)arg1 event:(id)arg2 ;
@end
复制代码
</code></pre>

<p>UIApplication 和 UIGestureRecognizer 中保存了同一个 UIGestureEnvironment 对象，根据上面 UIGestureRecognizer 的 Action Method 的调用栈，我们可以看到，UIWindow 通过 <code>sendEvent:</code>发送事件之后，UIGestureEnvironment 接收了这个事件并且最终通过方法：</p>

<pre><code class="language-text">-[UIGestureEnvironment _updateForEvent:window:] ()
-[UIGestureEnvironment _deliverEvent:toGestureRecognizers:usingBlock:] ()
复制代码
</code></pre>

<p>来对 UIGestureRecognizer 相关方法进行调用：</p>

<ol>
<li>对能够处理事件的 UIGestureRecognizer 发送 <code>touchesBegan:withEvent:</code> 等触摸事件的方法</li>
<li>通过 <code>gestureRecognizerShouldBegin</code> 方法判断是否应该进行状态转换</li>
<li>询问 UIGestureRecognizer 的 delegate 是否应该失效或者是否能够同时处理事件<code>gestureRecognizer:shouldRequireFailureOfGestureRecognizer:</code><code>gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:</code></li>
<li>UIGestureRecognizer 识别事件之后最终调用了 Action Method</li>
</ol>

<h3 id="toc_14">小结</h3>

<p><strong>1. 系统在探测阶段结束后创建了 UITouch，并封装了 UIEvent 将其传递。</strong></p>

<p><strong>2. 手势上下文 UIGestureEnvironment 最先收到 UIEvent，并负责通知给相关的 UIGestureRecognizer。</strong></p>

<p><strong>3. UIGestureEnvironment 根据 UIGestureRecognizer 的 delegate 方法来判断其是否能够对触摸事件进行响应。</strong></p>

<p>至此，UIGestureRecognizer 对事件的处理以及它们之间的相互关系告一段落。需要注意的是，建议最好使用官方文档推荐的方法对 UIGestureRecognizer 进行控制，而不要依赖上文中没有存在于文档中的具体实现细节和结论，苹果没有对外暴露这些，有可能会在接下来的版本中修改具体实现。</p>

<h2 id="toc_15">手势识别器与原生触摸事件</h2>

<p>接下来我们终于可以对上一节中 UIResponder 相关的系统原生触摸事件方法进行探讨了，我们去掉 Hit-Testing 与 UIGestureRecognizer 的 delegate 等相关方法，重新运行 Demo，点击 View D，log 显示如下：</p>

<pre><code class="language-text">A_view_tapGestureRecognizer_touchesBegan
D_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
D_touchesBegan
C_touchesBegan
A_touchesBegan
A_singleTapGesture
D_touchesCancelled
C_touchesCancelled
A_touchesCancelled
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>

<h3 id="toc_16">官方文档</h3>

<p>按照惯例，我们先来看下官方文档是怎么说的：</p>

<blockquote>
<p>There may be times when you want a view to receive a touch before a gesture recognizer. But, before you can alter the delivery path of touches to views, you need to understand the default behavior. In the simple case, when a touch occurs, the touch object is passed from the UIApplication object to the UIWindow object. Then, the window first sends touches to any gesture recognizers attached the view where the touches occurred (or to that view’s superviews), before it passes the touch to the view object itself.</p>

<p>Gesture Recognizers Get the First Opportunity to Recognize a Touch</p>

<p>A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence.</p>
</blockquote>

<p><img src="media/15654059537017/15654064332119.jpg" alt=""/></p>

<p>文档实际上说的比较清楚：UIWindow 会先将触摸事件发送给 Hit-Testing 返回的 View 和它的父 View 上的 UIGestureRecognizer，然后才会发送给这个 View 本身，如果 UIGestureRecognizer 成功识别了这个手势，之后 UIWindow 不会再向 View 发送触摸事件，并且会取消之前发送的触摸事件。</p>

<p>下面让我们回到 Demo 来进行验证。</p>

<h3 id="toc_17">Demo 验证</h3>

<p>从 log 上看，现象与官方文档的说法吻合，我们用几个调用栈来对其进行进一步证明：</p>

<p>ZTTapGestureRecognizer 的 <code>touchesBegan:withEvent:</code> 的调用栈:</p>

<p><img src="media/15654059537017/15654064509943.jpg" alt=""/></p>

<p>View D 的 <code>touchesBegan:withEvent:</code> 的调用栈：</p>

<p><img src="media/15654059537017/15654064661803.jpg" alt=""/></p>

<p>View D 的 <code>touchesCancelled:withEvent:</code> 的调用栈：</p>

<p><img src="media/15654059537017/15654064771703.jpg" alt=""/></p>

<p>可以看到，UIWindow 首先通过 <code>sendEvent:</code> 方法经过 UIGestureEnvironment 发送触摸事件给了 ZTTapGestureRecognizer，随后通过 <code>sendTouchesForEvent:</code> 方法发送触摸事件给 View D 并沿着响应链传递，而当 A_view_tapGestureRecognizer 第一个成功识别手势之后，UIGestureEnvironment 发起响应链的 cancel 并经过 UIApplication 发送给 View D 并沿着响应链取消。</p>

<h3 id="toc_18">UIGestureRecognizer Properties</h3>

<p>UIGestureRecognizer 有一些与响应链触摸事件相关的属性，这里简单说明一下：</p>

<pre><code class="language-text">// default is YES. causes touchesCancelled:withEvent: or pressesCancelled:withEvent: to be sent to the view for all touches or presses recognized as part of this gesture immediately before the action method is called.
@property(nonatomic) BOOL cancelsTouchesInView;
复制代码
</code></pre>

<p>这个属性可以控制当 UIGestureRecognizer 成功识别手势之后是否要取消响应链对触摸事件的响应，默认为 YES，设置为 NO 之后，即使 UIGestureRecognizer 识别了手势，UIGestureEnvironment 也不会发起对响应链的 cancel。</p>

<pre><code class="language-text">// default is NO.  causes all touch or press events to be delivered to the target view only after this gesture has failed recognition. set to YES to prevent views from processing any touches or presses that may be recognized as part of this gesture
@property(nonatomic) BOOL delaysTouchesBegan;
复制代码
</code></pre>

<p>设置为 YES 时，这个属性可以控制在 UIGestureRecognizer 识别手势期间截断事件，识别失败后响应链才能收到触摸事件。</p>

<pre><code class="language-text">// default is YES. causes touchesEnded or pressesEnded events to be delivered to the target view only after this gesture has failed recognition. this ensures that a touch or press that is part of the gesture can be cancelled if the gesture is recognized
@property(nonatomic) BOOL delaysTouchesEnded;
复制代码
</code></pre>

<p>默认为 YES，当手势识别失败时，若此时触摸事件已经结束，会延迟一小段时间（0.15s）再调用响应者的 <code>touchesEnded:withEvent:</code>，若设置成NO，则在手势识别失败时会立即通知 UIApplication 发送状态为 end 的 触摸事件给 Hit-Testing 返回的 View 以调用 <code>touchesEnded:withEvent:</code> 结束事件响应。</p>

<h3 id="toc_19">小结</h3>

<p><strong>1. UIGestureRecognizer 首先收到触摸事件，Hit-Testing 返回的 View 延迟收到，两者的调起方法不同。</strong></p>

<p><strong>2. 第一个 UIGestureRecognizer 识别成功后，UIGestureEnvironment 会发起响应链的 cancel。</strong></p>

<p><strong>3. 可以通过设置 UIGestureRecognizer 的 Properties 来控制对响应链的影响。</strong></p>

<h2 id="toc_20">UIControl 特例</h2>

<p>我们现在给 Demo 中的 View D 上加一个 UIButton：</p>

<p><img src="media/15654059537017/15654064977862.jpg" alt=""/></p>

<pre><code class="language-text">- (void)buttonTapped
{
    NSLog(@&quot;D_buttonTapped&quot;);
}

- (instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;D_view_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];

        FButton *button = [[FButton alloc] initWithFrame:CGRectMake(80, 10, 100, 40)];
        button.backgroundColor = [UIColor blueColor];
        [button addTarget:self action:@selector(buttonTapped) forControlEvents:UIControlEventTouchUpInside];
        [self addSubview:button];
    }

    return self;
}
复制代码
</code></pre>

<p>点击 Button，log 显示如下：</p>

<pre><code class="language-text">D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
D_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesEndedWithState: 5
A_view_tapGestureRecognizer_touchesEndedWithState: 5
D_view_tapGestureRecognizer_touchesEndedWithState: 5
D_buttonTapped
复制代码
</code></pre>

<p>这与我们想象的完全不同：</p>

<ol>
<li>UIGestureRecognizer 没有响应触摸事件且除了 <code>shouldReceiveTouch</code> 之外的回调没有被调用。</li>
<li>触摸事件没有沿着响应链进行传递。</li>
<li>UIButton 成功的响应了触摸事件。</li>
</ol>

<p>这又是什么原因导致的呢？</p>

<h3 id="toc_21">官方文档</h3>

<p>惯例，先看官方文档：</p>

<blockquote>
<p>Interacting with Other User Interface Controls</p>

<p>In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes:</p>

<ul>
<li><p>A single finger single tap on a UIButton, UISwitch, UIStepper, UISegmentedControl, and UIPageControl.</p></li>
<li><p>A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.</p></li>
<li><p>A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch.</p></li>
</ul>

<p>If you have a custom subclass of one of these controls and you want to change the default action, attach a gesture recognizer directly to the control instead of to the parent view. Then, the gesture recognizer receives the touch event first. As always, be sure to read the iOS Human Interface Guidelines to ensure that your app offers an intuitive user experience, especially when overriding the default behavior of a standard control.</p>
</blockquote>

<p>这次文档解释清楚了所有的原因：对于 <strong>部分 UIControl</strong> 来说（自己实现的不行），为了防止 UIControl 默认的手势与其父 View 上的 UIGestureRecognizer 的冲突，UIControl 最后会响应触摸事件，如果想要 UIGestureRecognizer 处理触摸事件，则需要将其直接与 UIControl 进行绑定。</p>

<p>原因清楚了，但是我们还是回到 Demo 之中来看看系统具体是怎么做的。</p>

<h3 id="toc_22">Demo 验证</h3>

<p>我们去掉 View A C D 中的 log，实现一个 UIButton 的子类 FButton，对 FButton 添加一个 ZTTapGestureRecognizer，并且实现方法 <code>gestureRecognizerShouldBegin：</code>：</p>

<pre><code class="language-text">@implementation FButton

- (void)singleTapGesture
{
    NSLog(@&quot;F_singleTapGesture&quot;);
}

- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
    if ([super gestureRecognizerShouldBegin:gestureRecognizer])
    {
        NSLog(@&quot;F_Button--- gestureRecognizerShouldBegin: %@ YES ---&quot;, gestureRecognizer.name);
    }
    else
    {
        NSLog(@&quot;F_Button--- gestureRecognizerShouldBegin: %@ NO ---&quot;, gestureRecognizer.name);
    }

    return [super gestureRecognizerShouldBegin:gestureRecognizer];
}

- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;F_Button_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];
    }

    return self;
}

@end
复制代码
</code></pre>

<p>运行 Demo，点击 Button，log 如下所示：</p>

<pre><code class="language-text">D_view_tapGestureRecognizer_touchesBegan
F_Button_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan

F_Button--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer NO ---
D_view_tapGestureRecognizer_touchesEndedWithState: 5
F_Button--- gestureRecognizerShouldBegin: F_Button_tapGestureRecognizer YES ---
F_Button_tapGestureRecognizer_touchesEndedWithState: 3
F_Button--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer NO ---
C_view_tapGestureRecognizer_touchesEndedWithState: 5
F_Button--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer NO ---
A_view_tapGestureRecognizer_touchesEndedWithState: 5

F_singleTapGesture
复制代码
</code></pre>

<p>可以看到 View A C D 和 Button F 上的 ZTTapGestureRecognizer 都收到了 <code>touchesBegan</code> 方法，但是最后只有 F_Button_tapGestureRecognizer 最终成功进行了状态转换，其原因就在于方法 <code>gestureRecognizerShouldBegin:</code>。</p>

<p>还记得前两节我们对于 <code>gestureRecognizerShouldBegin:</code> 的探讨吗，我们终于能够进一步对其进行解释了，这个机会还是留给官方文档：</p>

<blockquote>
<p>Subclasses may override this method and use it to prevent the recognition of particular gestures. For example, the UISlider class uses this method to prevent swipes parallel to the slider’s travel direction and that start in the thumb.</p>

<p>At the time this method is called, the gesture recognizer is in the UIGestureRecognizerStatePossible state and thinks it has the events needed to move to the UIGestureRecognizerStateBegan state.</p>

<p>The default implementation of this method returns YES.</p>
</blockquote>

<p>所以，上文提到的部分 UIControl 重写了该方法，虽然 UIGestureRecognizer 会首先受到触摸事件，但是在状态转换之前，调用了 Hit-Testing 返回的 View 也就是 UIControl 的 <code>gestureRecognizerShouldBegin:</code> 方法，UIControl 会使父 View 上的 UIGestureRecognizer 失效，而自己的 UIGestureRecognizer 却不会失效，这就是系统实现这个机制的方法。</p>

<p>还有一个问题，为什么触摸没有沿着响应链进行传递呢？惯例，先看文档：</p>

<blockquote>
<p>Controls communicate directly with their associated target object using action messages. When the user interacts with a control, the control sends an action message to its target object. Action messages are not events, but they may still take advantage of the responder chain. When the target object of a control is nil, UIKit starts from the target object and traverses the responder chain until it finds an object that implements the appropriate action method. For example, the UIKit editing menu uses this behavior to search for responder objects that implement methods with names like cut:, copy:, or paste:.</p>
</blockquote>

<p>然后我们看下 FButton 的响应方法的调用栈（去掉 FButton 上的 UIGestureRecognizer）：</p>

<p><img src="media/15654059537017/15654065324630.jpg" alt=""/></p>

<p>这里文档没有说全，实际上，FButton 重写了 <code>touchesBegan:withEvent:</code> 方法，在收到触摸事件后将其截断不再沿响应链进行传递；在响应触摸事件时，FButton 使用 Target-Action 机制通过 <code>sendAction:to:forEvent:</code> 方法通知 UIApplication，UIApplication 在通过 <code>sendAction:to:from:forEvent:</code> 方法向 target 发送 action，而当 target 为 nil 时就会沿着响应链进行寻找，知道找到了实现了相应方法的对象。</p>

<h3 id="toc_23">小结</h3>

<p><strong>1. UIGestureRecognizer 仍然会先于 UIControl 接收到触摸事件。</strong></p>

<p><strong>2. UIButton 等部分 UIControl 会拦截其父 View 上的 UIGestureRecognizer，但不会拦截自己和子 View 上的 UIGestureRecognizer。</strong></p>

<p><strong>3. UIButton 会截断响应链的事件传递，也可以利用响应链来寻找 Action Method。</strong></p>

<h2 id="toc_24">UITableView 与 UIScrollView</h2>

<p>当场景中存在 UITableView 和 UIScrollView 时，又会有不一样的情况，感兴趣的读者可以试着自己研究一下。</p>

<h2 id="toc_25">问题解决</h2>

<p>现在，我们回过头看看最初的问题，解决起来应该就比较简单了。</p>

<p>首先在我们对外的 View 上添加一个 UITapGestureRecognizer，通过回调使其能与内部的 UIGestureRecognizer 同时处理触摸事件，并且与内部双击手势不会冲突：</p>

<pre><code class="language-text">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    if (gestureRecognizer == self.tapGestureRecognizer)
    {
        return YES;
    }

    return NO;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    if (gestureRecognizer == self.tapGestureRecognizer &amp;&amp; [otherGestureRecognizer isKindOfClass:[UITapGestureRecognizer class]] &amp;&amp; ((UITapGestureRecognizer *)otherGestureRecognizer).numberOfTapsRequired == 2)
    {
        return YES;
    }

    return NO;
}
复制代码
</code></pre>

<p>由于单击手势要在双击手势判断失败后才能触发，所以会有一定的延迟，这里最好的办法是在内部自定义一个 UIGestureRecognizer 来实现双击手势以缩短等待时间：</p>

<pre><code class="language-text">#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;

#define UISHORT_TAP_MAX_DELAY 0.2
@interface UIShortTapGestureRecognizer : UITapGestureRecognizer

@end

@implementation UIShortTapGestureRecognizer

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    [super touchesBegan:touches withEvent:event];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(UISHORT_TAP_MAX_DELAY * NSEC_PER_SEC)), dispatch_get_main_queue(), ^
    {
        // Enough time has passed and the gesture was not recognized -&gt; It has failed.
        if  (self.state != UIGestureRecognizerStateRecognized)
        {
            self.state = UIGestureRecognizerStateFailed;
        }
    });
}
@end
复制代码
</code></pre>

<p>我们可以通过修改 <code>UISHORT_TAP_MAX_DELAY</code> 参数来控制等待的时间。</p>

<h2 id="toc_26">总结</h2>

<p><strong>1. 触摸事件发生后，IOKit 会通过 mach port 传递给 SpringBoad 进程，并最终传递给了 UIApplication。</strong></p>

<p><strong>2. UIApplication 通过 Hit-Testing 寻找到了最佳响应者，遍历得到所有的 UIGestureRecognizer，然后根据最佳响应者、UIGestureRecognizer、Window 创建 UITouch 并将其保存在 UIEvent 中。</strong></p>

<p><strong>3. UIApplication 将 UIEvent 发送给 UIWindow，UIWindow 首先发送事件给 UIGestureRecognizer，然后发送给最佳响应者，事件沿响应链传递。</strong></p>

<p><strong>4. UIGestureRecognizer 根据 Delegate 以及最佳响应者来判断是否能够成功进行状态转换并取消响应链的触摸事件。</strong></p>

<p><strong>5. 系统实现的部分 UIControl 会截断响应链，并使父 View 上的 UIGestureRecognizer 失效。</strong></p>

<h2 id="toc_27">参考资料</h2>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FBladeTail%2FEvent-Handling-Guide-for-iOS%2Fblob%2Fmaster%2FEvent%2520Handling%2520Guide%2520for%2520iOS.pdf">Event Handling Guide for iOS</a></p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd8512dff2b3e">iOS 事件响应链中 Hit-Test View 的应用</a></p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fc294d1bd963d">iOS 触摸事件全家桶</a></p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F53e03e558cbd">iOS 点击事件和手势冲突</a></p>

<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fzhoon.github.io%2Fios%2F2015%2F04%2F12%2Fios-event.html">深入浅出iOS事件机制</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图像显示原理]]></title>
    <link href="http://www.citynight.cn/Blog/15653483390225.html"/>
    <updated>2019-08-09T18:58:59+08:00</updated>
    <id>http://www.citynight.cn/Blog/15653483390225.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15653483390225/WX20190809-201518@2x.png" alt="WX20190809-201518@2x"/></p>

<p><img src="media/15653483390225/15656069984426.jpg" alt="" style="width:979px;"/><br/>
<img src="media/15653483390225/15656070181148.jpg" alt="" style="width:677px;"/></p>

<p><img src="media/15653483390225/15666279613682.jpg" alt="" style="width:755px;"/></p>

<p>系统绘制流程<br/>
<img src="media/15653483390225/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-4-.jpg" alt="未命名文件 -4-"/></p>

<p>异步绘制流程(时序图)<br/>
<img src="media/15653483390225/Jietu20190824-150035.jpg" alt="Jietu20190824-150035"/></p>

]]></content>
  </entry>
  
</feed>
