
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  李小争
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="记录开发中遇到的一些问题">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="李小争" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">李小争</a></h1>
  
    <h2>记录开发中遇到的一些问题</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.citynight.cn/Blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14727863232294.html">runtime(内部分享草稿)</a></h1>
			<p class="meta"><time datetime="2016-09-02T11:18:43+08:00" 
			pubdate data-updated="true">2016/9/2</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>本文涉及到的Demo地址 <a href="https://github.com/Mekor/runtimeDemo">https://github.com/Mekor/runtimeDemo</a></p>
</blockquote>

<h2 id="toc_0">理解self,super,class,superclass</h2>

<p>创建一个Person里面有一个类方法:</p>

<pre><code class="language-objectivec">#import &quot;Person.h&quot;

@implementation Person
+(void)study {
    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
}
@end
</code></pre>

<p>Student继承自Person,重写父类方法</p>

<pre><code class="language-objectivec">#import &quot;Student.h&quot;

@implementation Student
+(void)study {
    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
}
@end
</code></pre>

<!--more-->

<p>这两个输出的都是什么?<br/>
<img src="media/14727863232294/14729913552743.jpg" alt=""/></p>

<p>这时,我们在Student中用这样写:</p>

<pre><code class="language-objectivec">#import &quot;Student.h&quot;

@implementation Student
+(void)study {
//    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
    
    [super study];
}
@end
</code></pre>

<p>打断点我们可以看到:<br/>
<img src="media/14727863232294/14729934417192.jpg" alt=""/></p>

<p>可以看出:</p>

<pre><code class="language-objectivec">super：是编译器指示符，仅仅是一个标志,并不是指针，仅仅是标志的当前对象去调用父类的方法，本质还是当前对象调用
super:并不是让父类对象调用方法，调用者还是本身
class：获取方法调用者的类
superclass:获取方法调用者的父类
</code></pre>

<p>消息机制:(来自:<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">官方文档</a>)<br/>
<img src="media/14727863232294/messaging1.gif" alt="消息框架"/></p>

<p>当对象收到消息时,消息函数首先根据该对象的 isa 指针找到该对象所对应的类的方法表,并从表中寻找 该消息对应的方法选标。如果找不到,objc_msgSend 将继续从父类中寻找,直到 NSObject 类。一旦找到了方法选标, objc_msgSend 则以消息接收者对象为参数调用,调用该选标对应的方法实现。</p>

<h2 id="toc_1">self是从哪里来的?</h2>

<blockquote>
<p>官方解释:<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">Objective-C Runtime Programming Guide</a><img src="media/14727863232294/14729941396965.jpg" alt=""/></p>
</blockquote>

<p>简单说每个方法都存在并且隐藏的两个参数(self,_cmd),随便写个方法看下:<br/>
Student中写个text方法,然后打印下这两个隐藏参数.<br/>
<img src="media/14727863232294/14729960900273.jpg" alt=""/><br/>
<img src="media/14727863232294/14729961142923.jpg" alt=""/></p>

<h2 id="toc_2">动态添加方法</h2>

<p>上面说了一些貌似和runtime没有什么关系,runtime基础知识类似类的构成,对象的构成这里不再介绍,可以自己去看定义.当然也可以去<a href="http://opensource.apple.com/source/objc4/objc4-680/runtime/">苹果的开源网站</a>查看,如果网站不方便可以去苹果的<a href="https://github.com/opensource-apple/objc4">github</a>下载开源代码研究...  ...继续...那么根据上面所说的方法说下动态添加方法.</p>

<blockquote>
<p>思考一下,咱们new项目中将采用路由模式进行页面跳转,从网页跳转进入app调用一个方法,一般情况下都是移动端和后台协议好的内容,这样跳转不会出现问题.但是如果后台写错了或者传输中出现问题导致url中包含的方法名不是规定的方法名.这时怎么办?</p>
</blockquote>

<pre><code class="language-objectivec">    Student *s = [Student new];
    
    // 1. 比如我们要调用 Student中的eat方法, 默认这样写[s eat]; 但是不行,因为我们没有定义.
//    [s eat];
    // 2. 也可以这样调用[s performSelector:@selector(eat)];这样没有问题,@selector中参数是字符串,这个参考swift
//    [s performSelector:@selector(eat)];
    // 3. 使用string创建SEL
    
#pragma clang diagnostic push
#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;
    [s performSelector:NSSelectorFromString(@&quot;eat&quot;)];
#pragma clang diagnostic pop
    
    // 上面这样调用会报错,我们在对象调用未实现方法的时候动态的创建一个方法,避免抛出异常.
</code></pre>

<p>怎么忽略编译器警告已经分享过,可以参考:<a href="http://www.citynight.cn/Blog/14676105703423.html">http://www.citynight.cn/Blog/14676105703423.html</a></p>

<h3 id="toc_3">怎么动态添加方法呢?</h3>

<p><img src="media/14727863232294/14729983827897.jpg" alt=""/><br/>
上面是动态添加对象方法的例子,动态添加类方法也是一样的<code>+(BOOL)resolveClassMethod:(SEL)sel</code><br/>
<strong>注意:</strong>上面函数类型,有人可能好奇这块为什么写成&quot;v@:&quot;  ?参见:函数类型, 更多关于转发机制参见:<a href="http://www.citynight.cn/Blog/14733118707964.html">转发机制</a></p>

<h3 id="toc_4">关于函数类型</h3>

<p>先看文档:<br/>
<img src="media/14727863232294/14730056768742.jpg" alt=""/><br/>
查看<code>Objective-C type encodings</code> <img src="media/14727863232294/14730058881001.jpg" alt=""/><br/>
所以上面void eat(...)应该表述成 <code>&quot;v@:&quot;</code></p>

<p><strong>补充:</strong> 动态调用方法系统默认提供一到两个参数的方法调用, <del>这里封装了一个无限参数的方法调用.<a href="https://github.com/Mekor/NSObject-SEL">NSObject-SEL****</a></del>  我把一些扩展进行了总结,还不完善,地址<a href="https://github.com/Mekor/MKExtension">MKExtension</a></p>

<h3 id="toc_5">关于IMP(函数指针)</h3>

<pre><code class="language-objectivec">/// A pointer to the function of a method implementation. 
#if !OBJC_OLD_DISPATCH_PROTOTYPES
typedef void (*IMP)(void /* id, SEL, ... */ ); 
#else
typedef id (*IMP)(id, SEL, ...); 
#endif
</code></pre>

<p>当前版本Xcode如果使用IMP的话,默认是选择第一个也就是无参无返回值.如果需要参数有返回值的话,需要修改配置文件.如下:</p>

<h2 id="toc_6">方法交换(Method Swizzling:传说中的黑魔法)</h2>

<p>一般使用方法交换都是想给系统提供的方法添加一些其他的功能的时候使用.new中使用方法交换的例子:</p>

<pre><code class="language-objectivec">#import &quot;UIActionSheet+Front.h&quot;

#import &lt;objc/runtime.h&gt;

@implementation UIActionSheet (Front)
- (void)customShowInView:(UIView *)view{
    for(UIWindow * tmpWin in [[UIApplication sharedApplication] windows]){
        [tmpWin endEditing:NO];
    }
    [self customShowInView:view];
}
+ (void)load{
    swizzleAllActionSheet();
}
@end

void swizzleAllActionSheet(){
    Class c = [UIActionSheet class];
    SEL origSEL = @selector(showInView:);
    SEL newSEL = @selector(customShowInView:);
    Method origMethod = class_getInstanceMethod(c, origSEL);
    Method newMethod = class_getInstanceMethod(c, newSEL);
    method_exchangeImplementations(origMethod, newMethod);
}
</code></pre>

<p>关于方法交换,在new项目中已经封装好了,代码如下:</p>

<pre><code class="language-objectivec">// ObjcRuntime.h文件
void Swizzle(Class c, SEL origSEL, SEL newSEL);

//ObjcRuntime.m文件
//静态就交换静态，实例方法就交换实例方法
void Swizzle(Class c, SEL origSEL, SEL newSEL)
{
    Method origMethod = class_getInstanceMethod(c, origSEL);
    Method newMethod = nil;
    if (!origMethod) {
        origMethod = class_getClassMethod(c, origSEL);
        if (!origMethod) {
            return;
        }
        newMethod = class_getClassMethod(c, newSEL);
        if (!newMethod) {
            return;
        }
    }else{
        newMethod = class_getInstanceMethod(c, newSEL);
        if (!newMethod) {
            return;
        }
    }
    
    //自身已经有了就添加不成功，直接交换即可
    if(class_addMethod(c, origSEL, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))){
        class_replaceMethod(c, newSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
    }else{
        method_exchangeImplementations(origMethod, newMethod);
    }
}
</code></pre>

<p>用法(还是以Student为例):<br/>
Student中添加两个对象方法,一个run,一个sleep.我们的目的是交换两个方法的实现</p>

<pre><code class="language-objectivec">-(void)run {
    NSLog(@&quot;跑🏃&quot;);
}
-(void)sleep {
    NSLog(@&quot;睡觉😴&quot;);
}
+(void)load {
    Swizzle(self, @selector(run), @selector(sleep));
}
</code></pre>

<p>控制器调用的结果:<br/>
<img src="media/14727863232294/14730042652865.jpg" alt=""/></p>

<h2 id="toc_7">添加属性</h2>

<p>动态添加属性用的最多的地方应该是给分类添加属性.  <del>我在项目中添加过一个分类<code>UIView+Tap</code>这个也可以在这里查看<a href="https://github.com/Mekor/UIView-Tap">UIView-Tap</a></del>  我把一些扩展进行了总结,还不完善,地址<a href="https://github.com/Mekor/MKExtension">MKExtension</a></p>

<pre><code class="language-objectivec">#import &quot;UIView+Tap.h&quot;
#import &lt;objc/runtime.h&gt;

static const void* tagValue = &amp;tagValue;

@interface UIView ()
@property (nonatomic, copy) void(^tapAction)(id);
@end

@implementation UIView (Tap)
- (void)tap{
    if (self.tapAction) {
        self.tapAction(self);
    }
}
- (void)addTapBlock:(void(^)(id obj))tapAction{
    self.tapAction = tapAction;
    if (![self gestureRecognizers]) {
        self.userInteractionEnabled = YES;
        UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];
        [self addGestureRecognizer:tap];
    }
}

-(void)setTapAction:(void (^)(id))tapAction {
    objc_setAssociatedObject(self, tagValue, tapAction, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
-(void (^)(id))tapAction {
    return objc_getAssociatedObject(self, tagValue);
}
@end
</code></pre>

<p>主要是set&amp;get方法,这点注意了也就没啥了..</p>

<h2 id="toc_8">其他</h2>

<ol>
<li>系统中常见的使用到runtime的地方:
<a href="http://www.citynight.cn/Blog/14726525723684.html">KVO内部实现原理</a></li>
<li>日常开发中使用到runtime的地方:</li>
<li>字典转模型: 可以参看<code>MJExtension</code> 它的核心代码在:<code>NSObject+MJProperty.m</code>第150行开始</li>
</ol>

<pre><code class="language-objectivec">#pragma mark - 公共方法
+ (NSMutableArray *)properties
{
    NSMutableArray *cachedProperties = [self dictForKey:&amp;MJCachedPropertiesKey][NSStringFromClass(self)];
    
    if (cachedProperties == nil) {
        cachedProperties = [NSMutableArray array];
        
        [self mj_enumerateClasses:^(__unsafe_unretained Class c, BOOL *stop) {
            // 1.获得所有的成员变量
            unsigned int outCount = 0;
            objc_property_t *properties = class_copyPropertyList(c, &amp;outCount);
            
            // 2.遍历每一个成员变量
            for (unsigned int i = 0; i&lt;outCount; i++) {
                MJProperty *property = [MJProperty cachedPropertyWithProperty:properties[i]];
                // 过滤掉Foundation框架类里面的属性
                if ([MJFoundation isClassFromFoundation:property.srcClass]) continue;
                property.srcClass = c;
                [property setOriginKey:[self propertyKey:property.name] forClass:self];
                [property setObjectClassInArray:[self propertyObjectClassInArray:property.name] forClass:self];
                [cachedProperties addObject:property];
            }
            
            // 3.释放内存
            free(properties);
        }];
        
        [self dictForKey:&amp;MJCachedPropertiesKey][NSStringFromClass(self)] = cachedProperties;
    }
    
    return cachedProperties;
}
</code></pre>

<p>自定义字典转模型中log的输出可以参见Xcode插件<code>ESJsonFormat</code>中<code>ESJsonFormatManager.m</code>第47行:</p>

<pre><code class="language-objectivec">/**
 *  格式化OC属性字符串
 *
 *  @param key       JSON里面key字段
 *  @param value     JSON里面key对应的NSDiction或者NSArray
 *  @param classInfo 类信息
 *
 *  @return
 */
+ (NSString *)formatObjcWithKey:(NSString *)key value:(NSObject *)value classInfo:(ESClassInfo *)classInfo{
    NSString *qualifierStr = @&quot;copy&quot;;
    NSString *typeStr = @&quot;NSString&quot;;
    //判断大小写
    if ([ESUppercaseKeyWords containsObject:key] &amp;&amp; [ESJsonFormatSetting defaultSetting].uppercaseKeyWordForId) {
        key = [key uppercaseString];
    }
    if ([value isKindOfClass:[NSString class]]) {
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[@(YES) class]]){
        //the &#39;NSCFBoolean&#39; is private subclass of &#39;NSNumber&#39;
        qualifierStr = @&quot;assign&quot;;
        typeStr = @&quot;BOOL&quot;;
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ %@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[NSNumber class]]){
        qualifierStr = @&quot;assign&quot;;
        NSString *valueStr = [NSString stringWithFormat:@&quot;%@&quot;,value];
        if ([valueStr rangeOfString:@&quot;.&quot;].location!=NSNotFound){
            typeStr = @&quot;CGFloat&quot;;
        }else{
            NSNumber *valueNumber = (NSNumber *)value;
            if ([valueNumber longValue]&lt;2147483648) {
                typeStr = @&quot;NSInteger&quot;;
            }else{
                typeStr = @&quot;long long&quot;;
            }
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ %@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[NSArray class]]){
        NSArray *array = (NSArray *)value;
        
        //May be &#39;NSString&#39;，will crash
        NSString *genericTypeStr = @&quot;&quot;;
        NSObject *firstObj = [array firstObject];
        if ([firstObj isKindOfClass:[NSDictionary class]]) {
            ESClassInfo *childInfo = classInfo.propertyArrayDic[key];
            genericTypeStr = [NSString stringWithFormat:@&quot;&lt;%@ *&gt;&quot;,childInfo.className];
        }else if ([firstObj isKindOfClass:[NSString class]]){
            genericTypeStr = @&quot;&lt;NSString *&gt;&quot;;
        }else if ([firstObj isKindOfClass:[NSNumber class]]){
            genericTypeStr = @&quot;&lt;NSNumber *&gt;&quot;;
        }
        
        qualifierStr = @&quot;strong&quot;;
        typeStr = @&quot;NSArray&quot;;
        if ([ESJsonFormatSetting defaultSetting].useGeneric &amp;&amp; [ESUtils isXcode7AndLater]) {
            return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@%@ *%@;&quot;,qualifierStr,typeStr,genericTypeStr,key];
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }else if ([value isKindOfClass:[NSDictionary class]]){
        qualifierStr = @&quot;strong&quot;;
        ESClassInfo *childInfo = classInfo.propertyClassDic[key];
        typeStr = childInfo.className;
        if (!typeStr) {
            typeStr = [key capitalizedString];
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }
    return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
}

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14727432716172.html">基础拾遗</a></h1>
			<p class="meta"><time datetime="2016-09-01T23:21:11+08:00" 
			pubdate data-updated="true">2016/9/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/14727432716172/14727432899236.jpg" alt=""/></p>

<h2 id="toc_0">self和super区别</h2>

<p>要点：</p>

<ol>
<li>self调用自己方法，super调用父类方法</li>
<li>self是类，super是预编译指令</li>
<li>【self class】和【super class】输出是一样的</li>
</ol>

<p>self和super底层实现原理：</p>

<ol>
<li>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法。</li>
<li>当使用 self 调用时，会使用 <code>objc_msgSend</code> 函数：<code>id objc_msgSend(id theReceiver, SEL theSelector, ...)</code>。第 一个参数是消息接收者，第二个参数是调用的具体类方法的 <code>selector</code>，后面是 <code>selector</code> 方法的可变参数。以 <code>[self setName:]</code> 为例，编译器会替换成调用 <code>objc_msgSend</code> 的函数调用，其中 <code>theReceiver</code> 是 <code>self</code>，<code>theSelector</code> 是 <code>@selector(setName:)</code>，这个 <code>selector</code> 是从当前 <code>self</code> 的 <code>class</code> 的方法列表开始找的 <code>setName</code>，当找到后把对应的 <code>selector</code> 传递过去。</li>
<li>当使用 <code>super</code> 调用时，会使用 <code>objc_msgSendSuper</code> 函数：<code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</code>第一个参数是个<code>objc_super</code>的结构体，第二个参数还是类似上面的类方法的<code>selector</code>，</li>
</ol>

<pre><code class="language-text">struct objc_super {
      id receiver;
      Class superClass;
};
</code></pre>

<p>当编译器遇到  <code>[super setName:]</code> 时，开始做这几个事：</p>

<p>1）构建 <code>objc_super</code> 的结构体，此时这个结构体的第一个成员变量 <code>receiver</code> 就是子类，和 <code>self</code> 相同。而第二个成员变量 <code>superClass</code> 就是指父类<br/>
调用 <code>objc_msgSendSuper</code> 的方法，将这个结构体和 <code>setName</code> 的 <code>sel</code> 传递过去。</p>

<p>2）函数里面在做的事情类似这样：从 <code>objc_super</code> 结构体指向的 <code>superClass</code> 的方法列表开始找 <code>setName</code> 的 <code>selector</code>，找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 <code>selector</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14726525723684.html">KVO内部实现原理</a></h1>
			<p class="meta"><time datetime="2016-08-31T22:09:32+08:00" 
			pubdate data-updated="true">2016/8/31</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>KVO是基于runtime机制实现的</li>
<li>当某个类的对象第一次被观察时,系统就会在运行期动态地创建该类的一个派生类,在这个派生类中重写基类中任何被观察属性的setter方法.派生类在被重写的setter方法实现真正的通知机制.</li>
</ol>

<p>添加监听前:<br/>
<img src="media/14726525723684/14726530320712.jpg" alt=""/></p>

<p>添加监听后:(派生出:NSKVONotifying_Person)<br/>
<img src="media/14726525723684/14726532061641.jpg" alt=""/></p>

<p>把前后两份代码全部转换成cpp文件,这时我们查找两个文件不同的地方.</p>

<p><img src="media/14726525723684/14726564797185.jpg" alt=""/></p>

<p>经过简单整理的两份代码:<br/>
<img src="media/14726525723684/14726568603743.jpg" alt=""/></p>

<p>可以看出mi_0 &amp; mi_1之间就是Person &amp; NSKVONotifying_Person之间的关系.</p>

<p>-------------------2018.1.20更新(读&lt;编写高质量代码&gt;)--------------------<br/>
KVC 通过实现名为NSKeyValueCoding的非正式协议,使开发者可以通过键直接设置和获取对象属性,而不需要调用对象的存取方法(Cocoa为该协议提供了默认的实现).键通常和被访问对象中的实例变量或存取方法的名称相对应.</p>

<p>KVC主要利用一种使用字符串标识符,简介访问属性的机制,他是很多技术的基础.主要有<code>setValue: forKey</code>,<code>valueForKey</code>和<code>setValue: forKeyPath</code>,<code>valueForKeyPath</code></p>

<p>key 与keyPath 基本一样,只是keyPath的值是一个路径,路径之间用<code>.</code>分割,比如数据成员就是对象自己,寻值过程就会向下深入下去.<img src="media/14726525723684/WechatIMG26.png" alt="WechatIMG26"/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14726092302553.html">转载iOS MJ讲解面试题,并修改里面错误</a></h1>
			<p class="meta"><time datetime="2016-08-31T10:07:10+08:00" 
			pubdate data-updated="true">2016/8/31</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>原文链接:<a href="http://www.jianshu.com/p/9050e523e278">http://www.jianshu.com/p/9050e523e278</a></p>
</blockquote>

<h4 id="toc_0">1、KVO内部实现原理</h4>

<ul>
<li>1.KVO是基于runtime机制实现的</li>
<li>2.当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法。<br/>
派生类在被重写的setter方法实现真正的通知机制（Person-&gt;NSKVONotifying_Person）</li>
</ul>

<h4 id="toc_1">2、是否可以把比较耗时的操作放在NSNotificationCenter中</h4>

<ul>
<li>通知中心所做的操作在主线程，比较耗时的一般开启一个线程单独去跑</li>
</ul>

<h4 id="toc_2">3、KVO、NSNotification、代理的区别和用法是什么？什么时候该用那个？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果能，会有什么潜在的问题？如果不能，为什么？</h4>

<h5 id="toc_3">答案：</h5>

<p>参考：<a href="http://blog.csdn.net/dqjyong/article/details/7685933">http://blog.csdn.net/dqjyong/article/details/7685933</a></p>

<h6 id="toc_4">通知（NSNotification）：</h6>

<ul>
<li>比较灵活（1个通知能被多个对象接受，多个对象能接受多个通知）</li>
<li>没有耦合性（Ａ发出的通知，谁去接收并不知道）</li>
<li>缺点通知的Key容易被写错</li>
</ul>

<h6 id="toc_5">KVO</h6>

<ul>
<li>性能不好（底层对会Runtime动态产成新的类NSNotifying_xx）</li>
<li>局限性（只能监听某个对象属性的改变，不推荐实用）</li>
<li>1个对象的属性能被多个对象监听，1个对象能监听多个对象的其他属性</li>
</ul>

<h6 id="toc_6">代理</h6>

<ul>
<li>比较规范，所以安全性高</li>
<li>默认是1对1监听，可以用代理数组 a.delegates = @[b, c, d];(千万别这样写，违背的设计模式，这样写还不如同消息通知)</li>
</ul>

<h4 id="toc_7">4、Runtime实现的机制是什么，怎么用，一般用于干嘛，你还记得你所使用的相关的头文件或者某些方法的名称吗？</h4>

<p>运行时机制，runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量，动态改变类的方法实现，为类动态添加新的方法等，需要导入</p>

<h5 id="toc_8">1.什么是Runtime</h5>

<ul>
<li>runtime是一套比较低层的纯C语言API，属于1个C语言库，包含许多C底层的C语言的API</li>
<li>平时编写的OC代码，在程序 运行过程中，其实最终都转换成了runtime的C语言代码，runtime算是OC的幕后工作者<br/>
举例：<br/>
OC:
<code>[MJPerson alloc]init];</code>
runtime：
<code>objc_msgSend(objc_msgSend(&quot;MJPerson&quot;, &quot;alloc&quot;), &quot;init&quot;)</code></li>
</ul>

<h5 id="toc_9">2.用过么？怎么用？</h5>

<ul>
<li>1.runtime是属于OC底层，可以进行 一些非常的操作（OC无法实现的，不容易实现的）
<ul>
<li>在程序运行过程中，动态创建一个类（比如KVO底层实现）</li>
<li>在程序运行过程中，动态地为某个类 添加属性、方法，修改属性值、方法</li>
<li>便利一个类的 所以成员变量（属性）、方法</li>
</ul></li>
</ul>

<h5 id="toc_10">3.相关应用</h5>

<ul>
<li><p>1.头文件</p>
<p>调用底层的消息发送方法</p></li>
<li><p>2.相关应用</p>
<ul>
<li>NSCoding（归档和解档，利用runtime遍历模型对象的所有属性）</li>
<li>字典 -&gt;模型 （利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上）</li>
<li>KVO（利用runtime动态产生一个类）</li>
<li>用于封装框架（想怎么改，就怎么改）</li>
</ul></li>
<li><p>3.相关函数</p>
<ul>
<li>objc_msgSend ： 给对象发送消息</li>
<li>class_copyMethodList ： 遍历某个所有方法</li>
<li>class_copyIvarList ： 遍历某个类所以的成员变量</li>
<li>class_addMethod ： 动态添加方法</li>
<li>class_addIval ：动态添加成员变量</li>
<li>class_.... class_开头的方法,是操作类的</li>
</ul></li>
</ul>

<h6 id="toc_11">例：利用Runtime归档和解档</h6>

<pre><code class="language-text">//  MJPerson.m
//  runtime进行归档和解档
//
//  Created by Zhanbo on 16/7/7.
//  Copyright © 2016年 Zhanbo. All rights reserved.
//

#import &quot;MJPerson.h&quot;
#import &lt;objc/runtime.h&gt;
@implementation MJPerson

- (void)encodeWithCoder:(NSCoder *)aCoder {

   unsigned int count = 0;
  //参数1：那个类
  //参数2：有几个成员变量
   Ivar *ivars = class_copyIvarList([MJPerson class], &amp;count);

    for (int i = 0; i &lt;count; i++) {
        //取出i位置对应的成员变量
        Ivar ivar = ivars[i];

        //查看成员变量
        const char *name = ivar_getName(ivar);
        NSLog(@&quot;%s&quot;, name);

        //归档
        NSString *key = [NSString stringWithUTF8String:name];
        id value = [self valueForKey:key];
        [aCoder encodeObject:value forKey:key];

    }
    //在C语言中使用copy要释放
    free(ivars);
}

- (instancetype)initWithCoder:(NSCoder *)aDecoder {

    if (self = [super init]) {

        unsigned int count = 0;
        Ivar *ivars = class_copyIvarList([MJPerson class], &amp;count);

        for (int i = 0; i &lt;count; i++) {
            //取出i位置对应的成员变量
            Ivar ivar = ivars[i];

            //查看成员变量
            const char *name = ivar_getName(ivar);
            NSLog(@&quot;%s&quot;, name);

            //解档
            NSString *key = [NSString stringWithUTF8String:name];
            id value = [aDecoder decodeObjectForKey:key];

            //设置到成员变量身上
            [self setValue:value forKey:key];

        }
        //在C语言中使用copy要释放
        free(ivars);
    }
    return self;
}

@end
</code></pre>

<h5 id="toc_12">4.必备常识</h5>

<ul>
<li>1.Ivar ： 成员变量</li>
<li>1. Method ： 成员方法</li>
</ul>

<h4 id="toc_13">5、Foundation对象与Core Foundation对象有什么区别？</h4>

<ul>
<li>1.Foundation对象是OC的，Core Foundation对象是C对象</li>
<li><p>2.数据类型之间的转换(桥接)</p>
<ul>
<li><p>ARC：bridge_retained、 _bridge_transfer</p>
<pre><code class="language-text">CFArrayRef array3 = CFArrayCreate(NULL, NULL, 10, NULL);
//Foundetion -&gt; Core Fountdation<br/>
(__bridge_retained )<br/>
//Core Fountdation -&gt; Foundetion<br/>
(__bridge_transfer )<br/>
NSArray *array4 = (__bridge_transfer NSArray *)array3);
</code></pre></li>
<li><p>MRC: _bridge</p>
<pre><code class="language-text">Foundation -&gt; Core Foundation
NSArray *array1 = [NSArray array];<br/>
CFArrayRef array2 = (__bridge CFArrayRef)array1;<br/>
//记得释放内存<br/>
[array1 release];
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_14">6、不用中间变量，用两种方法交换A和B的值</h4>

<ul>
<li>1. A = A + B<br/>
    B = A - B<br/>
    A = A- B</li>
<li>2.使用位运算<sup>能交换两个变量的值</sup></li>
</ul>

<h4 id="toc_15">7、 什么是动态，举例说名</h4>

<ul>
<li>1.在线程运行过程才执行的操作，如Runtime动态创建成员变量和方法</li>
</ul>

<h4 id="toc_16">8、什么是多态</h4>

<ul>
<li><p>1.父类指针指向子类对象</p>
<pre><code class="language-text">NSObject *obj = [NSArray array];
</code></pre></li>
</ul>

<h4 id="toc_17">9、怎么解决缓存池满的问题（cell）</h4>

<ul>
<li>iOS中不存在缓存池满的情况，应为通常我们在iOS开发，对象都是在需要的时候才会创建，有种常用的说法叫懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会创建新对象，缓存池里最多就一两个对象，缓存池满的这中情况一般在开发Java中比较常见，Java中一般把最近最少使用的对象先释放</li>
<li>如果缓存池满了，判断哪个位置的cell是不经常使用的，先释放掉</li>
</ul>

<h3 id="toc_18">10、如何渲染自定义格式字符串的UILabel</h3>

<ul>
<li><p>1.通过NSAttributedString类</p>
<pre><code class="language-text">  //1种写法，也可以用字典
NSMutableAttributedString *str = [[NSMutableAttributedString alloc]initWithString:@&quot;哈哈哈啦啦啦哇哇哇&quot;];<br/>
  //设置文字颜色<br/>
  [str addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 3)];<br/>
  [str addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(6, 3)];<br/>
  //设置字体<br/>
  [str addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(3, 3)];<br/>
  _label.attributedText = str;
</code></pre></li>
</ul>

<p><img src="media/14726092302553/1240." alt=""/></p>

<p>效果</p>

<h4 id="toc_19">11、scrollView的contentSize能在ViewDidLoad里设置吗，为什么？</h4>

<ul>
<li>1.能，在哪里都能设置</li>
<li>2.但是最好不要在viewDidLoad里设置，因为视图刚创建不一定是我们想要的尺寸，在iPad开发中横竖屏是很好的例子</li>
</ul>

<h4 id="toc_20">12、控制器View的生命周期及相关函数什么？你在开发中是如何用的？</h4>

<ul>
<li>1.首先判断控制器是否有视图，如果没有就调用<strong>loadView</strong>方法创建：通过storyboard或者代码</li>
<li>2.随后调用<strong>viewDidLoad</strong>，可以进行下一步的初始化操作：只会被调用一次</li>
<li>3.在视图显示之前（即将显示）调用<strong>viewWillAppear</strong>，该函数可以多次调用</li>
<li>4.在视图显示，会调用<strong>viewDidAppear</strong></li>
<li>5.视图即将消失，调用<strong>viewWillDisappear</strong></li>
<li>6.视图已经消失，调用<strong>viewDidDisappear</strong></li>
<li>7.在布局变化前后，调用<strong>viewWillDidLayoutSubviews</strong>处理相关信息</li>
</ul>

<h4 id="toc_21">13、Block的内存管理</h4>

<ul>
<li>1.默认情况下，block的内存是在栈中
<ul>
<li>它不会对所引用的对象进行任何操作</li>
</ul></li>
<li>2.如果对block做一次copy操作，block的内存就会在堆中
<ul>
<li>它会对所引用的对象做一次retain操作</li>
<li>ARC ：如果所引用的对象用了<strong>__unsafe_unretained</strong>或者<strong>__weak</strong>修饰，就不会做retain操作</li>
<li>非ARC(MRC) ： 如果所引用的对象用<strong>__block</strong>修饰，就不会做retain操作；MRC记得释放blockBlock_release(_block);</li>
</ul></li>
</ul>

<pre><code class="language-text">- (void)dealloc {
    //MRC记得在dealloc释放blcok，[super dealloc];要写最后
    Block_release(_block);
    [super dealloc];
}
</code></pre>

<h4 id="toc_22">14、MRC中如何做开发</h4>

<p>1.MRC中retain相当于ARC中strong<br/>
assign相当于ARC中weak<br/>
2.只要声明对象属性就要写retain</p>

<pre><code class="language-text">@property (nonatomic, retain)NSArray *array; +1(计数器 = 1)
</code></pre>

<p>3.声明控件、协议用assgin</p>

<p>4.MRC的内存管理原则</p>

<ul>
<li>如果调用了alloc、new、copy产生了一个新对象，最后肯定要调用1次releace或者autorelease</li>
<li>如果让一个对象做了retain操作（计数器+1），最后肯定要调用1次release或者autorelease</li>
<li>原则：有+ 就有-</li>
</ul>

<pre><code class="language-text">self.array = [NSArray alloc]init]autorelease];
alloc后 +1(计数器 = 2)； autorelease后 -1(计数器 = 1)
//或者这样写，就不需要写autorelease，系统内部自动写好
self.array = [NSArray array];
</code></pre>

<ul>
<li>最后要在dealloc释放内存</li>
</ul>

<pre><code class="language-text">//当控制器将被释放的时候对调用
- (void)dealloc {
//最好这样写
self.array = nil;
-1(计数器 = 0)

//也可以这样写
self.array = [array release];
//最后调用
[supe dealloc];
}
</code></pre>

<p>如果是iOS版本在5.0之前要在3个地方释放内存</p>

<pre><code class="language-text">//控制器的View被卸载，会调用
- (void)viewDidUnload {

    [super viewDidUnload];
    self.array = nil;
}

//接收到内存警告，会调用
- (void)didReceiveMemoryWarning {

    [super didReceiveMemoryWarning];
    self.array = nil;
}

- (void)dealloc {

    self.array = nil;

    [super dealloc];
}
</code></pre>

<h4 id="toc_23">15、多线程如何进行线之间通讯？</h4>

<pre><code class="language-text">//在主线程执行某个方法，传参（该方法用于子线程对主线程进行通讯）
[self performSelectorOnMainThread: withObject: waitUntilDone:]

//指定线程，调用方法，传参
[self performSelector: onThread: withObject: waitUntilDone: modes: *)#&gt;

//GCD在异步线程做事情
dispatch_async(, )
</code></pre>

<h4 id="toc_24">16、用NSOperation和NSOperationQueue处理A,B,C三个线程，要求执行完A,B才能执行C，怎么做？</h4>

<ul>
<li>1.第一种方法添加依赖</li>
</ul>

<pre><code class="language-text">//创建列队
NSOperationQueue *queue = [NSOperationQueue alloc]init];
//创建3个操作
NSOperation *a = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation1....&quot;);
}];

NSOperation *c = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation2....&quot;);
}];

NSOperation *b = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation3....&quot;);
}];
//======添加依赖=======
//只有当a操作执行完毕后，才会执行c操作
[c addDependency:a];
//只有当b操作执行完毕后，才会执行c操作
[c addDependency:b];

[queue addOperation:a];
[queue addOperation:b];
[queue addOperation:c];
</code></pre>

<ul>
<li>2.第二种方法 可 以设置优先级</li>
</ul>

<pre><code class="language-text">- (NSOperationQueuePriority)queuePriority;
</code></pre>

<h4 id="toc_25">17、GCD内部怎么实现的</h4>

<ul>
<li>1.iSO和OS X的核心是XNU内核，GCD是基于XNU内核实现的</li>
<li>2.GCD的API全部在libdispatch库中</li>
<li>3.GCD的底层实现主要有Dispatch Queue和 Dispatch Source
<ul>
<li>Disatch Queue ：管理block（操作，block里的代码块，根据类型在哪个线程执行）</li>
<li>Disatch Source ： 处理事件（底层实现，处理线程之间的事件，如主线程会到什么线程，异步线程回到什么线程）</li>
</ul></li>
</ul>

<h4 id="toc_26">18、NSOperatinQueue和CGD的区别，什么情况下用NSOperationQueue，什么情况下用GCD</h4>

<ul>
<li>1.GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本封装</li>
<li>2.GCD只支持FIFO的列队（先进先出），NSOperationQueue可以很方便地调整执行顺序（设置优先级 ），设置最大并发数量</li>
<li>3.NSOperatinQueue可以轻松在Operation间设置依赖关系，而GCD需要些很多代码才能实现</li>
<li>4.NSOperationQueue支持KVO，可以监听operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）；系统内部已经做好的KVO</li>
<li>5.GCD的执行速度比NSOperationQueue快</li>
<li>什么时候，用哪个
<ul>
<li>1.任务之间有依赖/或者要监听任务的执行情况：NSOperatinQueue（任务需要时刻监听；任务严格需要按顺序执行）</li>
<li>2.任务之间不太相互依赖就用：CGD</li>
</ul></li>
</ul>

<h4 id="toc_27">19、既然说到GCD，那么问下在使用GCD已经block需要注意什么？</h4>

<ul>
<li>1.GCD的注意18题已有说明</li>
<li>2.Block的使用注意
<ul>
<li>1.block的内存管理(13题已有说明)</li>
<li>2.防止循环retain
<ul>
<li>ARC：<strong>weak/</strong>unsafe_unretained</li>
<li>MRC: __block 0</li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_28">20、如果后期需要增加数据库中的字段怎么实现，如果不使用CoreData呢？</h4>

<p>编写SQL语句来操作原来表中的字段</p>

<ul>
<li>1.增加表字段<br/>
ALTER TABLE 表名 DROP COLUMN 字段名 字段类型</li>
<li>2.删除表字段<br/>
ALTER TABLE 表名 DROP COLUMN 字段名</li>
<li>3.修改表字段<br/>
ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名</li>
</ul>

<h4 id="toc_29">21、简单描述下客户端的缓存机制</h4>

<ul>
<li>1.缓存可以分为：内存数据缓存、数据库缓存、文件缓存</li>
<li>2.每次想获取数据的时候
<ul>
<li>先检测内存中有无缓存</li>
<li>在检测本地有无缓存（数据库/文件）</li>
<li>最终发送网络请求</li>
<li>将服务器返回的网络数据进行缓存（内存、数据库、文件），已便下次读取</li>
</ul></li>
</ul>

<h4 id="toc_30">22、有些图片加载的比较慢怎么处理？你是怎么优化程序的性能的？</h4>

<ul>
<li>1.图片下载放在异步线程</li>
<li>2.图片下载过程中使用占位图，提高用户的天</li>
<li>3.如果图片比较大，可以考虑多线程断点下载（开辟多个线程下载一张图片，需要服务器设置请求体信息）</li>
</ul>

<h4 id="toc_31">23、你实现过一个框架或者库以供别人使用吗？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。</h4>

<ul>
<li>1.提供给外界的接口功能是否实用、够用</li>
<li>2.别人使用我的框架时，能不能根据类名、方法名就猜出接口的具体作用</li>
<li>3.别人调用接口时，提供的参数是否够用、调用起来是否简单</li>
<li>4.别人使用我的框架时，要不要再导入依赖其他的框架</li>
</ul>

<h4 id="toc_32">24、是否可以把比较耗时的操作放在NSNotificationCenter中？</h4>

<ul>
<li>1.如果在异步线程发的通知，那么可以执行比较耗时的操作</li>
<li>2.如果在主线程发的通知，那么就不可以执行比较耗时的操作<br/>
补充：NSNotificationCenter默认是主线程的，但是在异步线程发通知，那么NSNotificationCenter就会变成异步线程</li>
</ul>

<h4 id="toc_33">25、SDWebImage具体如何实现</h4>

<ul>
<li>1.利用NSOperationQueue和NSOperation下载图片，还使用了GCD的一些函数（解码GIF图片）</li>
<li>2.利用URL作为key，NSOperation作为value</li>
<li>3.利用URL作为key，UIImage作为value</li>
</ul>

<h4 id="toc_34">26、怎么解决sqlite锁定的问题</h4>

<ul>
<li>1.设置数据库锁定的处理函数</li>
</ul>

<pre><code class="language-text">当数据库被锁时，会调用该方法
//参数1传入数据库，
//参数2传入函数名(在该函数中做操作)
int sqlite3_busy_handler(sqlite3*, test);
</code></pre>

<ul>
<li><p>2.设置锁定时的等待时间</p>
<pre><code class="language-text">int sqlite3_busy_timeout(sqlite3*, int ms);
</code></pre></li>
</ul>

<h4 id="toc_35">27、cocoa中常见对几种多线程的实现，并谈谈多线程安全的几种解决办法及多线程安全怎么控制？</h4>

<ul>
<li>1.只在主线程刷新访问UI</li>
<li>2.如果要防止资源抢夺，得用synchroized进行加锁保护</li>
<li>3.如果异步操作要保证线程安全等问题，尽量使用GCD（有些函数默认就是安全的）</li>
</ul>

<h4 id="toc_36">28、什么是run loop？</h4>

<ul>
<li>1.runloop是消息循环，内部有定时源和输入源来运作</li>
<li>2.在创建的程序不需要显示的创建run loop；每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象，主线程会自行创建并运行run loop</li>
<li>3.run loop处理的输入事件有两种不同的来源：输入源（input source）和定时源（timer source）</li>
<li>4.输入源处理传递异步消息，通常来自于其他线程或者程序。定时源则处理传递同步消息，在特定时间或者一定的时间间隔发生</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14719458588528.html">MKNetWork简介</a></h1>
			<p class="meta"><time datetime="2016-08-23T17:50:58+08:00" 
			pubdate data-updated="true">2016/8/23</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>用户版最新版本我将替换成最新的网络请求封装,这次我将封装一些常用的东西到网络请求中,让网络请求独立出一层,避免所有网络请求都写在控制器中.<br/>
目录结构:</p>

<ul>
<li><strong>MKBaseRequest</strong>     :所有的网络请求类需要继承于 <code>MKBaseRequest</code> 类，每一个<code>MKBaseRequest</code> 类的子类代表一种专门的网络请求。
MKBaseRequest 的基本的思想是把每一个网络请求封装成对象。所以使用 MKNetWork，你的每一种请求都需要继承 MKBaseRequest类，通过覆盖父类的一些方法来构造指定的网络请求。把每一个网络请求封装成对象其实是使用了设计模式中的 Command 模式。<br/>
每一种网络请求继承 MKBaseRequest 类后，需要用方法覆盖（overwrite）的方式，来指定网络请求的具体信息。例如:</li>
</ul>

<pre><code class="language-text">// 重写接口名称
-(NSString *)requestUrl {
    return @&quot;geocode/regeo&quot;;
}
// 重写请求方式
-(MKRequestMethod)requestMethod {
    return MKRequestMethodGet;
}
// 重写想要的放回数据解析方式
-(MKRequestSerializerType)requestSerializerType {
    return MKRequestSerializerTypeHTTP;
}
</code></pre>

<p>目前没有添加返回参数格式验证,如有需要可以在base中添加,让继承者重写.</p>

<ul>
<li><strong>MKNetWorkAgent</strong>    :MKNetWorkAgent最基础的网络请求封装,目前封装的AFN,如有必要可以替换</li>
<li><strong>MKNetworkConfig</strong>   :用于统一设置网络请求的服务器和 CDN 的地址。在实际业务中，我们的测试需要切换不同的服务器地址来测试。统一设置服务器地址到 MKNetworkConfig 类中，也便于我们统一切换服务器地址。</li>
</ul>

<pre><code class="language-text"> - (void)setupRequestFilters {
    // 这里用高德Api进行测试
    NSString *appVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];
    MKNetworkConfig *config = [MKNetworkConfig sharedInstance];
    config.baseUrl = @&quot;http://restapi.amap.com/v3/&quot;;
    MKUrlArgumentsFilter *urlFilter = [MKUrlArgumentsFilter filterWithArguments:@{@&quot;version&quot;: appVersion}];
    [config addUrlFilter:urlFilter];
}


- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    [self setupRequestFilters];
    
    return YES;
} 
</code></pre>

<ul>
<li><strong>MKChainRequest</strong>    :用于管理有相互依赖的网络请求，它实际上最终可以用来管理多个拓扑排序后的网络请求。</li>
</ul>

<p>例如，我们有一个需求，需要用户在注册时，先发送注册的Api，然后:</p>

<ol>
<li>如果注册成功，再发送读取用户信息的Api。并且，读取用户信息的Api需要使用注册成功返回的用户id号。</li>
<li>如果注册失败，则不发送读取用户信息的Api了。</li>
</ol>

<p><strong>不足:</strong></p>

<ol>
<li>目前没有做缓存,由于项目中url是根据时间戳,可以使用已有的缓存作为补充.也可以写到网络层封装中.</li>
<li>串行网络请求封装了,但是由于默认就是并行网络请求,所以没有封装.如果需要限制最大并发数量,可以在<code>MKNetWorkAgent</code>中设置.</li>
<li>木有大量测试,可能存在bug</li>
</ol>

<p><strong>注意事项:</strong><br/>
基本没有啥需要注意的...,具体使用方法可以参见Demo,关于参数可以实现代理方法,也可以直接传参.如果直接传参,会覆盖掉代理中的数据源.  Demo中实现了简单的下拉加载中关于page的封装.扩展功能我都写成代理,然后需要什么功能实现以下就可以了,避免<code>MKBaseRequest</code>中包含太多功能,这样可以实现自定义组成自己需要的功能.</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_26.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_24.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.html"><strong>原理探究&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8A%80%E5%B7%A7.html"><strong>技巧&nbsp;(34)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%95%99%E7%A8%8B.html"><strong>教程&nbsp;(23)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%81%87%E5%88%B0Bug.html"><strong>遇到Bug&nbsp;(12)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%9D%82%E8%AE%B0.html"><strong>杂记&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Swift.html"><strong>Swift&nbsp;(23)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="C/C++.html"><strong>C/C++&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Linux.html"><strong>Linux&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Documentation.html"><strong>Documentation&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Java.html"><strong>Java&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LeetCode.html"><strong>LeetCode&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="16267690953146.html">Flutter 中 listView 嵌套 listView</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16261554677251.html">Flutter中Row中的子控件左右两端对齐</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16246203092572.html">flutter 多环境设置</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16189060168232.html">iOS 开发环境配置</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16158207840706.html">AR 模型格式转换和导入</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



  














<style type="text/css">
  
/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript */
/*
 Solarized Color Schemes originally by Ethan Schoonover
 http://ethanschoonover.com/solarized

 Ported for PrismJS by Hector Matos
 Website: https://krakendev.io
 Twitter Handle: https://twitter.com/allonsykraken)
*/

/*
SOLARIZED HEX
--------- -------
base03    #002b36
base02    #073642
base01    #586e75
base00    #657b83
base0     #839496
base1     #93a1a1
base2     #eee8d5
base3     #fdf6e3
yellow    #b58900
orange    #cb4b16
red       #dc322f
magenta   #d33682
violet    #6c71c4
blue      #268bd2
cyan      #2aa198
green     #859900
*/

code[class*="language-"],
pre[class*="language-"] {
  color: #657b83; /* base00 */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;

  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  background: #073642; /* base02 */
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  background: #073642; /* base02 */
}

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
  border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdf6e3; /* base3 */
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #93a1a1; /* base1 */
}

.token.punctuation {
  color: #586e75; /* base01 */
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #268bd2; /* blue */
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.url,
.token.inserted {
  color: #2aa198; /* cyan */
}

.token.entity {
  color: #657b83; /* base00 */
  background: #eee8d5; /* base2 */
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #859900; /* green */
}

.token.function,
.token.class-name {
  color: #b58900; /* yellow */
}

.token.regex,
.token.important,
.token.variable {
  color: #cb4b16; /* orange */
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>
  
    


</body>
</html>