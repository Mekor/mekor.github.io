
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  李小争
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="李小争" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">李小争</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16623668836941.html">git 远程分支回滚</a></h1>
			<p class="meta"><time datetime="2022-09-05T16:34:43+08:00" 
			pubdate data-updated="true">2022/09/05</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>git代码库回滚: 指的是将代码库某分支退回到以前的某个commit id</p>
<p>【本地代码库回滚】：</p>
<p><code>git reset --hard commit-id</code> :回滚到commit-id，将commit-id之后提交的commit都去除</p>
<p><code>git reset --hard HEAD~3</code>：将最近3次的提交回滚</p>
<p>【远程代码库回滚】：</p>
<p>这个是重点要说的内容，过程比本地回滚要复杂</p>
<p>应用场景：自动部署系统发布后发现问题，需要回滚到某一个commit，再重新发布</p>
<p>原理：先将本地分支退回到某个commit，删除远程分支，再重新push本地分支</p>
<p>操作步骤：</p>
<pre><code class="language-plain_text">1、git checkout the_branch

2、git pull

3、git branch the_branch_backup //备份一下这个分支当前的情况

4、git reset --hard the_commit_id //把the_branch本地回滚到the_commit_id

5、git push origin :the_branch //删除远程 the_branch

6、git push origin the_branch //用回滚后的本地分支重新建立远程分支

7、git push origin :the_branch_backup //如果前面都成功了，删除这个备份分支
</code></pre>
<p>如果使用了gerrit做远程代码中心库和code review平台，需要确保操作git的用户具备分支的push权限，并且选择了 Force Push选项（在push权限设置里有这个选项）</p>
<p>另外，gerrit中心库是个bare库，将HEAD默认指向了master，因此master分支是不能进行删除操作的，最好不要选择删除master分支的策略，换用其他分支。如果一定要这样做，可以考虑到gerrit服务器上修改HEAD指针。。。不建议这样搞</p>
<p>方法一：<br />
1、新建backup分支 作为备份，以防万一</p>
<pre><code class="language-plain_text">git branch backup
</code></pre>
<p>2、将本地的backup分支　推送到远程的backup</p>
<pre><code class="language-plain_text">git push origin backup:backup
</code></pre>
<p>3、本地仓库彻底回退到xxxxx版本，xxxxx版本之后的commit信息将丢失</p>
<pre><code class="language-plain_text">git reset --hard xxxxx
</code></pre>
<p>4、删除远程的master分支 (注意master前有个:)</p>
<pre><code class="language-plain_text">git push origin :master
</code></pre>
<p>主要远程仓库的master如果是保护分支将报错，请去掉对分支的保护设置：<br />
需要管理员权限,在网页端操作<br />
5、重新创建远程master分支(这跟第１次提交本地代码库给远程仓库的命令一样)</p>
<pre><code class="language-plain_text">git push origin master
</code></pre>
<p>方法二：<br />
1、本地代码回滚到上一版本（或者指定版本）</p>
<pre><code class="language-plain_text">git reset --hard HEAD~1
</code></pre>
<p>2、加入-f参数，强制提交，远程端将强制跟新到reset版本</p>
<pre><code class="language-plain_text">git push -f origin master
</code></pre>
<p>注：方法二前建议如方法一一样备份当前git中的数据，个人推荐方法二</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16619340520854.html">CSS 排版</a></h1>
			<p class="meta"><time datetime="2022-08-31T16:20:52+08:00" 
			pubdate data-updated="true">2022/08/31</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>文章来源 <a href="https://www.zhangxinxu.com/wordpress/2022/06/css-line-break-word-wrap-all/">CSS排版为何强？瞧瞧多牛这换行</a><br />
CSS这门语言中有各种各样的CSS属性和值来专门处理与文字排版换行相关的需求。</p>
<h3><a id="%E4%B8%80%E3%80%81%E9%BB%98%E8%AE%A4%E6%8D%A2%E8%A1%8C%E8%A1%8C%E4%B8%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、默认换行行为</h3>
<p>在 Web 文字排版中，默认的换行行为如下。</p>
<h4><a id="1%E4%B8%AD%E6%96%87%EF%BC%88-cjk%E6%96%87%E5%AD%97%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 中文（CJK文字）</h4>
<p>所有中文的文字内容都是换行点，例如，当宽度很小的时候，文字一柱擎天显示了：</p>
<p><img src="media/16619340520854/16619341173538.png" alt="一柱擎天" /></p>
<p>但是如果有标点符号，则情况发生了变化。</p>
<p>因为标点自带一些特别的换行特性。</p>
<p>例如逗号，句号，问号，逗号，感叹号就属于避头标点，是不能在开头显示的，称为避头标点。</p>
<p>例如上引号，上括号不能出现一行的尾部，称为避尾标点。</p>
<p>由于这种不能出现在开头或结尾的特性，使得这些标点在匹配这种情况的时候是不能换行的。</p>
<p><img src="media/16619340520854/16619341173570.png" alt="" /></p>
<p>例如，下面的容器宽度很小的时候，也保持了两个汉字的宽度，原因在于最后的感叹号是避头标点，如果换行了，就会出现在一行的开头，这是不被允许的，因此，在“持”这个字后面显示了。</p>
<p>在所有的中文标点中，有个标点符号值得专门一提，这个标点就是中文的破折号。</p>
<p>当中文破折号连续书写的时候，虽然避首避尾规则各个浏览器下有所不同（见下图），但破折号内部不会换行是所有浏览器都保持一致的的。</p>
<p><img src="media/16619340520854/16619341173578.png" alt="破折号处理" /></p>
<h4><a id="2%E8%8B%B1%E6%96%87%E5%92%8C%E6%95%B0%E5%AD%97%EF%BC%88%E9%9D%9E-cjk%E6%96%87%E5%AD%97%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 英文和数字（非CJK文字）</h4>
<p>英文的单词由连续英文字母构成，因此默认是不会换行的，连续的数字也是如此，只有遇到空格（U+0020）或者短横线连接符（U+002d）才会换行。</p>
<p>因此，如果一段文字内容中都是英文体系的字符，没有空格和短横线，则就可能出现连续字符超过容器宽度的情况，如下图所示：</p>
<p><img src="media/16619340520854/16619341173586.png" alt=" 超出容器宽度" /></p>
<p>下面看看上述这些默认的换行行为如何使用 CSS 进行改变。</p>
<h3><a id="%E4%BA%8C%E3%80%81%E4%B8%AD%E6%96%87%E5%86%85%E5%AE%B9%E4%B8%8D%E5%8F%AF%E6%8D%A2%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、中文内容不可换行</h3>
<p>如果希望中文内容不能成为换行点，可以使用如下所示的 CSS 声明：</p>
<p><code>word-break:keep-all;</code></p>
<p>此设置不会影响英文内容，也就是英文句子该换行还是换行，只中文内容变得不会自动换行。</p>
<p>在精确排版场景中，有时候希望中文一行显示，比方说下面的例子。</p>
<p>在宽度自适应的表格下，如果表格宽度不是很富足，标题中文可能就会换行，实际上一行显示效果更好，此时就可以使用上面的 <code>word-break:keep-all</code>，效果如下图所示：</p>
<p><img src="media/16619340520854/16619341173593.png" alt="keep-all中文不换行" /></p>
<h3><a id="%E4%B8%89%E3%80%81%E4%B8%AD%E6%96%87%E6%A0%87%E7%82%B9%E5%8F%AF%E6%8D%A2%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、中文标点可换行</h3>
<p>如果希望中文标点没有避头和避尾特性，可以使用下面的 CSS 声明：</p>
<p><code>line-break: anywhere;</code></p>
<p>此时的效果如下图所示：</p>
<p><img src="media/16619340520854/16619341173602.png" alt="line-break-anywhere示意" /></p>
<p>可以看到上引号出现在了一行的尾部，句号也跑到了一行的开头。</p>
<h3><a id="%E5%9B%9B%E3%80%81%E8%BF%9E%E7%BB%AD%E7%A0%B4%E6%8A%98%E5%8F%B7%E5%8F%AF%E6%8D%A2%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、连续破折号可换行</h3>
<p>在默认情况下，如果书写过于冗长的破折号，可能会出现破折号超出容器宽度的布局问题，例如：</p>
<p><img src="media/16619340520854/16619341173611.png" alt="破折号超出容器" /></p>
<p>这肯定不是我们希望看到的，此时，可以通过设置如下所示的 CSS 声明让连续破折号也换行。</p>
<p><code>word-wrap: break-word;</code></p>
<p>此时，破折号就会在容器的边缘自动换行，效果如下所示：</p>
<p><img src="media/16619340520854/16619341173620.png" alt="破折号换行示意" /></p>
<h3><a id="%E4%BA%94%E3%80%81%E8%8B%B1%E6%96%87%E6%95%B0%E5%AD%97%E6%88%90%E4%B8%BA%E6%8D%A2%E8%A1%8C%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、英文数字成为换行点</h3>
<p>默认情况下，英文单词和连续的数字是无法换行的，此时我们可以使用如下所示的 CSS 声明使其强制换行。</p>
<p><code>word-break:break\-all;</code></p>
<p>例如，一开始出现的连续英文字符超出容器的渲染效果：</p>
<p><img src="media/16619340520854/16619341173586.png" alt=" 超出容器宽度" /></p>
<p>就会变成下图这样：</p>
<p><img src="media/16619340520854/16619341173636.png" alt="换行处理" /></p>
<h3><a id="%E5%85%AD%E3%80%81%E7%A9%BA%E6%A0%BC%E4%B8%8D%E6%98%AF%E6%8D%A2%E8%A1%8C%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>六、空格不是换行点</h3>
<p>默认情况下，英文句子都是在空格位置处换行，如果希望这些空格不再是换行点，可以使用下面的 CSS 声明：</p>
<p><code>white-space: nowrap;</code></p>
<p>例如，这是一段默认排版的文字：</p>
<p><img src="media/16619340520854/16619341173645.png" alt="空格换行" /></p>
<p>应用了 <code>white-space:nowrap</code> 后就会一行显示：</p>
<p><img src="media/16619340520854/16619341173655.png" alt="空格不会换行" /></p>
<p>由于在 Web 中，换行符都会按照空格进行解析，因此，当一段文字设置为 white-space:nowrap，中文也会在一行显示，因为让中文换行的这个换行符解析成了 white-space。</p>
<p>如果还是不理解，可以参考我之前这篇文章：“<a href="https://www.zhangxinxu.com/wordpress/2021/07/css-white-space-nowrap/">为什么white-space:nowrap可以让文字一行显示？</a>”</p>
<h3><a id="%E4%B8%83%E3%80%81%E8%8B%B1%E6%96%87%E6%A0%87%E7%82%B9%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>七、英文标点强制换行</h3>
<p>某些英文表单具有不可换行特性，例如 i’m 这个单词，其中的单引号具有特殊含义，默认是不能换行的。</p>
<p>此时，我们可以设置如下所示的 CSS 声明，让这个单引号单独一行显示。</p>
<p><code>overflow-wrap: anywhere;</code></p>
<p>我们可以对比下 <code>word-break:break-all</code> 这个声明，就可以知道 <code>overflow-wrap:anywhere</code> 的作用了。<br />
如下一段 HTML 和 CSS 代码：</p>
<pre><code class="language-plain_text">&lt;p class\=&quot;p1&quot;\&gt;i'm a developer&lt;/p\&gt;
&lt;p class\=&quot;p2&quot;\&gt;i'm a developer&lt;/p\&gt;

p {
  width: min-content;
  border: 2px solid deepskyblue;
}
.p1 {
  overflow-wrap: anywhere;
}
.p2 {
  word-break: break-all;
}
</code></pre>
<p>此时的效果对比效果如下图所示：</p>
<p><img src="media/16619340520854/16619341173665.png" alt="英文标点换行" /></p>
<h3><a id="%E5%85%AB%E3%80%81%E7%BB%93%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>八、结语</h3>
<p>从上面的案例可以看出，凡是 Web 中的换行规则都可以改变，无论是中文的还是英文的，灵活到超出你的想象，非常强大。</p>
<p>所以在文字内容排版这块，CSS 是计算机领域中无可争议的霸主气，什么 SVG 什么 canvas 根本就是望尘莫及。</p>
<p>当然，关于 CSS 文字排版，还有很多其他属性，以及还有很多上面出现过的属性的其他值。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16613374889545.html">前端开发环境配置</a></h1>
			<p class="meta"><time datetime="2022-08-24T18:38:08+08:00" 
			pubdate data-updated="true">2022/08/24</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3><a id="%E5%AE%89%E8%A3%85xcode%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装Xcode环境</h3>
<p>如果想避免安装Xcode可以在命令行中输入</p>
<pre><code class="language-shell">xcode-select --install
</code></pre>
<p>即可安装 CLT for Xcode</p>
<h3><a id="%E5%AE%89%E8%A3%85homebrew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装Homebrew</h3>
<p>直接使用官网的安装链接会报443，可以使用国内镜像安装<br />
方式1：<br />
<a href="https://gitee.com/cunkai/HomebrewCN">gitee安装</a>：</p>
<pre><code class="language-plain_text">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;
</code></pre>
<p>方式2:<br />
<a href="https://mirror.tuna.tsinghua.edu.cn/help/homebrew/">清华镜像安装</a></p>
<h3><a id="nvm%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>nvm安装</h3>
<p>homebrew安装好后，执行</p>
<pre><code class="language-plain_text">brew install nvm
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16607216444595.html">网站SEO</a></h1>
			<p class="meta"><time datetime="2022-08-17T15:34:04+08:00" 
			pubdate data-updated="true">2022/08/17</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>可以做的有像百度主动提交链接 <a href="https://ziyuan.baidu.com/linksubmit/url">链接提交</a></li>
<li>域名根目录下放<code>robots.txt</code>根据要求只有首页能被抓取</li>
<li></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402963682.html">Vue3设计思想与理念</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="vue3%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3整体架构</h2>
<h3><a id="vue3%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3架构介绍</h3>
<h4><a id="monorepo%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Monorepo 管理项目</h4>
<p>Monorepo是管理项目代码的一个方式，指在一个项目仓库（repo）中管理多个模块、包（package）。Vue3源码采用monorepo方式进行管理，将模块拆分到package目录中。</p>
<ul>
<li>一个仓库可维护多个模块，不用导出找仓库</li>
<li>方便版本管理和依赖管理，模块之间的引用，调用都非常方便。</li>
</ul>
<h4><a id="vue3%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3项目结构</h4>
<p><img src="media/16587402963682/Vue3%E7%BB%84%E6%88%90.png" alt="Vue3组成" /></p>
<h4><a id="vue3%E9%87%87%E7%94%A8typescript" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3采用TypeScript</h4>
<p>Vue2采用Flow来进行类型检测（Vue2对ts支持并不友好），Vue3源码采用TypeScript来进行重写，对ts支持更友好。</p>
<h3><a id="vue3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3开发环境搭建</h3>
<h4><a id="%E6%90%AD%E5%BB%BAmonorepo%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>搭建Monorepo环境</h4>
<p>Vue3中使用pnpm workspace 来实现monorepo（pnpm是快速、节省磁盘空间的包管理器。主要采用符号链接的方式管理模块）</p>
<p><strong>全局安装pnpm</strong></p>
<pre><code class="language-shell">npm install pnpm -g #全局安装pnpm
</code></pre>
<pre><code class="language-shell">pnpm init -y # 初始化配置文件，今天尝试了一下已经不需要参数了
</code></pre>
<p><strong>创建.npmrc 文件</strong></p>
<pre><code class="language-plain_text">shamefully-hoist = true
</code></pre>
<p>这里可以尝试安装Vue3，<code>pnpm install vue@next</code>此时默认情况下Vue3中依赖的模块不会被提升到node_modules下，添加<strong>羞耻的提升</strong>可以讲Vue3所依赖的模块提升到node_modules中。</p>
<h4><a id="%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建工作空间</h4>
<p>创建<code>pnpm-workspack.yaml</code>，并指定工作空间目录</p>
<pre><code class="language-plain_text">packages:
  - 'packages/*'
</code></pre>
<p>表示所有包都在packages目录下</p>
<h4><a id="ts%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TS 配置文件</h4>
<p>使用<code>pnpm tsc --init</code>创建tsconfig.json</p>
<pre><code class="language-plain_text">{
  &quot;compilerOptions&quot;: {
    /* Visit https://aka.ms/tsconfig to read more about this file */
    /* Language and Environment */
    &quot;target&quot;: &quot;es2016&quot;,        // 目标语法                          
    &quot;lib&quot;: [&quot;ESNext&quot;,&quot;DOM&quot;],   // 支持的类库 esnext及dom                                     
    &quot;jsx&quot;: &quot;preserve&quot;,       //jsx不转义                         

    /* Modules */
    &quot;module&quot;: &quot;ESNext&quot;,     // 模块格式                           
    &quot;moduleResolution&quot;: &quot;node&quot;,     // 模块解析方式                  
    &quot;baseUrl&quot;: &quot;.&quot;,                                  
    &quot;paths&quot;: {
      &quot;@vue/*&quot;:[&quot;packages/*/src&quot;]
    },                                      
    &quot;resolveJsonModule&quot;: true,  // 解析JSON模块                      
    
    /* Emit */
    &quot;sourceMap&quot;: true,   // 采用sourceMap                             
    &quot;outDir&quot;: &quot;dist&quot;,    //输出的目录                               
    

    /* Interop Constraints */
    &quot;esModuleInterop&quot;: true,     // 允许通过es6语法引入commonjs模块                       

    /* Type Checking */
    &quot;strict&quot;: false,         // 严格模块                             
  }
}

</code></pre>
<p>ts配置文件是为了，模块引入的时候可以直接找到对应的位置</p>
<pre><code class="language-plain_text">import {isObject} from &quot;@vue/shared&quot;
</code></pre>
<p>路径在配置时已经确定，如果配置改了，引入的时候也要相应的修改<br />
<img src="media/16587402963682/16588231721998.jpg" alt="" /></p>
<h2><a id="vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3响应式原理</h2>
<h3><a id="vue3%E5%93%8D%E5%BA%94%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3响应式</h3>
<h4><a id="vue3%E5%AF%B9%E6%AF%94vue2%E7%9A%84%E5%8F%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vue3对比Vue2的变化</h4>
<ul>
<li>在Vue2的使用使用defineProperty来进行数据的劫持，需要对属性进行重写添加<code>getter</code>和<code>setter</code><strong>性能差</strong></li>
<li>当新增属性和删除属性时无法监控变化.需要通过<code>$set</code>、<code>$delete</code>实现</li>
<li>数组不采用defineProperty来进行劫持（浪费性能，对所有索引进行劫持会造成性能浪费）需要对数组单独进行处理。</li>
</ul>
<blockquote>
<p>Vue3中使用Proxy来实现响应式数据变化，从而解决上述问题。</p>
</blockquote>
<h4><a id="compositionapi" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CompositionApi</h4>
<ul>
<li>在Vue2中采用的是OptionsAPI，用户提供的data,props,methods,computed,watch等属性（用户编写复杂业务逻辑会出现反复横跳问题）</li>
<li>Vue2中所有的属性都是通过<code>this</code>访问，<code>this</code>存在指向明确问题</li>
<li>Vue2中很多未使用方法或属性依旧会被打包，并且所有全局API都在Vue对象上公开。CompositionAPI对tree-shaking更加友好，代码也更容易压缩。</li>
<li>组件逻辑共享问题，Vue2采用mixins实现组件质检的逻辑共享；但是会有书记来源不明确，命名冲突等问题。Vue3采用CompositionAPI提取公共逻辑非常方便</li>
</ul>
<blockquote>
<p>简单的组件仍然可以采用OptionsAPI进行编写，compositionAPI在复杂的逻辑中有着明显的优势。<code>reactivity</code>模块中就包含了很多我们经常使用的API，例如：<code>computed</code>、<code>reactive</code>、<code>ref</code>、<code>effect</code>等。</p>
</blockquote>
<h4><a id="reactivity" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reactivity</h4>
<p>reactive 将数据变成响应式， Proxy</p>
<pre><code class="language-plain_text">const {effect,reactive,shallowReactive} = VueReactivity;
const state = reactive({name:'xm',age:18,address:{num:209}});
consloe.log(state)


// 此effect函数默认会先执行一次，对响应式数据取值（取值的过程中数据会依赖于当前的effect）
effect(()=&gt;{
    document.getElementById('app').innerHTML = state.name + '今年' + state.age + '岁了'
})


// 稍后name 和age变化会重新执行effect函数
setTimeout(()=&gt;{state.age = 14;},1000)
</code></pre>
<p>reactive 会把state中子对象也设置为代理对象<br />
shallowReactive 只代理一层</p>
<h5><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%AE%80%E5%8D%95%E7%9A%84proxy%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么不能简单的Proxy实现</h5>
<pre><code class="language-plain_text">  const proxy = new Proxy(target, {
    get(target, key, receiver) { 
      return target[key];
    },
    set(target, key, value, receiver) { 
      target[key] = value;
      return true;
    }
  })
</code></pre>
<p>加入目标target如下</p>
<pre><code class="language-plain_text">let target = {
    name:&quot;zs&quot;,
    get alias() {
        return this.name
    }
}
</code></pre>
<p>这个时候如果取<code>proxy.alias</code> 去alias上取了值时，也去了name，但是没有监控到name.<br />
这个时候需要使用Reflect（反射），防止this指向出问题<br />
代码如下</p>
<pre><code class="language-plain_text">// 并没有重新定义属性,只是代理,在取值的时候调用get,当赋值的时候调用set
  const proxy = new Proxy(target, {
    /**
     * @param target 元对象
     * @param key 键
     * @param receiver 代理对象 --&gt; proxy
     * @returns 
     */
    get(target, key, receiver) { 
      return Reflect.get(target,key,receiver)
    },
    set(target, key, value, receiver) { 
      return Reflect.set(target,key,value,receiver);
    }
  })
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402961731.html"><禅与摩托车维修艺术></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>生活处处都透露着哲学，作者从骑摩托车旅行的途中对事物进行了深入的思考。</p>
<h2><a id="%E5%85%B3%E4%BA%8E%C2%B7%E5%BF%99%C2%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于·忙·</h2>
<p>书中这样写道：</p>
<blockquote>
<p>我们常常太忙而没有时间好好聊聊，结果日复一日地过着无聊的生活，单调乏味的日子让人几年后想起来不禁怀疑，究竟自己是怎么过的，而时间已悄悄溜走了。现在我们的确空下来了，我想谈一些我自己觉得颇为重要的事。</p>
</blockquote>
<h2><a id="%E5%85%B3%E4%BA%8E%C2%B7%E8%BF%87%E7%A8%8B%C2%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于·过程·</h2>
<blockquote>
<p>如果搭飞机抵达洛基山，你只会觉得景致很美，但是如果你是经过几天辛苦的旅程，通过这一片大草原，才抵达洛基山，那么你会从另一个角度来看它，那里仿佛是你的目标，是你的应许之地。</p>
</blockquote>
<p>我们的目标不应该仅仅是到达终点，旅途中的风景会让这个过程变得充实。我在记笔记的时候写的是“有过程的经历是印象深刻的”</p>
<h2><a id="%E5%85%B3%E4%BA%8E%C2%B7%E8%AF%86%E4%BA%BA%C2%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于·识人·</h2>
<blockquote>
<p>又钻进死胡同了。如果有人不懂心存感激，而你当面告诉他，那么你就等于是在骂他，这样你什么事都解决不了。<br />
每个人的性格都是不一样的，需要针对不同的性格做出不同的处理方式。错误的处理方式只会加深矛盾</p>
</blockquote>
<h2><a id="%E5%85%B3%E4%BA%8E%C2%B7%E8%AE%A4%E7%9F%A5%C2%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于·认知·</h2>
<blockquote>
<p>一名没有受过训练的旁观者只看到修理人员所付出的劳力，就以为他最主要的工作在于劳力。事实上，这正是他最轻松也是工作上最小的一部分，他最重要的工作就在于仔细观察和精确思考，这就是为什么技术人员往往显得沉默寡言，甚至在做实验的时候有些畏缩。他们不喜欢在做实验的时候讲话，那样就无法专心地思考问题了。他们借着实验推论出问题的结构，然后与心里正常的运作结构相比较，所以他们看到的是基本形式。</p>
</blockquote>
<p>隔行如隔山，拿程序员举例，其他人看到程序员噼里啪啦敲代码感觉这个人很厉害这其实是不对的。在敲代码之前的思考才是最重要的，敲代码只不过是把他思考的东西进行验证。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402970662.html">各种队列的执行效果</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:37+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<table>
<thead>
<tr>
<th style="text-align: left"></th>
<th style="text-align: left">并发队列</th>
<th style="text-align: left">手动创建的串行队列</th>
<th style="text-align: left">主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">同步（sync）</td>
<td style="text-align: left">*没有开启新线程 *串行执行任务</td>
<td style="text-align: left">*没有开启新线程 *串行执行任务</td>
<td style="text-align: left">*没有开启新线程 *串行执行任务</td>
</tr>
<tr>
<td style="text-align: left">异步（async）</td>
<td style="text-align: left">*有开启新线程 *并发执行任务</td>
<td style="text-align: left">*有开启新线程 *串行执行任务</td>
<td style="text-align: left">*没有开启新线程 *串行执行任务</td>
</tr>
</tbody>
</table>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402970879.html">632. Smallest Range Covering Elements from K Lists</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:37+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>题目地址:<a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">632. 最小区间</a><br />
You have <code>k</code> lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the <code>k</code> lists.</p>
<p>We define the range <code>[a,b]</code> is smaller than range <code>[c,d]</code> if <code>b-a &lt; d-c</code> or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p>
<ul>
<li><strong>Example 1:</strong></li>
</ul>
<pre><code class="language-plain_text">Input: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
Output: [20,24]
Explanation: 
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
List 2: [0, 9, 12, 20], 20 is in range [20,24].
List 3: [5, 18, 22, 30], 22 is in range [20,24].
</code></pre>
<p>Note:</p>
<ol>
<li>The given list may contain duplicates, so ascending order means &gt;= here.</li>
<li>1 &lt;= k &lt;= 3500</li>
<li>-10^5 &lt;= value of elements &lt;= 10^5.</li>
</ol>
<p>解题思路：<br />
先看🌰</p>
<pre><code class="language-plain_text">4,10,15,24,26
0, 9,12,20
5,18,22,30
</code></pre>
<p>因为每个数组中必须有一个数字包含在其中，一开始我们取每个数组中的第一个数字</p>
<pre><code class="language-plain_text">*4*,10,15,24,26
*0*, 9,12,20
*5*,18,22,30
</code></pre>
<p><code>4,0,5</code>最小的是<code>0</code>,最大值是<code>5</code>区间是<code>5-0=5</code><br />
把第一个最小区间5的坐标记录下来就是<code>[0,5]</code><br />
去掉最小的值,然后最小值所在的数组向后取一位即</p>
<pre><code class="language-plain_text">*4*,10,15,24,26
0, *9*,12,20
*5*,18,22,30
</code></pre>
<p><code>4,9,5</code>最小的是<code>4</code>,最大值是<code>9</code>区间是<code>9-4=5</code>最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>
<pre><code class="language-plain_text">4,*10*,15,24,26
0, *9*,12,20
*5*,18,22,30
</code></pre>
<p><code>10,9,5</code>最小的是<code>5</code>,最大值是<code>10</code>区间是<code>10-5=5</code>最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>
<pre><code class="language-plain_text">4,*10*,15,24,26
0, *9*,12,20
5,*18*,22,30
</code></pre>
<p><code>10,9,18</code>最小的是<code>9</code>,最大值是<code>18</code>区间是<code>18-9=9</code>,因为<code>9&gt;5</code>不符合规则,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>
<pre><code class="language-plain_text">4,*10*,15,24,26
0, 9,*12*,20
5,*18*,22,30
</code></pre>
<p><code>10,12,18</code>最小的是<code>10</code>,最大值是<code>18</code>区间是<code>18-10=8</code>,因为<code>8&gt;5</code>不符合规则,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>
<pre><code class="language-plain_text">4,10,*15*,24,26
0, 9,*12*,20
5,*18*,22,30
</code></pre>
<p><code>15,12,18</code>最小的是<code>12</code>,最大值是<code>18</code>区间是<code>18-12=6</code>,因为<code>6&gt;5</code>不符合规则,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>
<pre><code class="language-plain_text">4,10,*15*,24,26
0, 9,12,*20*
5,*18*,22,30
</code></pre>
<p><code>15,20,18</code>最小的是<code>15</code>,最大值是<code>20</code>区间是<code>20-15=5</code>,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>
<pre><code class="language-plain_text">4,10,15,*24*,26
0, 9,12,*20*
5,*18*,22,30
</code></pre>
<p><code>24,20,18</code>最小的是<code>18</code>,最大值是<code>24</code>区间是<code>24-18=6</code>,因为<code>6&gt;5</code>不符合规则,最小区间不变还是5,所以去掉最小的值,然后最小值所在的数组向后取一位即</p>
<pre><code class="language-plain_text">4,10,15,*24*,26
0, 9,12,*20*
5,18,*22*,30
</code></pre>
<p><code>24,20,22</code>最小的是<code>20</code>,最大值是<code>24</code>区间是<code>24-20=4</code>,因为<code>4&lt;5</code>符合规则,最小区间变更为4,把最小区间4的坐标记录下来就是<code>[20,24]</code>,这时继续向后走,由于最小值是<code>20</code>而<code>20</code>所在的数组已经走到了结尾,不能继续走,再走就不能满足每个数组中必须有一个数包含在其中.<br />
所以返回最小区间<code>[20,24</code></p>
<p>参考代码:</p>
<pre><code class="language-Java">class Solution {
    public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) {
        // 里面存储的是行列数据位置，优先级是列中数据大小
        PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; nums.get(o[0]).get(o[1])));
        int max = Integer.MIN_VALUE, start = 0, end = Integer.MAX_VALUE;
        // 先让每个数组中的第一个数进入 q
        for (int i = 0; i &lt; nums.size(); i++) {
            q.offer(new int[]{i, 0});
            max = Math.max(max, nums.get(i).get(0));
        }
        while (q.size() == nums.size()) {
            // 取出最小的元素获得到行列信息
            int e[] = q.poll(), row = e[0], col = e[1];
            // 比较，如果符合条件就更新最小区间信息
            if (end - start &gt; max - nums.get(row).get(col)) {
                start = nums.get(row).get(col);
                end = max;
            }
            // 防止越界
            if (col + 1 &lt; nums.get(row).size()) {
                q.offer(new int[]{row, col + 1});
                max = Math.max(max, nums.get(row).get(col + 1));
            }
        }
        return new int[]{start, end};
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402971086.html">Flutter手势，触摸事件处理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:37+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E7%B1%BB%E4%BC%BCbutton%E4%B9%8B%E7%B1%BB%E7%9A%84widget" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类似Button之类的Widget</h2>
<p>这种自带点击事件参数，比如<code>RaisedButton</code> widget拥有一个<code>onPressed</code>参数。</p>
<pre><code class="language-dart">…
return RaisedButton(onPressed:(){
Print(“click”);
},child:Text(“Button”)),
</code></pre>
<h2><a id="%E6%9C%AC%E8%BA%AB%E4%B8%8D%E6%94%AF%E6%8C%81%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本身不支持点击事件</h2>
<p>可以在外面包装一个<code>GestureDetecter</code>，并给它的onTap属性传递一个函数：</p>
<pre><code class="language-dart">GestureDetector(child:FlutterLogo(size:200.0),onTap:(){print(“tap d点击了”)},);

</code></pre>
<p>使用GestureDectector可以监测多种事件。</p>
<ul>
<li>onTapDown -手指触摸了Widget</li>
<li>onTapUp -手指离开了Widget</li>
<li>onTap -轻触</li>
<li>onTapCancel -触发了onTapDown但是没有触发onTap</li>
<li>onDoubleTap -同一位置两次快速点击</li>
<li>onLongPress -同一位置长按</li>
<li>垂直拖动
<ul>
<li>onVerticalDragStart - 接触了屏幕，并且可能会垂直移动</li>
<li>onVerticalDragUpdate - 接触了屏幕并在垂直方向继续移动</li>
<li>onVerticalDragEnd -之前接触了屏幕并垂直移动，并在停止接触屏幕前以某个垂直的速度移动</li>
</ul>
</li>
<li>水平拖动
<ul>
<li>和垂直类似</li>
</ul>
</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402971290.html">UITableView 第0的sectionHeaderView 不显示</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:37+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>只有当UITableView是Grouped样式，并且section的高度是通过sectionHeaderHeight设置的时候，第0个section的headerView才会丢失，通过代理设置不会丢失。如果UITableView是Plain样式就不会有任何问题。</p>
<p>下面是不显示第0个sectionHeaderView的情况<br />
<img src="media/16587402971290/15336074512241.jpg" alt="" style="width:1406px;" /></p>
<p>正常显示<br />
<img src="media/16587402971290/15336075291692.jpg" alt="" style="width:1394px;" /><br />
在正常显示的时候明显感觉到第0个section上面有间距，真机没有测试。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402971504.html">C++Primer笔记 - 如何获取 `main`的返回值</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:37+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>访问<code>main</code>的返回值的方法依赖于系统.在UNIX和Windows系统中,执行完一个程序后,都可以通过echo命令获得其返回值.<br />
在UNIX中通过<code>echo $?</code><br />
在Windows中通过<code>echo %ERRORLEVEL%</code></p>
<p>使用方式:<br />
在terminal中, <code>vim prog1.cc</code> ,然后在vim下输入(<code>i</code>是插入键)</p>
<pre><code class="language-plain_text"> int main()
 {
     return 0;
 }
</code></pre>
<p>退出编辑器(先按<code>esc</code>,然后<code>:wq</code>)<br />
在terminal中运行</p>
<pre><code class="language-plain_text">cc prog1.cc
./a.out
echo $?
</code></pre>
<p>最终会得到我们的返回值<code>0</code></p>
<p><strong>1.1节练习</strong><br />
1.2: main中返回-1.返回值-1通常被当做程序错误的标识.重新编译运行我再次获取错误值为255<br />
<img src="media/16587402971504/14866102127236.jpg" alt="" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402971722.html">关于签名(Certificate),Identifiers,Device和Provisioning Profile</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:37+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>直接上图:</p>
<p><img src="media/16587402971722/%E6%80%BB%E7%BB%93.png" alt="总结" /></p>
<p>应该很详细了</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402971927.html">库管理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:37+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>使用<code>pod</code>进行库管理</p>
<h1><a id="%E8%A7%92%E8%89%B2%E5%88%87%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>角色切换</h1>
<p>目前使用枚举进行角色切换.手动测试更换可以修改浮窗<code>PanelContentViewController</code> 中<code>homeCategory</code>切换</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402972137.html">如何解决json字符串中包含制表符</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:37+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>错误信息:</p>
<pre><code class="language-plain_text">Error Domain=NSCocoaErrorDomain Code=3840 &quot;The operation couldn’t be completed. (Cocoa error 3840.)&quot; (Unescaped control character around character 135.) UserInfo=0x170e79d00 {NSDebugDescription=Unescaped control character around character 135.}
</code></pre>
<p><strong>如何处理</strong><br />
最关键的地方:</p>
<pre><code class="language-plain_text">-(NSString *)removeUnescapedCharacter:(NSString *)inputStr
{
    NSCharacterSet *controlChars = [NSCharacterSet controlCharacterSet];//获取那些特殊字符
    NSRange range = [inputStr rangeOfCharacterFromSet:controlChars];//寻找字符串中有没有这些特殊字符
    if (range.location != NSNotFound)
        {
        NSMutableString *mutable = [NSMutableString stringWithString:inputStr];
        while (range.location != NSNotFound)
            {
            [mutable deleteCharactersInRange:range];//去掉这些特殊字符
            range = [mutable rangeOfCharacterFromSet:controlChars];
            }
        return mutable;
        }
    return inputStr;
}
</code></pre>
<p>举例:</p>
<pre><code class="language-plain_text">    NSString *responseString = [NSMutableString stringWithString:[request responseString]];
    responseString =[self removeUnescapedCharacter:responseString];
    NSData *jsonData = [responseString dataUsingEncoding:NSUTF8StringEncoding];
    NSError *error;
    NSDictionary * dic = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;error];
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402960469.html">Coding中检测系统授权状态，关闭提示用户去隐私设置中打开</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>参考Coding项目,二维码扫描中使用到,大家可以参考:<a href="https://github.com/Mekor/MKScanner">MKScanner</a></p>
</blockquote>
<p>Helper.h文件</p>
<pre><code class="language-plain_text">#import &lt;Foundation/Foundation.h&gt;

@interface Helper : NSObject

/**
 * 检查系统&quot;照片&quot;授权状态, 如果权限被关闭, 提示用户去隐私设置中打开.
 */
+ (BOOL)checkPhotoLibraryAuthorizationStatus;

/**
 * 检查系统&quot;相机&quot;授权状态, 如果权限被关闭, 提示用户去隐私设置中打开.
 */
+ (BOOL)checkCameraAuthorizationStatus;

@end
</code></pre>
<p>Helper.m文件</p>
<pre><code class="language-plain_text">#import &quot;Helper.h&quot;
@import AVFoundation;

@implementation Helper

+ (BOOL)checkPhotoLibraryAuthorizationStatus
{
    if ([ALAssetsLibrary respondsToSelector:@selector(authorizationStatus)]) {
        ALAuthorizationStatus authStatus = [ALAssetsLibrary authorizationStatus];
        if (ALAuthorizationStatusDenied == authStatus ||
            ALAuthorizationStatusRestricted == authStatus) {
            [self showSettingAlertStr:@&quot;请在iPhone的“设置-&gt;隐私-&gt;照片”中打开本应用的访问权限&quot;];
            return NO;
        }
    }
    return YES;
}

+ (BOOL)checkCameraAuthorizationStatus
{
    if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {
        kTipAlert(@&quot;该设备不支持拍照&quot;);
        return NO;
    }
    
    if ([AVCaptureDevice respondsToSelector:@selector(authorizationStatusForMediaType:)]) {
        AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];
        if (AVAuthorizationStatusDenied == authStatus ||
            AVAuthorizationStatusRestricted == authStatus) {
            [self showSettingAlertStr:@&quot;请在iPhone的“设置-&gt;隐私-&gt;相机”中打开本应用的访问权限&quot;];
            return NO;
        }
    }
    
    return YES;
}

+ (void)showSettingAlertStr:(NSString *)tipStr{
    //iOS8+系统下可跳转到‘设置’页面，否则只弹出提示窗即可
    if (floor(NSFoundationVersionNumber) &gt; NSFoundationVersionNumber_iOS_7_1) {
        UIAlertView *alertView = [UIAlertView bk_alertViewWithTitle:@&quot;提示&quot; message:tipStr];
        [alertView bk_setCancelButtonWithTitle:@&quot;取消&quot; handler:nil];
        [alertView bk_addButtonWithTitle:@&quot;设置&quot; handler:nil];
        [alertView bk_setDidDismissBlock:^(UIAlertView *alert, NSInteger index) {
            if (index == 1) {
                UIApplication *app = [UIApplication sharedApplication];
                NSURL *settingsURL = [NSURL URLWithString:UIApplicationOpenSettingsURLString];
                if ([app canOpenURL:settingsURL]) {
                    [app openURL:settingsURL];
                }
            }
        }];
        [alertView show];
    }else{
        kTipAlert(@&quot;%@&quot;, tipStr);
    }
}

@end

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402960672.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>class TreeNode {<br />
private TreeNode left;<br />
private TreeNode right;<br />
private int start;<br />
private int end;</p>
<pre><code class="language-plain_text">    public TreeNode(int start, int end) {
        this.start = start;
        this.end = end;
    }
}

TreeNode root;

public MyCalendar() {

}

public boolean book(int start, int end) {
    if (root == null) {
        root = new TreeNode(start, end);
        return true;
    }
    TreeNode cur = root;
    while (true) {
        //在树的左侧
        if (end &lt;= cur.start) {
            if (cur.left == null) {
                cur.left = new TreeNode(start, end);
                return true;
            }
            cur = cur.left;
        } else if (start &gt;= cur.end) {
            //在树的右侧
            if (cur.right == null) {
                cur.right = new TreeNode(start, end);
                return true;
            }
            cur = cur.right;
        } else {
            //包含返回false
            return false;
        }
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402960880.html">Flutter 环境变量设置</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>我把flutter文件夹拖到资源库中<br />
<img src="media/16587402960880/16154735272429.jpg" alt="" style="width:920px;" /></p>
<p>然后更改环境变量</p>
<pre><code class="language-plain_text">code ~/.bash_profile
</code></pre>
<p>在环境变量后面添加flutter的环境变量</p>
<pre><code class="language-plain_text">export PATH=/Users/logan/Library/flutter/bin:$PATH
</code></pre>
<p>然后看下版本号</p>
<pre><code class="language-plain_text">flutter --version
</code></pre>
<p>然后看到输出类似</p>
<pre><code class="language-plain_text">Flutter 2.0.1 • channel stable • https://github.com/flutter/flutter.git
Framework • revision c5a4b4029c (7 days ago) • 2021-03-04 09:47:48 -0800
Engine • revision 40441def69
Tools • Dart 2.12.0
</code></pre>
<p>这样就没有问题了</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402961091.html">指针</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1%E6%8C%87%E9%92%88%E6%98%AF%E4%B8%80%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 指针是一种数据类型</h2>
<ol>
<li>
<p>指针也是一种变量,占有内存空间,用来保存内存地址  指针的大小--&gt; 32位: 4  64位: 8</p>
</li>
<li>
<p><code>*p</code> 操作内存</p>
<pre><code class="language-plain_text">在指针声明时,`*`号表示所声明的变量为指针
在指针使用时,`*`号表示**操作**指针所指向的内存空间中的值
`*p`相当于通过地址(p变量的值)找到一块内存,然后操作内存
`*p`放在等号左边赋值(给内存赋值)
`*p`放在等号右边取值(从内存获取值)
</code></pre>
</li>
<li>
<p>指针变量和它指向的内存块是两个不同的概念</p>
<pre><code class="language-plain_text">含义1: 给p赋值 p = 0x1111; 只会改变指针变量值,不会改变所指的内容; p = p+1
含义2: 给`*p`赋值 *p = 'a';不会改变指针变量的值,只会改变所指的内存块的值
保证所指向的内存空间能修改()
*就像一把钥匙,通过一个地址(&amp;a),去修改a变量的标示的内存空间
</code></pre>
</li>
<li>
<p>指针是一种数据类型,是指它指向的内存空间的数据类型</p>
<pre><code class="language-plain_text">指针步长(p++),根据所指内存空间的数据类型类确定
p++ = ---&gt; p+sizeof(a)
</code></pre>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402961322.html">优秀文章链接收藏</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##优化<br />
<a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-3-imp-deluxe.html">极致优化</a></p>
<p>美团点评技术团队: <a href="http://tech.meituan.com/DiveIntoMethodCache.html">深入理解Objective-C：方法缓存</a></p>
<h2><a id="runloop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Runloop</h2>
<p><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a>  --- 内部分享文章runloop中使用了该文章中的一张图.</p>
<p>##GCD<br />
<a href="http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1">GCD 深入理解：第一部分</a> 中文翻译:<a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">译文</a><br />
<a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md">GCD 深入理解：第二部分</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402961539.html">iOS8之后设置PopoverController</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>直接上代码:</p>
<pre><code class="language-plain_text">    @IBOutlet weak var popoverButton: UIButton!
    @IBAction func popoverClick(_ sender: Any) {
        
        // 需要被展示的控制器
        let popover = PopoverViewController()
        // 设置呈现样式
        popover.modalPresentationStyle = .popover
        // 对应原来PopoverController中的rect
        popover.popoverPresentationController?.sourceRect = self.popoverButton.bounds
        // 对应原来PopoverController中的inView
        popover.popoverPresentationController?.sourceView = self.popoverButton
        // 展示
        self.present(popover, animated: true, completion: nil)
    }
</code></pre>
<p>在被呈现的控制器中设置显示的大小:</p>
<pre><code class="language-plain_text">class PopoverViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        /// 设置呈现大小
        self.preferredContentSize = CGSize(width: 400, height: 400)
    }
}
</code></pre>
<p>以上设置,如果是iPhone的话,模态弹出视图,popover属性就会被忽略.iPad则会Popover弹出</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402961927.html">UIBezierPath</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>由于Stack Overflow中Documentation将要关闭,所以我将部分内容转载至这里</p>
</blockquote>
<p>##<a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/13624/designing-and-drawing-a-bezier-path">Designing and drawing a Bezier Path</a></p>
<p>This example shows the process from designing the shape you want to drawing it on a view. A specific shap is used but the concepts you learn can be applied to any shape.</p>
<h3><a id="how-to-draw-a%C2%A0-b%C3%A9zier-path-https-developer-apple-comlibraryiosdocumentation2ddrawingconceptualdrawingprintingiosbezierpathsbezierpaths-html%C2%A0-in-a-custom-view" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to draw a <a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/BezierPaths/BezierPaths.html">Bézier path</a> in a custom view</h3>
<p>These are the main steps:</p>
<ol>
<li>Design the outline of the shape you want.</li>
<li>Divide the outline path into segments of lines, arcs, and curves.</li>
<li>Build that path programmatically.</li>
<li>Draw the path either in <code>drawRect</code> or using a <code>CAShapeLayer</code>.</li>
</ol>
<h3><a id="design-shape-outline" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design shape outline</h3>
<p>You could do anything, but as an example I have chosen the shape below. It could be a popup key on a keyboard.</p>
<p><a href="media/15036524793322/geckR.png"><img src="media/16587402961927/geckR.png" alt="enter image description here" /></a></p>
<h3><a id="divide-the-path-into-segments" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Divide the path into segments</h3>
<p>Look back at your shape design and break it down into simpler elements of lines (for straight lines), arcs (for circles and round corners), and curves (for anything else).</p>
<p>Here is what our example design would look like:</p>
<p><a href="media/15036524793322/4mkcI.png"><img src="media/16587402961927/4mkcI.png" alt="enter image description here" /></a></p>
<ul>
<li>Black are line segments</li>
<li>Light blue are arc segments</li>
<li>Red are curves</li>
<li>Orange dots are the control points for the curves</li>
<li>Green dots are the points between path segments</li>
<li>Dotted lines show the bounding rectangle</li>
<li>Dark blue numbers are the segments in the order that they will be added programmatically</li>
</ul>
<h3><a id="build-the-path-programmatically" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Build the path programmatically</h3>
<p>We'll arbitrarily start in the bottom left corner and work clockwise. I'll use the grid in the image to get the x and y values for the points. I'll hardcode everything here, but of course you wouldn't do that in a real project.</p>
<p>The basic process is:</p>
<ol>
<li>Create a new <code>UIBezierPath</code></li>
<li>Choose a starting point on the path with <code>moveToPoint</code></li>
<li>Add segments to the path</li>
</ol>
<ul>
<li>line: <code>addLineToPoint</code></li>
<li>arc: <code>addArcWithCenter</code></li>
<li>curve: <code>addCurveToPoint</code></li>
</ul>
<ol>
<li>Close the path with <code>closePath</code></li>
</ol>
<p>Here is the code to make the path in the image above.</p>
<pre><code class="language-plain_text">func createBezierPath() -&gt; UIBezierPath {

    // create a new path
    let path = UIBezierPath()

    // starting point for the path (bottom left)
    path.moveToPoint(CGPoint(x: 2, y: 26))

    // *********************
    // ***** Left side *****
    // *********************

    // segment 1: line
    path.addLineToPoint(CGPoint(x: 2, y: 15))

    // segment 2: curve
    path.addCurveToPoint(CGPoint(x: 0, y: 12), // ending point
        controlPoint1: CGPoint(x: 2, y: 14),
        controlPoint2: CGPoint(x: 0, y: 14))

    // segment 3: line
    path.addLineToPoint(CGPoint(x: 0, y: 2))

    // *********************
    // ****** Top side *****
    // *********************

    // segment 4: arc
    path.addArcWithCenter(CGPoint(x: 2, y: 2), // center point of circle
        radius: 2, // this will make it meet our path line
        startAngle: CGFloat(M_PI), // π radians = 180 degrees = straight left
        endAngle: CGFloat(3*M_PI_2), // 3π/2 radians = 270 degrees = straight up
        clockwise: true) // startAngle to endAngle goes in a clockwise direction

    // segment 5: line
    path.addLineToPoint(CGPoint(x: 8, y: 0))

    // segment 6: arc
    path.addArcWithCenter(CGPoint(x: 8, y: 2),
        radius: 2,
        startAngle: CGFloat(3*M_PI_2), // straight up
        endAngle: CGFloat(0), // 0 radians = straight right
        clockwise: true)

    // *********************
    // ***** Right side ****
    // *********************

    // segment 7: line
    path.addLineToPoint(CGPoint(x: 10, y: 12))

    // segment 8: curve
    path.addCurveToPoint(CGPoint(x: 8, y: 15), // ending point
        controlPoint1: CGPoint(x: 10, y: 14),
        controlPoint2: CGPoint(x: 8, y: 14))

    // segment 9: line
    path.addLineToPoint(CGPoint(x: 8, y: 26))

    // *********************
    // **** Bottom side ****
    // *********************

    // segment 10: line
    path.closePath() // draws the final line to close the path

    return path
}
</code></pre>
<p>Note: Some of the above code can be reduced by adding a line and an arc in a single command (since the arc has an implied starting point). See <a href="http://ronnqvi.st/thinking-like-a-bzier-path/">here</a> for more details.</p>
<h3><a id="draw-the-path" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Draw the path</h3>
<p>We can draw the path either in a layer or in <code>drawRect</code>.</p>
<p><strong>Method 1: Draw path in a layer</strong></p>
<p>Our custom class looks like this. We add our Bezier path to a new <code>CAShapeLayer</code> when the view is initialized.</p>
<pre><code class="language-plain_text">import UIKit
class MyCustomView: UIView {

    override init(frame: CGRect) {
        super.init(frame: frame)
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    func setup() {

        // Create a CAShapeLayer
        let shapeLayer = CAShapeLayer()

        // The Bezier path that we made needs to be converted to 
        // a CGPath before it can be used on a layer.
        shapeLayer.path = createBezierPath().CGPath

        // apply other properties related to the path
        shapeLayer.strokeColor = UIColor.blueColor().CGColor
        shapeLayer.fillColor = UIColor.whiteColor().CGColor
        shapeLayer.lineWidth = 1.0
        shapeLayer.position = CGPoint(x: 10, y: 10)

        // add the new layer to our custom view
        self.layer.addSublayer(shapeLayer)
    }

    func createBezierPath() -&gt; UIBezierPath {

        // see previous code for creating the Bezier path
    }
}
</code></pre>
<p>And creating our view in the View Controller like this</p>
<pre><code class="language-plain_text">override func viewDidLoad() {
    super.viewDidLoad()

    // create a new UIView and add it to the view controller
    let myView = MyCustomView()
    myView.frame = CGRect(x: 100, y: 100, width: 50, height: 50)
    myView.backgroundColor = UIColor.yellowColor()
    view.addSubview(myView)

}
</code></pre>
<p>We get...</p>
<p><a href="media/15036524793322/oELys.png"><img src="media/16587402961927/oELys.png" alt="enter image description here" /></a></p>
<p>Hmm, that's a little small because I hardcoded all the numbers in. I can scale the path size up, though, like this:</p>
<pre><code class="language-plain_text">let path = createBezierPath()
let scale = CGAffineTransformMakeScale(2, 2)
path.applyTransform(scale)
shapeLayer.path = path.CGPath
</code></pre>
<p><a href="media/15036524793322/LXvPc.png"><img src="media/16587402961927/LXvPc.png" alt="enter image description here" /></a></p>
<p><strong>Method 2: Draw path in <code>drawRect</code></strong></p>
<p>Using <code>drawRect</code> is slower than drawing to the layer, so this is not the recommended method if you don't need it.</p>
<p>Here is the revised code for our custom view:</p>
<pre><code class="language-plain_text">import UIKit
class MyCustomView: UIView {

    override func drawRect(rect: CGRect) {

        // create path (see previous code)
        let path = createBezierPath()

        // fill
        let fillColor = UIColor.whiteColor()
        fillColor.setFill()

        // stroke
        path.lineWidth = 1.0
        let strokeColor = UIColor.blueColor()
        strokeColor.setStroke()

        // Move the path to a new location
        path.applyTransform(CGAffineTransformMakeTranslation(10, 10))

        // fill and stroke the path (always do these last)
        path.fill()
        path.stroke()

    }

    func createBezierPath() -&gt; UIBezierPath {

        // see previous code for creating the Bezier path
    }
}
</code></pre>
<p>which gives us the same result...</p>
<p><a href="media/15036524793322/2hqMa.png"><img src="media/16587402961927/2hqMa.png" alt="enter image description here" /></a></p>
<h3><a id="further-study" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Further study</h3>
<p>Excellent articles for understanding Bezier paths.</p>
<ul>
<li><a href="http://ronnqvi.st/thinking-like-a-bzier-path/">Thinking like a Bézier path</a> (Everything I've ever read from this author is good and the inspiration for my example above came from here.)</li>
<li><a href="https://www.youtube.com/watch?v=dXECQRlmIaE">Coding Math: Episode 19 - Bezier Curves</a> (entertaining and good visual illustrations)</li>
<li><a href="https://www.youtube.com/watch?v=Qu-QK3uoMdY">Bezier Curves</a> (how they are used in graphics applications)</li>
<li><a href="https://www.youtube.com/watch?v=2HvH9cmHbG4">Bezier Curves</a> (good description of how the mathematical formulas are derived)</li>
</ul>
<h3><a id="notes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notes</h3>
<ul>
<li>This example originally comes from <a href="http://stackoverflow.com/a/34659468/3681880">this Stack Overflow answer</a>.</li>
<li>In your actual projects you probably shouldn't use hard coded numbers, but rather get the sizes from your view's bounds.</li>
</ul>
<hr />
<h2><a id="how-to-apply-corner-radius-to-rectangles-drawn-by-uibezierpath-https-stackoverflow-comdocumentationios3186uibezierpath10890how-to-apply-corner-radius-to-rectangles-drawn-by-uibezierpath" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10890/how-to-apply-corner-radius-to-rectangles-drawn-by-uibezierpath">How to apply corner radius to rectangles drawn by UIBezierPath</a></h2>
<p><em>Corner radius for all 4 edges:</em></p>
<p><a href="media/15036524793322/O8qTg.png"><img src="media/16587402961927/O8qTg.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text"> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) cornerRadius: 11];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>
<p><em>Corner radius for top-left edge:</em></p>
<p><a href="media/15036524793322/OEOJa.png"><img src="media/16587402961927/OEOJa.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text"> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopLeft cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>
<p><em>Corner radius for top-right edge:</em></p>
<p><a href="media/15036524793322/1xhp8.png"><img src="media/16587402961927/1xhp8.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>
<p><em>corner radius for bottom-left edge:</em></p>
<p><a href="media/15036524793322/yqd87.png"><img src="media/16587402961927/yqd87.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomLeft cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>
<p><em>corner radius for bottom-right edge:</em></p>
<p><a href="media/15036524793322/AIgP0.png"><img src="media/16587402961927/AIgP0.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text"> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>
<p><em>corner radius for bottom edges:</em></p>
<p><a href="media/15036524793322/4BrrS.png"><img src="media/16587402961927/4BrrS.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>
<p><em>corner radius for top edges:</em></p>
<p><a href="media/15036524793322/lecWo.png"><img src="media/16587402961927/lecWo.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(x,y,width,height) byRoundingCorners: UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii: CGSizeMake(11, 11)];
[rectanglePath closePath];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>
<hr />
<p>##<a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10893/how-to-apply-shadows-to-uibezierpath">How to apply shadows to UIBezierPath</a></p>
<p>Consider a simple rectangle that is drawn by the bezier path.</p>
<p><a href="media/15036524793322/imDTW.png"><img src="media/16587402961927/imDTW.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text"> UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
 [UIColor.grayColor setFill];
 [rectanglePath fill];
</code></pre>
<p><em>Basic Outer-fill shadow:</em></p>
<p><a href="media/15036524793322/mqiIV.png"><img src="media/16587402961927/mqiIV.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">CGContextRef context = UIGraphicsGetCurrentContext();

NSShadow* shadow = [[NSShadow alloc] init];
[shadow setShadowColor: UIColor.blackColor];
[shadow setShadowOffset: CGSizeMake(7.1, 5.1)];
[shadow setShadowBlurRadius: 5];

UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
CGContextSaveGState(context);
CGContextSetShadowWithColor(context, shadow.shadowOffset, shadow.shadowBlurRadius, [shadow.shadowColor CGColor]);
[UIColor.grayColor setFill];
[rectanglePath fill];
CGContextRestoreGState(context);
</code></pre>
<p><em>Basic Inner fill shadow:</em></p>
<p><a href="media/15036524793322/C1rZk.png"><img src="media/16587402961927/C1rZk.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">CGContextRef context = UIGraphicsGetCurrentContext();

NSShadow* shadow = [[NSShadow alloc] init];
[shadow setShadowColor: UIColor.blackColor];
[shadow setShadowOffset: CGSizeMake(9.1, -7.1)];
[shadow setShadowBlurRadius: 6];

UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(x,y,width,height)];
[UIColor.grayColor setFill];
[rectanglePath fill];

CGContextSaveGState(context);
UIRectClip(rectanglePath.bounds);
CGContextSetShadowWithColor(context, CGSizeZero, 0, NULL);

CGContextSetAlpha(context, CGColorGetAlpha([shadow.shadowColor CGColor]));
CGContextBeginTransparencyLayer(context, NULL);
{
    UIColor* opaqueShadow = [shadow.shadowColor colorWithAlphaComponent: 1];
    CGContextSetShadowWithColor(context, shadow.shadowOffset, shadow.shadowBlurRadius, [opaqueShadow CGColor]);
    CGContextSetBlendMode(context, kCGBlendModeSourceOut);
    CGContextBeginTransparencyLayer(context, NULL);

    [opaqueShadow setFill];
    [rectanglePath fill];

    CGContextEndTransparencyLayer(context);
}
CGContextEndTransparencyLayer(context);
CGContextRestoreGState(context);
</code></pre>
<p>##<a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10891/how-to-create-a-simple-shapes-using-uibezierpath">How to create a simple shapes using UIBezierPath</a><br />
<em>For a simple circle:</em></p>
<p><a href="media/15036524793322/ymoay.png"><img src="media/16587402961927/ymoay.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">UIBezierPath* ovalPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(0,0,50,50)];
[UIColor.grayColor setFill];
[ovalPath fill];
</code></pre>
<p>Swift:</p>
<pre><code class="language-plain_text">let ovalPath = UIBezierPath(ovalInRect: CGRect(x: 0, y: 0, width: 50, height: 50))
UIColor.grayColor().setFill()
ovalPath.fill()
</code></pre>
<p><em>For a simple Rectangle:</em></p>
<p><a href="media/15036524793322/C1GFH.png"><img src="media/16587402961927/C1GFH.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(0,0,50,50)];
[UIColor.grayColor setFill];
[rectanglePath fill];
</code></pre>
<p>Swift:</p>
<pre><code class="language-plain_text">let rectanglePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 50, height: 50))
UIColor.grayColor().setFill()
rectanglePath.fill()
</code></pre>
<p><em>For a simple Line:</em></p>
<p><a href="media/15036524793322/KIAOK.png"><img src="media/16587402961927/KIAOK.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">UIBezierPath* bezierPath = [UIBezierPath bezierPath];
[bezierPath moveToPoint: CGPointMake(x1,y1)];
[bezierPath addLineToPoint: CGPointMake(x2,y2)];
[UIColor.blackColor setStroke];
bezierPath.lineWidth = 1;
[bezierPath stroke];
</code></pre>
<p>Swift:</p>
<pre><code class="language-plain_text">let bezierPath = UIBezierPath()
bezierPath.moveToPoint(CGPoint(x: x1, y: y1))
bezierPath.addLineToPoint(CGPoint(x: x2, y: y2))
UIColor.blackColor().setStroke()
bezierPath.lineWidth = 1
bezierPath.stroke()
</code></pre>
<p><em>For a half circle:</em></p>
<p><a href="media/15036524793322/3Nywj.png"><img src="media/16587402961927/3Nywj.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text"> CGRect ovalRect = CGRectMake(x,y,width,height);
UIBezierPath* ovalPath = [UIBezierPath bezierPath];
[ovalPath addArcWithCenter: CGPointMake(0, 0) radius: CGRectGetWidth(ovalRect) / 2 startAngle: 180 * M_PI/180 endAngle: 0 * M_PI/180 clockwise: YES];
[ovalPath addLineToPoint: CGPointMake(0, 0)];
[ovalPath closePath];

CGAffineTransform ovalTransform = CGAffineTransformMakeTranslation(CGRectGetMidX(ovalRect), CGRectGetMidY(ovalRect));
ovalTransform = CGAffineTransformScale(ovalTransform, 1, CGRectGetHeight(ovalRect) / CGRectGetWidth(ovalRect));
[ovalPath applyTransform: ovalTransform];

[UIColor.grayColor setFill];
[ovalPath fill];
</code></pre>
<p>Swift:</p>
<pre><code class="language-plain_text">let ovalRect = CGRect(x: 0, y: 0, width: 50, height: 50)
let ovalPath = UIBezierPath()
ovalPath.addArcWithCenter(CGPoint.zero, radius: ovalRect.width / 2, startAngle: 180 * CGFloat(M_PI)/180, endAngle: 0 * CGFloat(M_PI)/180, clockwise: true)
ovalPath.addLineToPoint(CGPoint.zero)
ovalPath.closePath()

var ovalTransform = CGAffineTransformMakeTranslation(CGRectGetMidX(ovalRect), CGRectGetMidY(ovalRect))
ovalTransform = CGAffineTransformScale(ovalTransform, 1, ovalRect.height / ovalRect.width)
ovalPath.applyTransform(ovalTransform)

UIColor.grayColor().setFill()
ovalPath.fill()
</code></pre>
<p><em>For a simple triangle:</em></p>
<p><a href="media/15036524793322/5r6IE.png"><img src="media/16587402961927/5r6IE.png" alt="enter image description here" /></a></p>
<pre><code class="language-plain_text">UIBezierPath* polygonPath = [UIBezierPath bezierPath];
[polygonPath moveToPoint: CGPointMake(x1, y1)];
[polygonPath addLineToPoint: CGPointMake(x2, y2)];
[polygonPath addLineToPoint: CGPointMake(x3, y2)];
[polygonPath closePath];
[UIColor.grayColor setFill];
[polygonPath fill];
</code></pre>
<p>Swift:</p>
<pre><code class="language-plain_text">let polygonPath = UIBezierPath()
polygonPath.moveToPoint(CGPoint(x: x1, y: y1))
polygonPath.addLineToPoint(CGPoint(x: x2, y: y2))
polygonPath.addLineToPoint(CGPoint(x: x3, y: y3))
polygonPath.closePath()
UIColor.grayColor().setFill()
polygonPath.fill()
</code></pre>
<hr />
<p>##<a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/18109/pie-view-column-view-with-uibezierpath">pie view &amp; column view with UIBezierPath</a></p>
<ul>
<li>pie view<br />
<img src="media/16587402961927/oh0DL.png" alt="pie view" /></li>
</ul>
<pre><code class="language-plain_text">- (void)drawRect:(CGRect)rect {

    NSArray *data = @[@30, @15, @5, @17, @3, @10, @20];

    // 1\. context
    CGContextRef cxtRef = UIGraphicsGetCurrentContext();

    CGPoint center = CGPointMake(150, 150);
    CGFloat radius = 150;
    __block CGFloat startAngle = 0;
    [data enumerateObjectsUsingBlock:^(NSNumber * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {

        // 2\. create path
        CGFloat endAngle = obj.floatValue / 100 * M_PI * 2 + startAngle;
        UIBezierPath *circlePath = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startAngle endAngle:endAngle clockwise:YES];
        [circlePath addLineToPoint:center];

        // 3\. add path
        CGContextAddPath(cxtRef, circlePath.CGPath);

        // set color
        [[UIColor colorWithRed:((float)arc4random_uniform(256) / 255.0) green:((float)arc4random_uniform(256) / 255.0) blue:((float)arc4random_uniform(256) / 255.0) alpha:1.0] setFill];

        // 4\. render
        CGContextDrawPath(cxtRef, kCGPathFill);

        // reset angle
        startAngle = endAngle;
    }];
}


override func draw(_ rect: CGRect) {
    // define data to create pie chart
    let data: [Int] = [30, 15, 5, 17, 3, 10, 20]

    // 1\. find center of draw rect
    let center: CGPoint = CGPoint(x: rect.midX, y: rect.midY)

    // 2\. calculate radius of pie
    let radius = min(rect.width, rect.height) / 2.0

    var startAngle: CGFloat = 0.0
    for value in data {

      // 3\. calculate end angle for slice
      let endAngle = CGFloat(value) / 100.0 * CGFloat.pi * 2.0 + startAngle

      // 4\. create UIBezierPath for slide
      let circlePath = UIBezierPath(arcCenter: center, radius: radius, startAngle: startAngle, endAngle: endAngle, clockwise: true)

      // 5\. add line to center to close path
      circlePath.addLine(to: center)

      // 6\. set fill color for current slice
      UIColor(red: (CGFloat(arc4random_uniform(256)) / 255.0), green: (CGFloat(arc4random_uniform(256)) / 255.0), blue: (CGFloat(arc4random_uniform(256)) / 255.0), alpha: 1.0).setFill()

      // 7\. fill slice path
      circlePath.fill()

      // 8\. set end angle as start angle for next slice
      startAngle = endAngle
    }
  }
</code></pre>
<ul>
<li>column view<br />
<img src="media/16587402961927/ayD5Y.png" alt="column view" /></li>
</ul>
<pre><code class="language-plain_text">- (void)drawRect:(CGRect)rect {

    NSArray *data = @[@300, @150.65, @55.3, @507.7, @95.8, @700, @650.65];

    // 1.
    CGContextRef cxtRef = UIGraphicsGetCurrentContext();

    NSInteger columnCount = 7;
    CGFloat width = self.bounds.size.width / (columnCount + columnCount - 1);
    for (NSInteger i = 0; i 

override func draw(_ rect: CGRect) {
    // define data for chart
    let data: [CGFloat] = [300, 150.65, 55.3, 507.7, 95.8, 700, 650.65]

    // 1\. calculate number of columns
    let columnCount = data.count

    // 2\. calculate column width
    let columnWidth = rect.width / CGFloat(columnCount + columnCount - 1)

    for (columnIndex, value) in data.enumerated() {
      // 3\. calculate column height
      let columnHeight = value / 1000.0 * rect.height

      // 4\. calculate column origin
      let columnOrigin = CGPoint(x: (columnWidth * 2.0 * CGFloat(columnIndex)), y: (rect.height - columnHeight))

      // 5\. create path for column
      let columnPath = UIBezierPath(rect: CGRect(origin: columnOrigin, size: CGSize(width: columnWidth, height: columnHeight)))

      // 6\. set fill color for current column
      UIColor(red: (CGFloat(arc4random_uniform(256)) / 255.0), green: (CGFloat(arc4random_uniform(256)) / 255.0), blue: (CGFloat(arc4random_uniform(256)) / 255.0), alpha: 1.0).setFill()

      // 7\. fill column path
      columnPath.fill()
    }
  }
</code></pre>
<hr />
<p>##<a href="https://stackoverflow.com/documentation/ios/3186/uibezierpath/10892/uibezierpath-autolayout">UIBezierPath + AutoLayout</a></p>
<p>For bezier path to get resized based on the view frame, override the drawRect of view that you are drawing the bezier path :</p>
<pre><code class="language-plain_text">- (void)drawRect:(CGRect)frame
{
    UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(frame), CGRectGetWidth(frame), CGRectGetHeight(frame))];
    [UIColor.grayColor setFill];
    [rectanglePath fill];
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402962421.html">C++Primer笔记 - 初识输入输出</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>使用<code>iostream</code>库.<code>iostream</code>中包含两个基础类型<code>istream</code>和<code>ostream</code>,分别表示输入流和输出流<br />
##标准输入输出对象<br />
标准库中定义了4个IO对象.为了处理输入,我们使用了一个名为<code>cin</code>的<code>istream</code>类型的对象.这个对象也被称为<strong>标准输入</strong>.对于输出,我们使用一个名为<code>cout</code>的<code>ostream</code>类型的对象.此对象也被称为<strong>标准输出</strong>.标准库中还定义了其他两个<code>ostream</code>对象,名为<code>cerr</code>和<code>clog</code>.我们通常用<code>cerr</code>来输出警告和错误信心,因此它也被称为<strong>标准错误</strong>,而<code>clog</code>用来输出程序运行时的一般性信息.</p>
</blockquote>
<p>系统通常将程序所运行的窗口与这些对象关联起来.因此,当我们读取cin,数据将从程序正在运行的窗口读入,当我们像cout,cerr,clog写入数据的时候,将会写到同一个窗口.</p>
<p>##Demo</p>
<pre><code class="language-plain_text">#include &lt;iostream&gt;
using namespace std;

int main(int argc, char *argv[])
{
    std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;
    int v1 = 0, v2 = 0;
    std::cin &gt;&gt; v1 &gt;&gt; v2;
    std::cout &lt;&lt; &quot;The sun of &quot; &lt;&lt; v1 &lt;&lt; &quot;and&quot; &lt;&lt; v2 &lt;&lt; &quot;is&quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;
    return 0;
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402962631.html">设计模式 读书笔记</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##单一职责原则(Single Responsibility Principe 简称SRP)</p>
<blockquote>
<p>定义: 应该有且仅有一个原因引起类的变更..</p>
</blockquote>
<p>###对职责的定义,什么是类的职责,以及怎么划分类的职责.<br />
图书中 &lt;图1-1用户信息IUserInfo位图类图&gt; 中设计的有问题:<br />
用户的属性和用户的行为没有分开,这是一个严重的错误.. 应该把用户的信息抽取成一个BO(Bussiness Object,业务对象),把行为抽取成一个Biz(Bussiness Logic,业务逻辑)</p>
<p>重新拆封成两个接口. IUserBO 负责用户的属性,简单的说就是收集和反馈用户的属性信息.IUserBiz负责用户的行为,完成用户信息的维护和变更.<br />
###好处</p>
<ol>
<li>类的复杂性降低.实现什么职责都有清晰明确的定义了;</li>
<li>可读性提高.复杂性降低,当然可读性提高了;</li>
<li>可维护性提高.可读性提高,那当然更容易维护了;</li>
<li>变更引起的风险降低,变更时必不可少的.如果接口的单一职责做的好,一个接口的修改只对相应的实现类有影响,对其他的接口无影响,这对系统的扩展性和维护性都有非常大的帮助.</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402962834.html">数组传递</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>把A控制器中的数组 传递给 B  ,然后 B 再把数据传递给 C<br />
这时如果 A中数组进行了修改,那么 C 中数据也会修改</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402963047.html">const,static,extern简介</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3><a id="%E4%B8%80%E3%80%81const%E4%B8%8E%E5%AE%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、const与宏的区别（面试题）:</h3>
<ul>
<li>
<p><code>const简介</code>:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</p>
<ul>
<li><code>编译时刻</code>:宏是预编译（编译之前处理），const是编译阶段。</li>
<li><code>编译检查</code>:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
<li><code>宏的好处</code>:宏能定义一些函数，方法。 const不能。</li>
<li><code>宏的坏处</code>:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>
<p>注意:很多Blog都说使用宏，会消耗很多内存. define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，<strong>变量定义</strong>分配内存。）<br />
<img src="media/16587402963047/14719323806994.jpg" alt="" /></p>
<p><img src="media/16587402963047/14719331536266.jpg" alt="" /></p>
</li>
</ul>
<p>产生上述问题的原因:可以查看<a href="https://www.zhihu.com/question/29662431">知乎</a>上面的回答,可以简单理解为编译器优化.</p>
<pre><code class="language-plain_text">// 常见的常量：抽成宏
#define MKAccount @&quot;account&quot;

#define MKUserDefault [NSUserDefaults standardUserDefaults]

// 字符串常量
static NSString * const account = @&quot;account&quot;;

- (void)viewDidLoad {
    [super viewDidLoad];

    // 偏好设置存储
    // 使用宏
    [MKUserDefault setValue:@&quot;123&quot; forKey:MKAccount];

    // 使用const常量
    [[NSUserDefaults standardUserDefaults] setValue:@&quot;123&quot; forKey:account];

}

</code></pre>
<h3><a id="%E4%BA%8C%E3%80%81const%E4%BD%9C%E7%94%A8%EF%BC%9A%E9%99%90%E5%88%B6%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、const作用：限制类型</h3>
<ul>
<li>
<p>1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</p>
</li>
<li>
<p>2.被const修饰的变量是只读的。</p>
</li>
<li>
<p><code>const基本使用</code></p>
</li>
</ul>
<pre><code class="language-plain_text">- (void)viewDidLoad {
    [super viewDidLoad];

    // 定义变量
    int a = 1;

    // 允许修改值
    a = 20;

    // const两种用法
    // const:修饰基本变量p
    // 这两种写法是一样的，const只修饰右边的基本变量b
    const int b = 20; // b:只读变量
    int const b = 20; // b:只读变量

    // 不允许修改值
    b = 1;

    // const:修饰指针变量*p，带*的变量，就是指针变量.
    // 定义一个指向int类型的指针变量，指向a的地址
    int *p = &amp;a;

    int c = 10;

    p = &amp;c;

    // 允许修改p指向的地址，
    // 允许修改p访问内存空间的值
    *p = 20;

    // const修饰指针变量访问的内存空间，修饰的是右边*p1，
    // 两种方式一样
    const int *p1; // *p1：常量 p1:变量
    int const *p1; // *p1：常量 p1:变量

    // const修饰指针变量p1
    int * const p1; // *p1:变量 p1:常量

    // 第一个const修饰*p1 第二个const修饰 p1
    // 两种方式一样
    const int * const p1; // *p1：常量 p1：常量

    int const * const p1;  // *p1：常量 p1：常量

}

</code></pre>
<h3><a id="%E4%B8%89%E3%80%81const%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、const开发中使用场景:</h3>
<ul>
<li>1.当一个方法参数只读</li>
<li>2.定义只读全局变量</li>
</ul>
<pre><code class="language-plain_text">@implementation ViewController

// 定义只读全局常量
NSString * const str  = @&quot;123&quot;;

// 当一个方法的参数，只读.
- (void)test:(NSString * const)name
{

}

// 指针只读,不能通过指针修改值
- (void)test1:(int const *)a{

//    *a = 10;
}

// 基本数据类型只读
- (void)test2:(int const)a{

}

@end

</code></pre>
<h3><a id="%E5%9B%9B%E3%80%81static%E5%92%8Cextern%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%8C%E5%85%88%E4%BA%86%E8%A7%A3%E5%85%B6%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、static和extern简单使用(要使用一个东西，先了解其作用)</h3>
<ul>
<li>
<p><code>static作用</code>:</p>
<ul>
<li>
<p>修饰局部变量：</p>
<p>1.延长局部变量的生命周期,程序结束才会销毁。</p>
<p>2.局部变量只会生成一份内存,只会初始化一次。</p>
</li>
<li>
<p>修饰全局变量</p>
<p>1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改</p>
</li>
</ul>
</li>
<li>
<p><code>extern作用</code>:</p>
<ul>
<li>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</li>
</ul>
</li>
<li>
<p><code>extern工作原理</code>:</p>
<ul>
<li>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</li>
</ul>
</li>
</ul>
<pre><code class="language-plain_text">// 全局变量：只有一份内存，所有文件共享，与extern联合使用。
int a = 20;

// static修饰全局变量
static int age = 20;

- (void)test
{
    // static修饰局部变量
    static int age = 0;
    age++;
    NSLog(@&quot;%d&quot;,age);
}

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    [self test];
    [self test];

    extern int age;
    NSLog(@&quot;%d&quot;,age);
}
I

</code></pre>
<h3><a id="%E4%BA%94%E3%80%81static%E4%B8%8Econst%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、static与const联合使用</h3>
<ul>
<li>static与const作用:声明一个只读的静态变量</li>
<li>开发使用场景:在<code>一个文件中</code>经常使用的字符串常量，可以使用static与const组合</li>
</ul>
<pre><code class="language-plain_text">// 开发中常用static修饰全局变量,只改变作用域

// 为什么要改变全局变量作用域，防止重复声明全局变量。

// 开发中声明的全局变量，有些不希望外界改动，只允许读取。

// 比如一个基本数据类型不希望别人改动

// 声明一个静态的全局只读常量
static const int a = 20;

// staic和const联合的作用:声明一个静态的全局只读常量

// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.

// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。
static  NSString * const key = @&quot;name&quot;;

// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。

static  NSString const *key1 = @&quot;name&quot;;

</code></pre>
<h3><a id="%E5%85%AD%E3%80%81extern%E4%B8%8Econst%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>六、extern与const联合使用</h3>
<ul>
<li>
<p>开发中使用场景:在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用extern与const组合。</p>
</li>
<li>
<p>原因:</p>
<ul>
<li>static与const组合：在每个文件都需要定义一份静态全局变量。</li>
<li>extern与const组合:只需要定义一份全局变量，多个文件共享。</li>
</ul>
</li>
<li>
<p>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</p>
</li>
<li>
<p>GlobeConst.h</p>
</li>
</ul>
<pre><code class="language-plain_text">/*******************************首页****************************/

extern NSString * const nameKey = @&quot;name&quot;;

/*******************************首页****************************/

</code></pre>
<ul>
<li>GlobeConst.m</li>
</ul>
<pre><code class="language-plain_text">#import 

/*******************************首页****************************/

NSString * const nameKey = @&quot;name&quot;;

/*******************************首页****************************/
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402963262.html">vim</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>r替换当前光标下的字符<br />
dd 删除当前行<br />
u 撤销<br />
:w 报错<br />
:q 退出<br />
a:追加<br />
i:插入</p>
<p>查找对应的字符: / 加上字符<br />
加上行号: :set nu</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402963475.html">Java语言特点</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##面向对象性：</p>
<p>两个要素： 类，对象<br />
三个特征：封装，继承，多态</p>
<p>##健壮性：</p>
<ol>
<li>去除了C语言中的指针</li>
<li>自动的垃圾回收机制--》 仍然会出现内存溢出，内存泄漏</li>
</ol>
<p>##跨平台性：</p>
<ol>
<li>write once，run anywhere: 一次编译到处运行</li>
<li>归功于JVM</li>
</ol>
<p>##JDK，JRE，JVM之间的关系<br />
JDK = JRE + 开发工具集（例如Javac编译工具等）<br />
JRE = JVM + JavaSE 标准类库</p>
<h2><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%85%8D%E7%BD%AEpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么配置 PATH 环境变量</h2>
<p>path 环境变量: windows操作系统执行命令时所要搜寻的路径<br />
为什么要配置path：希望Java的开发工具（javac.exe,java.exe）在任何的文件路径下都可以执行成功</p>
<h2><a id="%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何配置</h2>
<p>path: D:\developer_tools\Java\jdk1.8.0_131\bin   --&gt; %JAVA_HOME%\bin<br />
JAVA_HOME = D:\developer_tools\Java\jdk1.8.0_131</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402963923.html">关于网络请求的封装</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>微指3.0版本使用的是 <code>MKRequestManager</code> 微指 new 中使用的是基于 AOP 封装的网络请求.这里介绍3.0版本网络请求的基本用法</p>
<p>##项目中绝大部分使用的是</p>
<pre><code class="language-Objective-C">/**
 * 普通post方法请求网络数据
 *
 * @param url 请求网址路径
 * @param params 请求参数
 * @param success 成功回调
 * @param fail 失败回调
 */

- (void)POST:(NSString *)url
 params:(NSDictionary *)params
 success:(MKResponseSuccess)success
 fail:(MKResponseFail)fail;

</code></pre>
<p>还有一个带有唯一标识的网络请求:</p>
<pre><code class="language-Objective-C">/**
 * 签名post方法请求网络数据
 *
 * @param url 请求网址路径
 * @param params 请求参数
 * @param securityPolicy 唯一标识符
 * @param success 成功回调
 * @param fail 失败回调
 */

- (void)POST:(NSString *)url
 params:(NSDictionary *)params
 securityPolicy:(NSString *)securityPolicy
 success:(MKResponseSecurityPolicySuccess)success
 fail:(MKResponseSecurityPolicyFail)fail;

</code></pre>
<p>##文件上传(主要是图片文件怎么上传)</p>
<pre><code class="language-Objective-C">/**
 * 普通路径上传文件
 *
 * @param url 请求网址路径
 * @param params 请求参数
 * @par![am files 文件数组](/assets/Snip20161103_7.png)
 * @param progress 上传进度
 * @param success 成功回调
 * @param fail 失败回调
 */

- (void)uploadWithURL:(NSString *)url
 params:(NSDictionary *)params
 files:(NSArray *)files
 progress:(MKProgress)progress
 success:(MKResponseSuccess)success
 fail:(MKResponseFail)fail;
</code></pre>
<p>这是上传文件的网络封装,文件封装如下:</p>
<pre><code class="language-Objective-C">interface MKHttpFile : NSObject
/** 文件参数名(key) */
@property (nonatomic, copy) NSString *name;
/** 文件数据 */
@property (nonatomic, strong) NSData *data;
/** 文件类型 */
@property (nonatomic, copy) NSString *mimeType;
/** 文件名 */
@property (nonatomic, copy) NSString *filename;
+ (instancetype)fileWithName:(NSString *)name
 data:(NSData *)data
 mimeType:(NSString *)mimeType
 filename:(NSString *)filename;

@end
</code></pre>
<p>具体的使用方法:<br />
这里简单摘录<code>WZMyInfoViewController</code>中头像上传的代码:</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402964126.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##关于对象方法与类方法</p>
<pre><code class="language-plain_text">@interface NSObject (Sark)
+ (void)foo;
@end

@implementation NSObject (Sark)

- (void)foo
{
    NSLog(@&quot;IMP: -[NSObject (Sark) foo]&quot;);
}
@end
</code></pre>
<p>如果这样调用会怎样?</p>
<pre><code class="language-plain_text">    [NSObject foo];
    [[NSObject new] foo];
</code></pre>
<p><img src="media/16587402964126/14736082339119.jpg" alt="" /></p>
<h2><a id="%E7%BB%A7%E7%BB%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继续</h2>
<pre><code class="language-plain_text">- (id)copy;
</code></pre>
<p>我们不能能这么调用</p>
<pre><code class="language-plain_text">[NSObject copy];
</code></pre>
<p>还有</p>
<p><img src="media/16587402964126/14736087569353.jpg" alt="" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402964521.html">联系方式</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>手机：15633396400</li>
<li>Email：<a href="mailto:hiccer@126.com">hiccer@126.com</a></li>
</ul>
<h1><a id="%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>个人信息</h1>
<ul>
<li>李小争/男/1990</li>
<li>本科/软件工程</li>
<li>工作年限：6 年 iOS开发 1年 C#开发</li>
<li>技术博客：<a href="http://lxzzzzzz.github.io/Blog">http://lxzzzzzz.github.io/Blog</a></li>
<li>Github：<a href="http://github.com/lxzzzzzz">http://github.com/lxzzzzzz</a></li>
</ul>
<h1><a id="%E5%B7%A5%E4%BD%9C%E7%BB%8F%E5%8E%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作经历</h1>
<h2><a id="%E7%BA%A2%E7%81%AB%E5%8F%B0%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80%E5%85%AC%E5%8F%B8%E7%94%A8%E5%8F%8B%E9%A4%90%E9%A5%AE%E4%BA%91%EF%BC%882016%E5%B9%B4-11%E6%9C%88%E4%BB%8A%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>红火台网络科技公司 (用友餐饮云) （ 2016 年 11 月 ~ 今 ）</h2>
<h3><a id="%E6%B5%B7%E5%BA%95%E6%8D%9Eipad%E7%82%B9%E9%A4%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>海底捞 iPad 点餐</h3>
<p>项目初期负责主体框架搭建，负责点菜列表，点锅页面，菜品下单，鉴权等操作.后期所有功能的开发和维护。项目特点如下:</p>
<ol>
<li>
<p>为混编项目，视频监控等功能是 C&amp;C++的三方库，通过 Objective-C 和 Swift 桥接起来.</p>
</li>
<li>
<p>项目点菜列表页显示大量图片&amp;标签，需要支持 iPad 2 等比较老的设备.菜品列表滚动优化</p>
</li>
<li>
<p>权限控制，页面跳转控制，屏保设置，国际化等</p>
</li>
<li>
<p>数据加密压缩传输</p>
</li>
<li>
<p>多服务支持，iPad端同时支持天子星后台和红火台后台</p>
</li>
<li>
<p>锅底页面大量使用手势操作锅底 (万柳店DIY功能)</p>
<p>总结: 点菜列表页经过优化，滑动效果在 iPad 2 上优于淘宝京东等 App。视频监控可以做到兼容海康威视 &amp; 宇视两家视频监控厂商的各型号设备，支持 NVR 模式 &amp; IP 直连。</p>
</li>
</ol>
<h3><a id="%E7%BA%A2%E7%81%AB%E5%8F%B0app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>红火台 App</h3>
<p>红火台点餐分为用户版&amp;商户版。项目有园区版本和对外版本，该项目主要是预约点餐&amp;堂食。预约点餐是手机端点菜下单类似于美团点菜。堂食分为主扫和被扫。主扫是通过扫描二维码支付，被扫是生成付款码 (餐补，部门卡，活动卡，临时卡等) 扫码枪扫二维码支付。项目特点如下:</p>
<ol>
<li>显示信息由后台配置，移动端根据配置显示对应数据</li>
<li>食堂的信号不是很好所以支付信息等通过 WebSocket 进行状态传递用定时轮询做补充</li>
<li>订单待支付状态显示，代付款的订单需要显示倒计时，优化列表中多个倒计时显示效果</li>
</ol>
<h3><a id="%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他项目</h3>
<p>负责的项目还有</p>
<ol>
<li>催单 App: 主要是推送服务，根据推送跳转不同的功能页面</li>
<li>智能供应链: 登录后根据角色显示不同的页面&amp;功能，页面主要功能点是订单的展示和修改。</li>
<li>红火台 iPad 点餐: 基本原理同海底捞点餐。不同点是默认进入吧台模式，适合门店 iPad 较少的情况。</li>
<li>Hi捞送: 海底捞自己的配送App，支持取餐和配送。主要使用高德地图展示路径规划，和UIControl 模拟iOS4的侧滑接单通过<code>beginTracking</code> <code>continueTracking</code> <code>endTracking</code> 判断滑动位置和状态修改。</li>
</ol>
<h2><a id="%E5%BE%AE%E6%8C%87%EF%BC%88%E4%B8%8A%E6%B5%B7%EF%BC%89%E4%BF%A1%E6%81%AF%E7%A7%91%E6%8A%80%E8%82%A1%E4%BB%BD%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8%EF%BC%882014%E5%B9%B4-10%E6%9C%88-2016%E5%B9%B4-11%E6%9C%88%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>微指（上海）信息科技股份有限公司 （ 2014 年 10 月 ~ 2016 年 11 月 ）</h2>
<h3><a id="%E5%BE%AE%E6%8C%87%E7%94%A8%E6%88%B7%E7%89%88%E5%95%86%E6%88%B7%E7%89%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>微指用户版&amp;商户版</h3>
<p>主要负责项目架构，使用 Objective-C 编写。LBS 类 App，负责功能有:首页附近商户，聊天 (Socket) 等功能。根据地理位置展示附近商户。主要功能点:</p>
<ol>
<li>
<p>定位，采集端使用百度地图，用户端使用高德地址，通过火星坐标转换显示对应的位置</p>
</li>
<li>
<p>聊天，使用 Socket 进行通讯，内容包括文字图片等信息。</p>
</li>
<li>
<p>商户详情页面，Hybrid(原生&amp;H5 混合开发) 形式展示内容</p>
</li>
</ol>
<h1><a id="%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开源贡献</h1>
<h2><a id="%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开源项目</h2>
<ul>
<li><a href="https://Github.com/line/line-sdk-ios-swift">line-sdk-ios-swift</a>：学习 LineSDK 的时候参与修改部分代码</li>
<li><a href="https://Github.com/ChenYilong/iOS9AdaptationTips">iOS9AdaptationTips</a>：提交 Issues，奉献一些自己遇到并解决的问题</li>
</ul>
<h1><a id="%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>技能清单</h1>
<p>以下均为我熟练使用的技能</p>
<ul>
<li>
<p>编程语言: Swift/Objective-C</p>
</li>
<li>
<p>框架：Kingfisher/Moya/PromiseKit</p>
</li>
<li>
<p>数据库相关：MySQL/SQLite</p>
</li>
<li>
<p>版本管理：SVN/Git</p>
</li>
<li>
<p>了解RunLoop、Runtime、GCD等</p>
</li>
</ul>
<p>以下为了解能写简单功能的技能:</p>
<ul>
<li>
<p>编程语言: Java/HTML+JavaScript</p>
</li>
<li>
<p>框架: Vue/ElementUI</p>
<p>​</p>
</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402964722.html">升级到Xcode8后Qt无法正常使用</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>错误信息:</p>
<blockquote>
<p>Project ERROR: Xcode not set up properly. You may need to confirm the license agreement by running /usr/bin/xcodebuild.</p>
</blockquote>
<p>解决办法:<br />
<strong>&gt;= Xcode 8</strong></p>
<p>In Xcode 8, as Bruce said, this happens when Qt tries to find <code>xcrun</code> when it should be looking for <code>xcodebuild</code>.</p>
<p><strong>Step 1:</strong></p>
<p>Open the file:</p>
<pre><code class="language-plain_text">Qt_install_folder/5.7/clang_64/mkspecs/features/mac/default_pre.prf
</code></pre>
<p><strong>Step 2:</strong></p>
<p>Replace:</p>
<pre><code class="language-plain_text">isEmpty($$list($$system(&quot;/usr/bin/xcrun -find xcrun 2&gt;/dev/null&quot;)))
</code></pre>
<p>With:</p>
<pre><code class="language-plain_text">isEmpty($$list($$system(&quot;/usr/bin/xcrun -find xcodebuild 2&gt;/dev/null&quot;)))
</code></pre>
<p><strong>~&gt; Xcode 8</strong></p>
<p>Before Xcode 8, this problem occurs when command line tools are installed after Xcode is installed. What happens is the <code>Xcode-select</code> developer directory gets pointed to <code>/Library/Developer/CommandLineTools</code>.</p>
<p><strong>Step 1:</strong></p>
<p>Point <code>Xcode-select</code> to the correct Xcode Developer directory with the command:</p>
<pre><code class="language-plain_text">sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer
</code></pre>
<p><strong>Step 2:</strong></p>
<p>Confirm the license agreement with the command:</p>
<pre><code class="language-plain_text">xcodebuild -license
</code></pre>
<p>This will prompt you to read through the license agreement.</p>
<p>Enter <code>agree</code> to accept the terms.</p>
<p>详见stackoverflow 中 <a href="http://stackoverflow.com/questions/33728905/qt-creator-project-error-xcode-not-set-up-properly-you-may-need-to-confirm-t">Qt Creator - Project ERROR: Xcode not set up properly. You may need to confirm the license agreement by running /usr/bin/xcodebuild</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402964936.html">事件传递</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>整体的事件传递流程<br />
<img src="media/16587402964936/15653376299374.jpg" alt="" style="width:687px;" /></p>
<p>详细的<code>hitTset:withEvent:</code>系统实现<br />
<img src="media/16587402964936/15653413218867.jpg" alt="" /></p>
<p>注：先判断视图是否隐藏可交互，不满足条件返回nil, 如果不在点击范围内就返回nil,在点击范围内就遍历子视图。遍历子视图的时候如果都没有子视图响应事件，那么就把视图本身<code>v</code>返回，如果有子视图响应就返回当前子视图。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402965346.html">vim 学习</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>开发中如果遇到修改配置文件的时候经常用到 vim .今天把常用到的 vim 命令进行简单的总结</p>
<p>##开始学习 vim<br />
在 terminal 中输入  <code>vimtutor -g zh</code> 就会开始 vim  学习教程</p>
<p>##简单总结<br />
###vim 编辑器中有三种状态模式<br />
<img src="media/16587402965346/14768675919240.jpg" alt="" /></p>
<p>###vim 编辑器的启动与退出</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>释意</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ vim</td>
<td>直接进入编辑环境</td>
</tr>
<tr>
<td>$ vim myfile</td>
<td>进入编辑环境并打开(新建)文件</td>
</tr>
<tr>
<td>:q</td>
<td>退出 vi 编辑环境</td>
</tr>
</tbody>
</table>
<p>###文件操作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>释意</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存对 vim 编辑器中已打开文件的修改</td>
</tr>
<tr>
<td>:w myfile</td>
<td>将 vim 编辑器中的内容另存为指定文件名</td>
</tr>
<tr>
<td>:wq</td>
<td>对 vim 编辑器中的文件进行保存并退出 vim 编辑器</td>
</tr>
<tr>
<td>:q!</td>
<td>放弃对文件内容的修改,并退出 vi 编辑器</td>
</tr>
</tbody>
</table>
<p>###光标移动操作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>光标操作</th>
<th>释意</th>
</tr>
</thead>
<tbody>
<tr>
<td>光标移动</td>
<td>h</td>
<td>向左移动光标</td>
</tr>
<tr>
<td></td>
<td>l</td>
<td>向右移动光标</td>
</tr>
<tr>
<td></td>
<td>k</td>
<td>向上移动光标</td>
</tr>
<tr>
<td></td>
<td>j</td>
<td>向下移动光标</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>翻页</td>
<td>Ctrl + f</td>
<td>向下翻整页</td>
</tr>
<tr>
<td></td>
<td>Ctrl + b</td>
<td>向上翻整页</td>
</tr>
<tr>
<td></td>
<td>Ctrl + u</td>
<td>向上翻半页</td>
</tr>
<tr>
<td></td>
<td>Ctrl + d</td>
<td>向下翻半页</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>行内移动光标</td>
<td>^</td>
<td>将光标快速跳转到本行的行首字符</td>
</tr>
<tr>
<td></td>
<td>$</td>
<td>将光标快速跳转到本行的行尾字符</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>文件内跳转</td>
<td>:set nu</td>
<td>在编辑器中显示行号</td>
</tr>
<tr>
<td></td>
<td>:set nonu</td>
<td>取消编辑器中的行号显示</td>
</tr>
<tr>
<td></td>
<td>1G(gg)</td>
<td>跳转到文件的首行</td>
</tr>
<tr>
<td></td>
<td>G</td>
<td>跳转到文件的末尾行</td>
</tr>
<tr>
<td></td>
<td>#G</td>
<td>跳转到文件中的第#行</td>
</tr>
</tbody>
</table>
<h3><a id="%E7%BC%96%E8%BE%91%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编辑操作</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>光标操作</th>
<th>释意</th>
</tr>
</thead>
<tbody>
<tr>
<td>进入输入模式</td>
<td>i</td>
<td>在当前光标处进入插入状态</td>
</tr>
<tr>
<td></td>
<td>a</td>
<td>在当前光标后进入插入状态</td>
</tr>
<tr>
<td></td>
<td>o</td>
<td>在当前行的下面插入新行,光标移动到新行的行首,进入插入状态</td>
</tr>
<tr>
<td></td>
<td>O</td>
<td>在当前行的上面插入新行,光标移动到新行的行首,进入插入状态</td>
</tr>
<tr>
<td></td>
<td>c(n)w</td>
<td>删除当前光标到所在单词尾部的字符,并进入插入状态</td>
</tr>
<tr>
<td></td>
<td>c$</td>
<td>删除当前光标到行尾的字符,并进入插入状态</td>
</tr>
<tr>
<td></td>
<td>c^</td>
<td>命令删除当前光标之前(不包括光标上的字符)到行首的字符,并进入插入状态</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>删除操作</td>
<td>x</td>
<td>删除光标处的单个字符</td>
</tr>
<tr>
<td></td>
<td>(n)dd</td>
<td>删除光标所 n 行</td>
</tr>
<tr>
<td></td>
<td>:3,5 d</td>
<td>删除从第 3 行到第 5 行的内容</td>
</tr>
<tr>
<td></td>
<td>dw</td>
<td>删除当前字符到单词尾(包括空格)的所有字符</td>
</tr>
<tr>
<td></td>
<td>de</td>
<td>删除当前字符到单词尾(不包括单词尾部的空格)的所有字符</td>
</tr>
<tr>
<td></td>
<td>d$</td>
<td>删除当前字符到行尾的所有字符</td>
</tr>
<tr>
<td></td>
<td>d^</td>
<td>删除当前字符到行首的所有字符</td>
</tr>
<tr>
<td></td>
<td>J(大写)</td>
<td>删除光标所在行行尾的换行符,相当于合并当 前行和下一行的内容</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>拷贝和粘贴</td>
<td>(n)yy</td>
<td>复制当前行整行的内容到 vi 缓冲区</td>
</tr>
<tr>
<td></td>
<td>:3,6 co(m) 12</td>
<td>复制(剪切)3-6 行,到第 12 行处</td>
</tr>
<tr>
<td></td>
<td>p</td>
<td>读取 vi 缓冲区中的内容,并粘贴到光标当前的位置(不覆盖文件已有的内容)</td>
</tr>
<tr>
<td></td>
<td>u</td>
<td>取消最近一次的操作,并恢复操作结果可以多次使用 u命令恢复已进行的多步操作</td>
</tr>
<tr>
<td></td>
<td>U</td>
<td>取消对当前整行进行的所有操作</td>
</tr>
<tr>
<td></td>
<td>Ctrl + r</td>
<td>对使用 u 命令撤销的操作进行恢复</td>
</tr>
</tbody>
</table>
<p>###查找与替换操作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>光标操作</th>
<th>释意</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找</td>
<td>/word</td>
<td>从上而下在文件中查找字符串“word”</td>
</tr>
<tr>
<td></td>
<td>?word</td>
<td>从下而上在文件中查找字符串“word”</td>
</tr>
<tr>
<td></td>
<td>n</td>
<td>定位下一个匹配的被查找字符串</td>
</tr>
<tr>
<td></td>
<td>N</td>
<td>定位上一个匹配的被查找字符串</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>替换</td>
<td>:s/old/new</td>
<td>将当前行中查找到的第一个字符“old” 串替换为“new”</td>
</tr>
<tr>
<td></td>
<td>:s/old/new/g</td>
<td>将当前行中查找到的所有字符串“old” 替换为“new”</td>
</tr>
<tr>
<td></td>
<td>:#,#s/old/new/g</td>
<td>在行号“#,#”范围内替换所有的字符串“old”为“new”</td>
</tr>
<tr>
<td></td>
<td>:%s/old/new/g</td>
<td>在整个文件范围内替换所有的字符串“old”为“new”</td>
</tr>
</tbody>
</table>
<p>##简易配置</p>
<p>输入 vim ~/.vimrc 该文件是一个隐藏文件,如果没有则 创建它,该文件中保存一些,vim 的常用配置。</p>
<pre><code class="language-plain_text">set nu //代码显示行号
syntax on //关键词高亮显示
set cindent //c 语法自动缩进
set autoindent //新行自动缩进
set shiftwidth=4 //缩进宽度 4
set tabstop=4 //tab 键宽度 4
set softtabstop=4 //制表符宽度 4
set nobackup //不备份
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402965549.html">全屏返回手势小技巧</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>这片文章可以和<a href="http://www.citynight.cn/Blog/14790381443417.html">Swift - KVC 和 运行时获取属性列表</a> 一起看,当然配上<a href="http://www.citynight.cn/Blog/14793034700265.html">隐藏tabBar的小技巧</a>就更好了😀</p>
</blockquote>
<p>##第一种: 通过<code>runtime</code>与<code>KVC</code>配合完成</p>
<p>在<code>UINavigationController</code>的<code>viewDidLoad</code>方法中:</p>
<pre><code class="language-plain_text">// 获取系统的手势
let gest = self.interactivePopGestureRecognizer!
// 禁用系统的手势
interactivePopGestureRecognizer?.isEnabled = false

// 通过KVC获取target 属性是通过runtime获取的,具体方法参见`Swift - KVC 和 运行时获取属性列表`
guard let targets = gest.value(forKey: &quot;_targets&quot;) as? [AnyObject] else {
    return
}
let target = targets[0].value(forKey: &quot;_target&quot;)

// 给视图添加点击事件
let pan = UIPanGestureRecognizer(target: target, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
view.addGestureRecognizer(pan)
</code></pre>
<p>##第二种: 通过原有的代理完成<br />
直接上代码:</p>
<pre><code class="language-plain_text">class BaseNavigationController: UINavigationController {

    override func viewDidLoad() {
        super.viewDidLoad()

        // 获取系统的手势的代理
        guard let target = interactivePopGestureRecognizer?.delegate else {
            return
        }
        
        // 禁用系统的手势
        interactivePopGestureRecognizer?.isEnabled = false
        
        // 给视图添加点击事件
        let pan = UIPanGestureRecognizer(target: target, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
        pan.delegate = self
        view.addGestureRecognizer(pan)
    }
}

extension BaseNavigationController:UIGestureRecognizerDelegate {
    func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&gt; Bool {
        // 当是跟控制器的时候不让返回,非跟控制器可以返回
        return viewControllers.count &gt; 1
    }
}

</code></pre>
<p>第一种也应该设置代理,不设置代理的话跟控制出现手势就会有bug</p>
<p>简单比较一下,第二种更简洁.不过应用了一个小技巧,看代码:</p>
<pre><code class="language-plain_text">    let pan = UIPanGestureRecognizer(target: self, action: NSSelectorFromString(&quot;handleNavigationTransition:&quot;))
    pan.delegate = self
    view.addGestureRecognizer(pan)
</code></pre>
<p>可见<code>target</code>&amp;<code>delegate</code>通常都是同一个对象,当让也可以是不同的,这里应用这个小技巧让代码变得更简洁.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402965748.html">Swift - 最近遇到的问题(3.8)</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E6%8A%8A%E5%87%BD%E6%95%B0%E5%90%8D%E5%BD%93%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8D%E9%87%8A%E6%94%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>把函数名当参数传递不释放</h2>
<p>控制器A 有一个函数 func  有一个视图 View ,如果控制器A 把函数 func 传递给 View 那么 控制器不释放</p>
<h2><a id="assertion-failure-in-uitableview-dequeuereusablecellwithidentifier-forindexpath" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>*** Assertion failure in -[UITableView dequeueReusableCellWithIdentifier:forIndexPath:]</h2>
<p>产生原因: 同一个控制器,里面有一个代码添加的tableView,然后这个控制器又添加了一个xib视图,xib视图中有tableView,并且设置tableView的数据源和代理方法为filesowner,导致崩溃.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402966163.html">Markdown syntax guide and writing on MWeb</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="philosophy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Philosophy</h2>
<blockquote>
<p>Markdown is intended to be as easy-to-read and easy-to-write as is feasible.<br />
Readability, however, is emphasized above all else. A Markdown-formatted document should be publishable as-is, as plain text, without looking like it's been marked up with tags or formatting instructions.<br />
Markdown's syntax is intended for one purpose: to be used as a format for <em>writing</em> for the web.</p>
</blockquote>


		</div>

		 
		 <footer>
      	<a rel="full-article" href="16587402966163.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402966388.html">fir 账号信息及使用</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>测试版账号： <a href="https://fir.im/jrfx">https://fir.im/jrfx</a><br />
账号：<a href="mailto:yubingice1986@163.com">yubingice1986@163.com</a><br />
密码：honghuotai</p>
<p>正式版本账号： <a href="https://fir.im/e659">https://fir.im/e659</a><br />
账号：<a href="mailto:qiaoyd523@163.com">qiaoyd523@163.com</a><br />
密码：qm523402</p>
<p>使用方式：<br />
<img src="media/16587402966388/15423501876913.jpg" alt="" style="width:1650px;" /><br />
进入后的界面<br />
<img src="media/16587402966388/15423504484819.jpg" alt="" style="width:1650px;" /></p>
<p>第二种方法找到历史版本比如<br />
<img src="media/16587402966388/15423508528219.jpg" alt="" style="width:831px;" /></p>
<p>把输入框中带有release_id 的地址发给其他人也能打开对应的历史版本<br />
<img src="media/16587402966388/15423508975512.jpg" alt="" style="width:1283px;" /></p>
<p>第三种方式 可以打开<br />
<img src="media/16587402966388/15423505180186.jpg" alt="" style="width:824px;" /><img src="media/16587402966388/Jietu20181116-144528.jpg" alt="Jietu20181116-144528" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402966634.html">1. 入职以来完成点菜点锅框架搭建,点菜存储上传相关逻辑梳理,推荐套餐完全重构等内容.</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol start="2">
<li>与团队成员共同定制代码规范,目前已初步完成.</li>
<li>总结团队开发中遇到的问题,并尽可能形成文档<br />
　在这三个月的工作中，我的技术水平，和业务能力都有所很大提高，和公司每位同事相处融洽，工作有条不紊。</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402966845.html">图像显示原理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402966845/WX20190809-201518@2x.png" alt="WX20190809-201518@2x" /></p>
<p><img src="media/16587402966845/15656069984426.jpg" alt="" style="width:979px;" /><br />
<img src="media/16587402966845/15656070181148.jpg" alt="" style="width:677px;" /></p>
<p><img src="media/16587402966845/15666279613682.jpg" alt="" style="width:755px;" /></p>
<p>系统绘制流程<br />
<img src="media/16587402966845/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-4-.jpg" alt="未命名文件 -4-" /></p>
<p>异步绘制流程(时序图)<br />
<img src="media/16587402966845/Jietu20190824-150035.jpg" alt="Jietu20190824-150035" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402967084.html">海底捞项目可以改进的地方</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>鉴权，  现在的鉴权会出现重复数据，比如<code>新品体验</code>中有<code>罗非鱼</code>,<code>荤菜</code>中的海鲜类中还存在<code>罗非鱼</code>，这两个是完全一致的，现在会把2个信息全部返回来，完全没有必要。--&gt; 可以改成 菜品全部返回来，然后分类中包含菜品id就好了。pad端可以根据菜品id在菜品中找到这个菜。然后再组装成显示的菜品列表</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402967306.html">键盘消失后又再次显示并立即消失问题</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Keyboard will appeared automatically while displaying alertview or alertcontroller</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/30498972/keyboard-will-appeared-automatically-in-ios-8-3-while-displaying-alertview-or-al">stackoverflow</a></p>
</blockquote>
<p>我采用其中</p>
<pre><code class="language-plain_text"> [YOUR_TEXT resignFirstResponder];
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.6 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{


                    _alertVw = [[UIAlertView alloc] initWithTitle:@&quot;&quot; message:@&quot;message.&quot; delegate:self cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil];

                    [_alertVw show];
});

</code></pre>
<p>这种方案解决的</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402967545.html">ListView了解Scrollable</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>滚动列表与动态加载</h2>
<h3><a id="listview%E6%89%80%E6%9C%89%E5%AD%90%E6%8E%A7%E4%BB%B6%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ListView 所有子控件一次直接渲染</h3>
<p>开发中常见的就是超出屏幕后提示Overflowing 像素超出屏幕了。这时最简单的办法就是外层控件换成ListView，这样就能上下滚动了。</p>
<h3><a id="listview-builder%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ListView.builder 按需加载</h3>
<p>如果控件比较多肯定不可能一次直接加载所有元素。这时就用到了ListView.builder,可以实现类似UITableView按需加载的效果。</p>
<p>如果itemCount 不设置即为null的时候，是无限加载，如果itemCount 设置了大小就是加载到固定项数。</p>
<pre><code class="language-dart">...
ListView.builder(
	itemCount: 88,// 不设置就是无限加载，设置就加载该值的数量。
	itemBuilder:(content,index){
		print(&quot;building $index&quot;); // 打印当前在画的视图
		return Container(
			color: Colors.blue[(index%5)*100],
			height:100,
			alignment: Alignment.center,
			child: Text(&quot;$index&quot;),
		);
	}
);
</code></pre>
<p>如上图，就会打印出当前正在渲染第几个。<br />
<img src="media/16587402967545/3A2D24C6-1778-407B-99B0-65E6E53EB136.jpeg" alt="3A2D24C6-1778-407B-99B0-65E6E53EB136" /></p>
<p>如果想要改变缓冲区大小可以设置cacheExtent参数</p>
<pre><code class="language-dart">...
ListView.builder(
	itemCount: 100,// 不设置就是无限加载，设置就加载该值的数量。
	cacheExtent: 2000, // 缓冲区大小，逻辑像素为单位，如果设置为0即不想要缓冲，只加载渲染屏幕正在显示的组件
	itemBuilder:(content,index){
		print(&quot;building $index&quot;); // 打印当前在画的视图
		return Container(
			color: Colors.blue[(index%5)*100],
			height:100,
			alignment: Alignment.center,
			child: Text(&quot;$index&quot;),
		);
	}
);
</code></pre>
<h3><a id="listview-separated%E5%88%86%E5%89%B2%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ListView.separated 分割线</h3>
<p>基本用法和ListView.builder一样，只不过添加了separatorBuilder</p>
<pre><code class="language-dart">ListView.separated(
	itemCount:6,
	separatorBuilder: (content,index){
		return Divider(thickness: 2); //thickness 设置分割线粗细
	},
);
</code></pre>
<h2><a id="listview%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ListView 性能问题</h2>
<h3><a id="%E8%AE%BE%E7%BD%AEitemextent" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置itemExtent</h3>
<p>如果每个item大小不一，这样在滑动ScrollBar的时候就会把所有中间位置的item都加载，加载速度会变慢，很耗性能。</p>
<p>ListView中有一个参数itemExtent，这个参数设置每一个item的固定大小，即使item Builder中的item有大小也会强制设置为itemExtent的值（主轴方向）。</p>
<p><img src="media/16587402967545/57658C3A-957B-4324-937E-E9CAF86A3EB8.jpeg" alt="57658C3A-957B-4324-937E-E9CAF86A3EB8" /></p>
<p>由上图也能看出，设置itemExtent后，主轴方向的大小就是itemExtent设置的值，不设置就是视图自己的值。交叉轴方向是要占满ListView的宽度/高度。</p>
<h3><a id="%E8%AE%BE%E7%BD%AEpadding" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置padding</h3>
<p>给ListView设置padding有三种方式</p>
<ol>
<li>
<p>给ListView外面加padding</p>
<pre><code class="language-dart">...
Padding(
	padding: const EdgeInsets.all(40),
	child: ListView.builder(
		...
	),
),
...
</code></pre>
<p>这种方式也就固定了ListView的视图padding</p>
</li>
<li>
<p>给item添加padding</p>
<pre><code class="language-dart">...
ListView.builder(
	itemBuilder:(content,index){
		return Padding(
			padding: EdgeInsets.symmetric(horizontal: 80),// 水平左右80
			child: Container(
				height:80,
				width: 80,
				color: Colors.blue,
			),
		);
	},
),
</code></pre>
<p>这种方式是给每一个item添加padding</p>
</li>
<li>
<p>设置padding属性。</p>
<pre><code class="language-dart">...
ListView.builder(
	padding: const EdgeInsets.all(33.0),
	itemBuilder: ...
),
...
</code></pre>
<p>这种方式能看到左右的交叉轴方向立即显示padding对应的大小，而主轴方向则显示类似为iOS 中Scroll View中的scrollOfSet</p>
</li>
</ol>
<h3><a id="%E8%AE%BE%E7%BD%AEcontroller" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置controller</h3>
<p>ListView中有一个属性是controller，我们可以给ListView设置controller，从而设置List View滚动相关的控制.</p>
<pre><code class="language-dart">...
final _controller = ScrollController();

...
return Scaffold(
	appBar: AppBar(
		title: GestureDetector(
			onTap:() {
				//_controller.jumpTo(0.0);// 跳转到第一
				_controller.animateTo(-20,duration:Duration(seconds:1),curve:Curves.linear,);// 动画跳转，设置为负像素能超出范围然后反弹，持续时间1s，线性动画
			},
			child: Text(&quot;ListView Demo&quot;),
		),
	),
);
</code></pre>
<p>我们也可以通过_controller.offSet知道目前的位置（逻辑像素）</p>
<h3><a id="%E8%AE%BE%E7%BD%AEphysics" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置physics</h3>
<p>像安卓一样的效果，可以设置为</p>
<p>ClampingScrollPhysics</p>
<p>像iOS一样的效果，可以设置为</p>
<p>BouncingScrollPhysics</p>
<p>不能滚动</p>
<p>NeverScrollableScrollPhysics</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402967801.html">代理 strong</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-plain_text">URLSession(configuration: &lt;#T##URLSessionConfiguration#&gt;, delegate: &lt;#T##URLSessionDelegate?#&gt;, delegateQueue: &lt;#T##OperationQueue?#&gt;)
</code></pre>
<p>The session object keeps a strong reference to the delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session by calling the invalidateAndCancel() or finishTasksAndInvalidate() method, your app leaks memory until it exits.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402968058.html">Flutter中Row中的子控件左右两端对齐</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>假如我们要实现这样一个效果：两个子控件（例如2个文本）在一行显示，但我们想让它们分别左右两侧对齐，也就是左右一边一个。如何实现呢？<br />
方法一：<br />
设置 spaceBetween 对齐方式 设置 Row 控件的属性 mainAxisAlignment： mainAxisAlignment: MainAxisAlignment.spaceBetween,<br />
方法二：Expanded 填充 使用 Expanded 中间填充布局空间：<br />
new Row( children: [ new Text(&quot;开始日期：&quot;), Expanded(child: SizedBox()), new Text(“2020-12-29&quot;), ],),<br />
方法三：使用 Spacer() 填充<br />
new Row( children: [ new Text(&quot;开始日期：&quot;), Spacer(), new Text(“2020-12-29&quot;), ],),<br />
方法四：使用 Flexible<br />
new Row( children: [ new Text(&quot;开始日期：&quot;), Flexible(fit: FlexFit.tight, child: SizedBox()), new Text(“2020-12-29&quot;), ],),</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402968315.html">Custom UIViews from XIB files</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##<a href="https://stackoverflow.com/documentation/ios/1362/custom-uiviews-from-xib-files/4443/wiring-elements">Wiring elements</a></p>
<ul>
<li></li>
</ul>
<pre><code class="language-plain_text">&gt; Create a XIB file

Xcode Menu Bar &gt; File &gt; New &gt; File.
Select iOS, User Interface and then &quot;View&quot;:

[![First step](media/16587402968315/RSkzu.png)](media/15036540820094/RSkzu.png)

Give your XIB a name (yes, we are doing a Pokemon example 👾).
**Remember to check your target** and hit &quot;Create&quot;.

[![Second step](media/16587402968315/oJ1s1.png)](media/15036540820094/oJ1s1.png)

&gt; Design your view

To make things easier, set:

* Size: Freeform
* Status Bar: None
* Top Bar: None
* Bottom Bar: None

[![Third step](media/16587402968315/Gy0KD.png)](media/15036540820094/Gy0KD.png)

Click on the Size Inspector and resize the view.
For this example we'll be using width 321 and height 256.

[![Fourth step](media/16587402968315/PNIek.png)](media/15036540820094/PNIek.png)

Drop some elements into your XIB file like shown below.
Here we'll be adding an **Image View** (256x256) and a **Switch**.

[![Fifth step](media/16587402968315/6u3pd.png)](media/15036540820094/6u3pd.png)

Add Auto-Layout constraints by clicking on &quot;Resolve Auto Layout Issues&quot; (bottom-right) and selecting &quot;Add Missing Constraints&quot; under &quot;All Views&quot;.

[![Sixth step](media/16587402968315/esZhQ.png)](media/15036540820094/esZhQ.png)

Preview the changes you made by clicking on &quot;Show the Assistant Editor&quot; (top-right), then &quot;Preview&quot;.
You can add iPhone screens by clicking on the &quot;Plus&quot; button.
The preview should look like this:

[![Seventh step](media/16587402968315/D3rac.png)](media/15036540820094/D3rac.png)

&gt; Subclass UIView

Create the class that is going to manage the XIB file.
Xcode Menu Bar &gt; File &gt; New &gt; File.
Select iOS / Source / Cocoa Touch Class. Hit &quot;Next&quot;.

[![Eighth step](media/16587402968315/0EyHy.png)](media/15036540820094/0EyHy.png)

Give the class a name, which must be the same name as the XIB file (Pokemon).
Select UIView as the subclass type, then hit &quot;Next&quot;.

[![Nineth step](media/16587402968315/qbo3s.png)](media/15036540820094/qbo3s.png)

On the next window, select your target and hit &quot;Create&quot;.

[![Tenth step](media/16587402968315/Ks9Tu.png)](media/15036540820094/Ks9Tu.png)

&gt; Connect Pokemon.xib to Pokemon.swift via &quot;File’s Owner&quot; attribute

Click on the Pokemon.xib file in Xcode.
Click on the &quot;File's Owner&quot; outlet.
On the &quot;Identity inspector&quot; (top-right), set the Class to our recently created Pokemon.swift file.

[![Eleventh step](media/16587402968315/4YT3i.png)](media/15036540820094/4YT3i.png)

&gt; POKEMONS!!!

Yes! Drag and drop some Pokemons into your project to finish up our &quot;infrastructure&quot;.
Here we are adding two PGN files, 256x256, transparent.

[![Twelfth step](media/16587402968315/ibqxZ.png)](media/15036540820094/ibqxZ.png)

&gt; Show me code already.

All right, all right.
Time to add some code to our Pokemon.swift class.

It's actually pretty simple:

1. Implement required initializers
2. Load the XIB file
3. Configure the view that will display the XIB file
4. Show the above view

Add the following code to the Pokemon.swift class:

```
import UIKit

class Pokemon: UIView {

    // MARK: - Initializers

    override init(frame: CGRect) {
        super.init(frame: frame)
        setupView()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setupView()
    }

    // MARK: - Private Helper Methods

    // Performs the initial setup.
    private func setupView() {
        let view = viewFromNibForClass()
        view.frame = bounds

        // Auto-layout stuff.
        view.autoresizingMask = [
            UIViewAutoresizing.flexibleWidth,
            UIViewAutoresizing.flexibleHeight
        ]

        // Show the view.
        addSubview(view)
    }

    // Loads a XIB file into a view and returns this view.
    private func viewFromNibForClass() -&gt; UIView {

        let bundle = Bundle(for: type(of: self))
        let nib = UINib(nibName: String(describing: type(of: self)), bundle: bundle)
        let view = nib.instantiate(withOwner: self, options: nil).first as! UIView

        /* Usage for swift &lt; 3.x
        let bundle = NSBundle(forClass: self.dynamicType)
        let nib = UINib(nibName: String(self.dynamicType), bundle: bundle)
        let view = nib.instantiateWithOwner(self, options: nil)[0] as! UIView
        */

        return view
    }
}

```

&gt; @IBDesignable and @IBInspectable

By adding `@IBDesignable` to your class, you make possible for it to live-render in Interface Builder.
By adding `@IBInspectable` to the properties of your class, you can see your custom views changing in Interface Builder as soon as you modify those properties.

Let's make the `Image View` of our custom view &quot;Inspectable&quot;.

First, hook up the `Image View` from the Pokemon.xib file to the Pokemon.swift class.

[![Thirteenth step](media/16587402968315/Dxyv2.png)](media/15036540820094/Dxyv2.png)

Call the outlet `imageView` and then add the following code (notice the `@IBDesignable` before the class name):

```
@IBDesignable class Pokemon: UIView {

    // MARK: - Properties

    @IBOutlet weak var imageView: UIImageView!

    @IBInspectable var image: UIImage? {
        get {
            return imageView.image
        }
        set(image) {
            imageView.image = image
        }
    }

    // MARK: - Initializers
    ...

```

&gt; Using your Custom Views

Got to your Main storyboard file, drag a UIView into it.
Resize the view to, say 200x200\. Centralize.
Go to the Identity inspector (top-right) and set the Class to Pokemon.

[![Fourteenth steps](media/16587402968315/Iah3Y.png)](media/15036540820094/Iah3Y.png)

To select a Pokemon, go to the Attribute Inspector (top-right) and select one of the Pokemon images you previously added using the awesome `@IBInspectable` image property.

[![Fifteenth step](media/16587402968315/727mm.png)](media/15036540820094/727mm.png)

Now duplicate your custom Pokemon view.
Give it a different size, say 150x150.
Choose another Pokemon image, observe:

[![Sixteenth step](media/16587402968315/xrTXw.png)](media/15036540820094/xrTXw.png)

Now we are going to add more logic to that self-containing custom UI element.
The button will allow Pokemons to be enabled/disabled.

Create an `IBAction` from the Switch button to the Pokemon.swift class.
Call the action something like `switchTapped`.
Add the following code to it:

```
// MARK: - Actions

@IBAction func switchTapped(sender: UISwitch) {
    imageView.alpha = sender.on ? 1.0 : 0.2
}

// MARK: - Initializers
...

```

Final result:

[![Final](media/16587402968315/DQJvO.gif)](media/15036540820094/DQJvO.gif)

You are done!
Now you can create complex custom views and reuse them anywhere you want.
This will increase productivity while isolating code into self-contained UI elements.

[The final project can be cloned in Github.](https://github.com/singledev/custom-uiviews-from-xib)
(**Updated to Swift 3.1**)
</code></pre>
<p>##<a href="https://stackoverflow.com/documentation/ios/1362/custom-uiviews-from-xib-files/11599/how-to-make-custom-reusable-uiview-using-xib">How to make custom reusable UIView using XIB</a></p>
<p>Following example shows steps involved in initializing a view from XIB.</p>
<p>This is not a complex operation but exact steps need to be followed in order to do it right way first time, avoiding exceptions.</p>
<p><a href="http://stackoverflow.com/questions/20323393/how-does-loadnibnamed-work-uiview-outlets-not-initializing-using-loadnibnamed">How does loadNibNamed Works</a></p>
<p>Main steps are:</p>
<ol>
<li>
<p>Create XIB</p>
</li>
<li>
<p>Create class .h and .m</p>
</li>
<li>
<p>Define outlets in .h</p>
</li>
<li>
<p>Connect outlets between .h and XIB</p>
<p>See attached screenshot:</p>
<p><a href="media/15036540820094/rSBw6.png"><img src="media/16587402968315/rSBw6.png" alt="Label Object connected to myLabel IBOutlet UILabel variable" /></a></p>
</li>
<li>
<p>Invoke loadNibNamed inside initWithCoder function of .m file. This is needed to ensure you can directly place UIView object into storyboard / Parent UIView XIB file and define it as your custom view. No other initialization code is needed once you load the storyboard / parent XIB. Your custom view can be added to other views just like other built-in Objective C view objects given in XCode.</p>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402968609.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>点餐版本： 1.查看账单功能置灰，不能点击 2.更多功能里只保留桌位备注，修改当前工号密码，绑定桌位，修改当前服务员密码</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402968823.html">[转]浅析 iOS 应用开发中的断点续传</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>原贴地址<a href="https://www.ibm.com/developerworks/cn/mobile/mo-cn-breakpoint/index.html">IBM developerWorks</a></p>
</blockquote>
<h2><a id="%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>断点续传概述</h2>
<p>断点续传就是从文件上次中断的地方开始重新下载或上传数据，而不是从文件开头。（本文的断点续传仅涉及下载，上传不在讨论之内）当下载大文件的时候，如果没有实现断点续传功能，那么每次出现异常或者用户主动的暂停，都会去重头下载，这样很浪费时间。所以项目中要实现大文件下载，断点续传功能就必不可少了。当然，断点续传有一种特殊的情况，就是 iOS 应用被用户 kill 掉或者应用 crash，要实现应用重启之后的断点续传。这种特殊情况是本文要解决的问题。</p>
<h2><a id="%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>断点续传原理</h2>
<p>要实现断点续传 , 服务器必须支持。目前最常见的是两种方式：FTP 和 HTTP。下面来简单介绍 HTTP 断点续传的原理。</p>
<h3><a id="http" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTTP</h3>
<p>通过 HTTP，可以非常方便的实现断点续传。断点续传主要依赖于 HTTP 头部定义的 Range 来完成。具体 Range 的说明参见 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC2616</a>中 14.35.2 节，在请求某范围内的资源时，可以更有效地对大资源发出请求或从传输错误中恢复下载。有了 Range，应用可以通过 HTTP 请求曾经获取失败的资源的某一个返回或者是部分，来恢复下载该资源。当然并不是所有的服务器都支持 Range，但大多数服务器是可以的。Range 是以字节计算的，请求的时候不必给出结尾字节数，因为请求方并不一定知道资源的大小。Range 的定义如图 1 所示：</p>
<h5><a id="%E5%9B%BE1-http-range" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 1. HTTP-Range</h5>
<p><img src="media/16587402968823/image001.png" alt="HTTP-Range" /></p>
<p>图 2 展示了 HTTP request 的头部信息：</p>
<h5><a id="%E5%9B%BE2-http-request%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 2. HTTP request 例子</h5>
<p><img src="media/16587402968823/image002.png" alt="HTTP request 例子" /></p>
<p>在上面的例子中的“Range: bytes=1208765-”表示请求资源开头 1208765 字节之后的部分。</p>
<p>图 3 展示了 HTTP response 的头部信息：</p>
<h5><a id="%E5%9B%BE3-http-response%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 3. HTTP response 例子</h5>
<p><img src="media/16587402968823/image003.png" alt="HTTP response 例子" /></p>
<p>上面例子中的”Accept-Ranges: bytes”表示服务器端接受请求资源的某一个范围，并允许对指定资源进行字节类型访问。”Content-Range: bytes 1208765-20489997/20489998”说明了返回提供了请求资源所在的原始实体内的位置，还给出了整个资源的长度。这里需要注意的是 HTTP return code 是 206 而不是 200。</p>
<h2><a id="%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%88%86%E6%9E%90afhttprequestoperation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>断点续传分析 -AFHTTPRequestOperation</h2>
<p>了解了断点续传的原理之后，我们就可以动手来实现 iOS 应用中的断点续传了。由于笔者项目的资源都是部署在 HTTP 服务器上 , 所以断点续传功能也是基于 HTTP 实现的。首先来看下第三方网络框架 AFNetworking 中提供的实现。清单 1 示例代码是用来实现断点续传部分的代码：</p>
<h5><a id="%E6%B8%85%E5%8D%951%E4%BD%BF%E7%94%A8-afhttprequestoperation%E5%AE%9E%E7%8E%B0%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E7%9A%84%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>清单 1. 使用 AFHTTPRequestOperation 实现断点续传的代码</h5>
<pre><code class="language-plain_text">// 1 指定下载文件地址 URLString 
// 2 获取保存的文件路径 filePath 
// 3 创建 NSURLRequest 
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:URLString]]; 
unsigned long long downloadedBytes = 0; 
 
if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) { 
// 3.1 若之前下载过 , 则在 HTTP 请求头部加入 Range 
   // 获取已下载文件的 size 
   downloadedBytes = [self fileSizeForPath:filePath]; 
        
   // 验证是否下载过文件
   if (downloadedBytes &gt; 0) { 
       // 若下载过 , 断点续传的时候修改 HTTP 头部部分的 Range 
       NSMutableURLRequest *mutableURLRequest = [request mutableCopy]; 
       NSString *requestRange = 
       [NSString stringWithFormat:@&quot;bytes=%llu-&quot;, downloadedBytes]; 
       [mutableURLRequest setValue:requestRange forHTTPHeaderField:@&quot;Range&quot;]; 
       request = mutableURLRequest; 
   } 
} 
 
// 4 创建 AFHTTPRequestOperation 
AFHTTPRequestOperation *operation 
 = [[AFHTTPRequestOperation alloc] initWithRequest:request]; 
 
// 5 设置操作输出流 , 保存在第 2 步的文件中
operation.outputStream = [NSOutputStream 
outputStreamToFileAtPath:filePath append:YES]; 
 
// 6 设置下载进度处理 block 
[operation setDownloadProgressBlock:^(NSUInteger bytesRead, 
long long totalBytesRead, long long totalBytesExpectedToRead) { 
// bytesRead 当前读取的字节数
// totalBytesRead 读取的总字节数 , 包含断点续传之前的
// totalBytesExpectedToRead 文件总大小
}]; 
 
// 7 设置 success 和 failure 处理 block 
[operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation 
*operation, id responseObject) { 
 
} failure:^(AFHTTPRequestOperation *operation, NSError *error) { 
 
}]; 
 
// 8 启动 operation 
[operation start];
</code></pre>
<p>使用以上代码 , 断点续传功能就实现了，应用重新启动或者出现异常情况下 , 都可以基于已经下载的部分开始继续下载。关键的地方就是把已经下载的数据持久化。接下来简单看下 AFHTTPRequestOperation 是怎么实现的。通过查看源码 , 我们发现 AFHTTPRequestOperation 继承自 AFURLConnectionOperation , 而 AFURLConnectionOperation 实现了 NSURLConnectionDataDelegate 协议。处理流程如图 4 所示：</p>
<h5><a id="%E5%9B%BE4-afurlhttprequestoperation%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 4. AFURLHTTPrequestOperation 处理流程</h5>
<p><img src="media/16587402968823/image004.png" alt="AFURLHTTPrequestOperation 处理流程" /></p>
<p>这里 AFNetworking 为什么采取子线程调异步接口的方式 , 是因为直接在主线程调用异步接口 , 会有一个 Runloop 的问题。当主线程调用 [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:YES] 时 , 请求发出之后的监听任务会加入到主线程的 Runloop 中 ,RunloopMode 默认为 NSDefaultRunLoopMode, 这个表示只有当前线程的 Runloop 处理 NSDefaultRunLoopMode 时，这个任务才会被执行。而当用户在滚动 TableView 和 ScrollView 的时候，主线程的 Runloop 处于 NSEventTrackingRunLoop 模式下，就不会执行 NSDefaultRunLoopMode 的任务。</p>
<p>另外由于采取子线程调用接口的方式 , 所以这边的 DownloadProgressBlock,success 和 failure Block 都需要回到主线程来处理。</p>
<h2><a id="%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%AE%9E%E6%88%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>断点续传实战</h2>
<p>了解了原理和 AFHTTPRequestOperation 的例子之后 , 来看下实现断点续传的三种方式：</p>
<h3><a id="nsurlconnection" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSURLConnection</h3>
<p>基于 NSURLConnection 实现断点续传 , 关键是满足 NSURLConnectionDataDelegate 协议，主要实现了如下三个方法：</p>
<h5><a id="%E6%B8%85%E5%8D%952-nsurlconnection%E7%9A%84%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>清单 2. NSURLConnection 的实现</h5>
<pre><code class="language-plain_text">// SWIFT 
// 请求失败处理
func connection(connection: NSURLConnection, 
didFailWithError error: NSError) { 
   self.failureHandler(error: error) 
} 
 
// 接收到服务器响应是调用
func connection(connection: NSURLConnection, 
 didReceiveResponse response: NSURLResponse) { 
   if self.totalLength != 0 { 
       return 
   } 
 
   self.writeHandle = NSFileHandle(forWritingAtPath: 
   FileManager.instance.cacheFilePath(self.fileName!)) 
 
   self.totalLength = response.expectedContentLength + self.currentLength 
} 
 
// 当服务器返回实体数据是调用
func connection(connection: NSURLConnection, didReceiveData data: NSData) { 
   let length = data.length 
    
   // move to the end of file 
   self.writeHandle.seekToEndOfFile() 
    
   // write data to sanbox 
   self.writeHandle.writeData(data) 
    
   // calculate data length 
   self.currentLength = self.currentLength + length 
    
   print(&quot;currentLength\(self.currentLength)-totalLength\(self.totalLength)&quot;) 
    
   if (self.downloadProgressHandler != nil) { 
       self.downloadProgressHandler(bytes: length, totalBytes: 
       self.currentLength, totalBytesExpected: self.totalLength) 
   } 
} 
 
// 下载完毕后调用
func connectionDidFinishLoading(connection: NSURLConnection) { 
   self.currentLength = 0 
   self.totalLength = 0 
 
   //close write handle 
   self.writeHandle.closeFile() 
   self.writeHandle = nil 
 
   let cacheFilePath = FileManager.instance.cacheFilePath(self.fileName!) 
   let documenFilePath = FileManager.instance.documentFilePath(self.fileName!) 
        
   do { 
       try FileManager.instance.moveItemAtPath(cacheFilePath, toPath: documenFilePath) 
   } catch let e as NSError { 
       print(&quot;Error occurred when to move file: \(e)&quot;) 
   } 
    
   self.successHandler(responseObject:fileName!) 
}
</code></pre>
<p>如图 5 所示 , 说明了 NSURLConnection 的一般处理流程。（代码详见下载包）</p>
<h5><a id="%E5%9B%BE5-nsurlconnection%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 5. NSURLConnection 流程</h5>
<p><img src="media/16587402968823/image005.png" alt="NSURLConnection 流程" /></p>
<p>根据图 5 的一般流程，在 didReceiveResponse 中初始化 fileHandler, 在 didReceiveData 中 , 将接收到的数据持久化的文件中 , 在 connectionDidFinishLoading 中，清空数据和关闭 fileHandler，并将文件保存到 Document 目录下。所以当请求出现异常或应用被用户杀掉，都可以通过持久化的中间文件来断点续传。初始化 NSURLConnection 的时候要注意设置 scheduleInRunLoop 为 NSRunLoopCommonModes，不然就会出现进度条 UI 无法更新的现象。实现效果如图 6 所示：</p>
<h5><a id="%E5%9B%BE6-nsurlconnection%E6%BC%94%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 6. NSURLConnection 演示</h5>
<p><img src="media/16587402968823/image006.gif" alt="NSURLConnection 演示" /></p>
<h3><a id="nsurlsessiondatatask" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSURLSessionDataTask</h3>
<p>苹果在 iOS7 开始，推出了一个新的类 NSURLSession, 它具备了 NSURLConnection 所具备的方法，并且更强大。由于通过 NSURLConnection 从 2015 年开始被弃用了，所以读者推荐基于 NSURLSession 去实现续传。NSURLConnection 和 NSURLSession delegate 方法的映射关系 , 如图 7 所示。所以关键是要满足 NSURLSessionDataDelegate 和 NSURLsessionTaskDelegate。</p>
<h5><a id="%E5%9B%BE7%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 7. 协议之间映射关系</h5>
<p><img src="media/16587402968823/image007.png" alt="协议之间映射关系" /></p>
<p>代码如清单 3 所示 , 基本和 NSURLConnection 实现的一样。</p>
<h5><a id="%E6%B8%85%E5%8D%953-nsurlsessiondatatask%E7%9A%84%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>清单 3. NSURLSessionDataTask 的实现</h5>
<pre><code class="language-plain_text">// SWIFT 
// 接收数据
func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, 
idReceiveData data: NSData) { 
   //. . . 
} 
// 接收服务器响应
func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, 
didReceiveResponse response: NSURLResponse, completionHandler: 
 (NSURLSessionResponseDisposition) -&gt; Void) { 
   // . . . 
   completionHandler(.Allow) 
} 
 
// 请求完成
func URLSession(session: NSURLSession, task: NSURLSessionTask, 
 didCompleteWithError error: NSError?) { 
   if error == nil { 
       // . . . 
       self.successHandler(responseObject:self.fileName!) 
   } else { 
       self.failureHandler(error:error!) 
   } 
}
</code></pre>
<p>区别在与 didComleteWithError, 它将 NSURLConnection 中的 connection:didFailWithError:</p>
<p>和 connectionDidFinishLoading: 整合到了一起 , 所以这边要根据 error 区分执行成功的 Block 和失败的 Block。实现效果如图 8 所示：</p>
<h5><a id="%E5%9B%BE8-nsurlsessiondatatask%E6%BC%94%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 8. NSURLSessionDataTask 演示</h5>
<p><img src="media/16587402968823/image008.gif" alt="NSURLSessionDataTask 演示" /></p>
<h3><a id="nsurlsessiondowntask" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSURLSessionDownTask</h3>
<p>最后来看下 NSURLSession 中用来下载的类 NSURLSessionDownloadTask，对应的协议是 NSURLSessionDownloadDelegate，如图 9 所示：</p>
<h5><a id="%E5%9B%BE9-nsurlsessiondownloaddelegate%E5%8D%8F%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 9. NSURLSessionDownloadDelegate 协议</h5>
<p><img src="media/16587402968823/image009.png" alt="NSURLSessionDownloadDelegate 协议" /></p>
<p>其中在退出 didFinishDownloadingToURL 后，会自动删除 temp 目录下对应的文件。所以有关文件操作必须要在这个方法里面处理。之前笔者曾想找到这个 tmp 文件 , 基于这个文件做断点续传 , 无奈一直找不到这个文件的路径。等以后 SWIFT 公布 NSURLSession 的源码之后，兴许会有方法找到。基于 NSURLSessionDownloadTask 来实现的话 , 需要在 cancelByProducingResumeData 中保存已经下载的数据。进度通知就非常简单了，直接在 URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite: 实现即可。代码如清单 4 所示：</p>
<h5><a id="%E6%B8%85%E5%8D%954-nsurlsessiondownloadtask%E7%9A%84%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>清单 4. NSURLSessionDownloadTask 的实现</h5>
<pre><code class="language-plain_text">//SWIFT 
 
//UI 触发 pause 
func pause(){ 
   self.downloadTask?.cancelByProducingResumeData({data -&gt; Void in 
       if data != nil { 
data!.writeToFile(FileManager.instance.cacheFilePath(self.fileName!), 
atomically: false) 
} 
       }) 
   self.downloadTask = nil 
} 
 
// MARK: - NSURLSessionDownloadDelegate 
func URLSession(session: NSURLSession, downloadTask: 
NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, 
totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) { 
   if (self.downloadProgressHandler != nil) { 
       self.downloadProgressHandler(bytes: Int(bytesWritten), 
        totalBytes: totalBytesWritten, totalBytesExpected: totalBytesExpectedToWrite) 
   } 
} 
 
func URLSession(session: NSURLSession, task: NSURLSessionTask, 
didCompleteWithError error: NSError?) { 
   if error != nil {//real error 
       self.failureHandler(error:error!) 
   } 
} 
 
func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, 
 didFinishDownloadingToURL location: NSURL) { 
   let cacheFilePath = FileManager.instance.cacheFilePath(self.fileName!) 
   let documenFilePath = FileManager.instance.documentFilePath(self.fileName!) 
   do { 
       if FileManager.instance.fileExistsAtPath(cacheFilePath){ 
           try FileManager.instance.removeItemAtPath(cacheFilePath) 
       } 
       try FileManager.instance.moveItemAtPath(location.path!, toPath: documenFilePath) 
   } catch let e as NSError { 
       print(&quot;Error occurred when to move file: \(e)&quot;) 
   } 
   self.successHandler(responseObject:documenFilePath) 
}
</code></pre>
<p>实现效果如图 10 所示：</p>
<h5><a id="%E5%9B%BE10-nsurlsessiondownloadtask%E6%BC%94%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图 10. NSURLSessionDownloadTask 演示</h5>
<p><img src="media/16587402968823/image010.gif" alt="NSURLSessionDownloadTask 演示" /></p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>本文从断点续传概述开始，介绍了断点续传的应用背景，通过原理的描述，相信读者对断点续传有了基本的认识和理解。接着笔者介绍了通过 AFHTTPRequestOpeartion 实现的代码，并对 AFHTTPRequestOpeartion 做了简单的分析。最后笔者结合的实际需求，基于 NSURLConnection, NSURLSeesionDataTask 和 NSURLSessionDownloadtask。其实，下载的实现远不止这些内容，本文只介绍了简单的使用。希望在进一步的学习和应用中能继续与大家分享。</p>
<h4><a id="%E7%9B%B8%E5%85%B3%E4%B8%BB%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关主题</h4>
<ul>
<li>参考 <a href="https://www.w3.org/Protocols/rfc959/4_FileTransfer.html">RFC959</a>，了解 FTP 协议文本的说明。</li>
<li>参考 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC2616</a>，了解 HTTP 的说明。</li>
<li>参考 <a href="https://github.com/AFNetworking/AFNetworking/blob/2.x/AFNetworking/AFHTTPRequestOperation.m">AFHTTPRequestOperation</a>, 了解源码。</li>
<li>参考 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/ObjC_classic/index.html#//apple_ref/doc/uid/20001091">iOSDeveloperLibrary</a>，了解 Apple 官方文档对 NSURLConnection, NSURLSeesionDownloadTask 和 NSURLSeesionDataTask 的说明。</li>
<li>访问 developerWorks <a href="http://www.ibm.com/developerworks/cn/mobile/">Mobile 专区</a>，了解关于信息管理的更多信息，获取技术文档、how-to 文章、培训、下载、产品信息以及其他资源。</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402969069.html">问题汇总</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1%E9%A6%96%E9%A1%B5%E6%98%AF%E6%80%8E%E4%B9%88%E5%87%BA%E6%9D%A5%E7%9A%84-push%E8%BF%98%E6%98%AF-present" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 首页是怎么出来的 push 还是 present</h2>
<h2><a id="2%E5%A6%82%E6%9E%9C%E6%98%AF-present%E6%80%8E%E4%B9%88%E6%B6%88%E5%A4%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 如果是present 怎么消失</h2>
<h2><a id="3-present" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. present</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402969290.html">iOS依赖库管理工具：Carthage</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>新项目需要使用一种新的依赖库管理工具:<code>Carthage</code></p>
<blockquote>
<p>参见:<a href="http://www.jianshu.com/p/9a37b81a59d6">iOS依赖库管理工具：Carthage</a></p>
</blockquote>
<h2><a id="%E5%AE%89%E8%A3%85carthage" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装Carthage</h2>
<ul>
<li>使用终端安装</li>
</ul>
<pre><code class="language-plain_text">$brew update
$brew install carthage
</code></pre>
<ul>
<li>在<a href="https://github.com/Carthage/Carthage/releases">https://github.com/Carthage/Carthage/releases</a> 下载最新版的Carthage.pkg</li>
</ul>
<p>安装好Carthage后，查看Carthage当前版本</p>
<pre><code class="language-plain_text">$brew carthage version
</code></pre>
<h2><a id="%E4%BD%BF%E7%94%A8carthage" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用Carthage</h2>
<ul>
<li>在项目所在文件夹中创建一个空的Carthage文件</li>
</ul>
<pre><code class="language-plain_text">$touch Cartfile  
$vi Cartfile
</code></pre>
<p><strong>$touch Cartfile</strong>：新建一个名为Cartfile的文件</p>
<p><strong>$vi Cartfile</strong>：打开名为Cartfile文件，如若该文件不存在会新建</p>
<ul>
<li>在Cartfile中加入一下内容，以Alamofire为例：</li>
</ul>
<pre><code class="language-plain_text">github &quot;Alamofire/Alamofire&quot; ~&gt; 3.0
</code></pre>
<p>版本含义：<br />
<code>~&gt; 3.0：表示使用版本高于3.0低于4.0的最新版本</code><br />
<code>== 3.0：使用3.0版本</code><br />
<code>&gt;= 3.0：使用3.0版本或者更高版本</code><br />
如果没有指明版本号，默认使用最新版本</p>
<ul>
<li>保存并关闭Cartfile文件，在终端执行如下命令，carthage开始下载和编译所需要的第三方库，当命令执行完毕，项目文件夹中会创建一个名为Carthage的文件夹，并且在~/Carthage/Build/iOS中出现Alamofire.framework文件</li>
</ul>
<pre><code class="language-plain_text">$carthage update
</code></pre>
<ul>
<li>
<p>打开项目，点击project-&gt;target-&gt;General，在Embedded Binaries添加Alamofire.framework</p>
</li>
<li>
<p>此时已经可以使用导入的第三方库了，在需要的文件中导入头文件</p>
</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402969513.html">Swift - 数组遍历</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>最近没怎么更新,主要是最近刚入职新公司.正在熟悉环境中... 好了题目是<code>Swift - 数组遍历</code> 主要是项目要使用 Swift 开发,所以需要熟悉下语法.</p>
</blockquote>
<p>##传统的下标遍历方法</p>
<pre><code class="language-plain_text">let array = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;]

// 第一种 下标遍历
for i in 0..&lt;array.count {
    print(array[i])
}
</code></pre>
<p>##for in 遍历元素</p>
<pre><code class="language-plain_text">// 第二种 for in 遍历元素
for s in array {
    print(s)
}
</code></pre>
<p>##enum block遍历</p>
<pre><code class="language-plain_text">// 第三种 enum block 遍历
for e in array.enumerated() {
    print(e)
}
</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">(0, &quot;张三&quot;)
(1, &quot;李四&quot;)
(2, &quot;王五&quot;)
</code></pre>
<p>我们可以看下e的类型--元组<br />
<img src="media/16587402969513/14789449636069.jpg" alt="" /></p>
<p>##元组方法遍历下标和内容<br />
由上面第三种方法我们可以知道 e 的类型是元组,那么同样我们可以直接使用元组</p>
<pre><code class="language-plain_text">// 第四种 元组使用
for (n,s) in array.enumerated() {
    print(&quot;\(n) \(s)&quot;)
}
</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">0 张三
1 李四
2 王五
</code></pre>
<p>##反序遍历</p>
<pre><code class="language-plain_text">// 第五种 反序遍历
for i in array.reversed() {
    print(i)
}
</code></pre>
<p>结果</p>
<pre><code class="language-plain_text">王五
李四
张三
</code></pre>
<p>##反序遍历 带索引</p>
<pre><code class="language-plain_text">// 第六种 反序遍历 带索引
for (n,s) in array.enumerated().reversed() {
    print(&quot;\(n) \(s)&quot;)
}
</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">2 王五
1 李四
0 张三
</code></pre>
<p>注意: <strong>先枚举再反序</strong></p>
<p>总结:Swift 太灵活了...</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402969749.html">其他人很少关注的页面</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>这里总结下大部分人不熟悉的页面.</p>
<p>##1. 秒杀</p>
<p>这个活动已经结束,代码位置:SecKill(秒杀)  调用这个活动不需要传递任何参数,只需要调用<code>XZSecKillViewController</code>就可以了.</p>
<p>链接在 <code>.m</code>文件的头部,是一个宏定义,方便修改.这个页面分为两个部分.一个是顶部的滚动条,能够显示相应的秒杀时刻,另一个是对应时间段的秒杀活动列表.这两个分别在两个控制器当中.</p>
<p>他们之间通过<code>XZSecKillTimeProtocol</code>代理进行数据传递.代理方法:</p>
<p><code>-(void)selectedProductId:(NSString *)productid;</code></p>
<p>时间段页面通过<code>-(void)congfigDetailWithCurrentTime:(NSInteger)currentTime DetailTime:(XZSecKillTime *)detailTime NextTime:(NSInteger)nextTime EndTime:(NSInteger)endTime;</code>列表页面显示该时间段的秒杀商品列表.</p>
<p>该活动在运营期间没有什么问题.如果再次开启秒杀活动出现问题最可能的地方就就是<strong>定时器</strong>出现了问题.需要检查的地方有</p>
<ol>
<li>
<p>服务器返回的当前时间,结束时间</p>
</li>
<li>
<p>代码中计算的当前时间,timer 运行是否正常.</p>
</li>
<li>
<p>跳转到下一个秒杀时间处理是否有问题.</p>
</li>
</ol>
<p>当前服务器配置的秒杀活动没有问题,如果下次再开启秒杀活动出现问题检测这几个地方就可以了.</p>
<h2><a id="%E5%95%86%E6%88%B7%E8%AF%A6%E6%83%85%E7%95%8C%E9%9D%A2%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>商户详情界面说明</h2>
<p>最原始的商户详情界面架构:<a href="https://github.com/Mekor/MKShowDetail">https://github.com/Mekor/MKShowDetail</a><br />
项目中对应的控制器<code>XZShopDetailController</code></p>
<p>###需要传递的参数</p>
<ol>
<li>项目刚开始的时候由于复杂度不是很高,而且流程比较单一,控制器之间传递的大部分都是模型,现在商户详情界面已经修改为传递<code>shopid</code></li>
<li>另一个需要传递的参数是进入页面的方式,普通的方式进入和扫描二维码方式进入.主要区别就是扫描二维码方式进入需要再调用添加关注</li>
</ol>
<p>###商户详情界面需要包含的自控制器</p>
<ol>
<li>WZShopDetailController</li>
<li>XZShowCouponViewController</li>
<li>XZProductListViewController</li>
</ol>
<p>最多包含这三个控制器,里面显示那个控制器可以随意控制,方法名:<code>- (void)addChildViewController</code><br />
这三个页面都是继承自<code>XZCustomViewController</code>,在<code>XZCustomViewController</code>中控制商户详情页面有背景图的高度和没背景图的高度还有标题栏的高度.<br />
<img src="media/16587402969749/14781382059544.jpg" alt="" /></p>
<p>需要注意的是<code>@property (copy, nonatomic) void(^changeNavigationBar)(CGFloat alpha);</code>通过这个属性可以控制导航栏的透明度.注:为什么不在控制器内部控制?原因:统一管理,需要更改导航栏状态就不需要再在三个控制器中分别进行了.只需要在<code>XZShopDetailController</code>中进行就好了.</p>
<p>###正在热卖页面<br />
对应的控制器<code>XZProductListViewController</code>这个页面有两点需要注意: 1. 左侧的tableView滑动的时候不影响其他控件. 2. 左右数据之间对应关系.</p>
<p>关于滚动的时候更改整体布局原因:</p>
<pre><code class="language-plain_text">/**
 *  给继承者使用的: tag:1024
 */
@property (nonatomic, strong) XZTableView *tableView;

</code></pre>
<p>这个tableView滚动时在<code>scrollViewDidScroll</code>中做了2个操作:</p>
<ol>
<li>调用<code>changeNavigationBar</code>这个block来给外面的控制器,让其更改导航栏的透明度等操作.</li>
<li>设置头部的高度.<code>@property (nonatomic, weak)  NSLayoutConstraint *headHCons;</code></li>
</ol>
<p>由于更改了头部约束使整个页面也都会跟着变化.</p>
<p>###原来的商户详情界面<br />
由于业务调整,原来的商户详情界面整合到新的商户详情界面中来了--&gt;店铺详情<code>WZShopDetailController</code>.<br />
这个界面主要不同点就是cell样式多变,所以这个界面我采用的是给cell传递一个 frame model,这样好处:</p>
<ol>
<li>只计算一次高度</li>
<li>视图只负责显示,所有布局都在frame model中进行.</li>
</ol>
<p>这样做有好处也有缺点:好处是清晰明了逻辑比较清晰,但是这意味着需要添加更多的文件.使用这种方式的界面:<br />
<img src="media/16587402969749/14781502496626.jpg" alt="测试店铺" /></p>
<p>使用这种方式很容易写出点评页面:<br />
<img src="media/16587402969749/14781505140226.jpg" alt="" /></p>
<p>逻辑顺序: <code>model -&gt; frame model - &gt; view</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402969971.html">h5版本入口：https://aipos.honghuotai.com/huoguo-app-web/</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>请求header中添加token<br />
登录接口：<code>post</code>  多商户选择商户后添加companyCode 后请求会返回token</p>
<pre><code class="language-plain_text">https://aipos.honghuotai.com:8919/login
</code></pre>
<p>参数：</p>
<pre><code class="language-plain_text">{
    &quot;userName&quot;:&quot;18801028497&quot;,
    &quot;password&quot;:&quot;zTgx5W/rHWKrwQSfvMyyuw==&quot;,
    &quot;osId&quot;:0,
    &quot;isMsgLogin&quot;:&quot;N&quot;,
    &quot;companyCode&quot;:&quot;&quot;
}
</code></pre>
<p>返回结果：</p>
<pre><code class="language-plain_text">{
    &quot;message&quot;:&quot;存在多商户&quot;,
    &quot;obj&quot;:[
        {
            &quot;area&quot;:&quot;&quot;,
            &quot;companyCode&quot;:&quot;967896&quot;,
            &quot;companyName&quot;:&quot;北京金盛通商贸有限公司&quot;,
            &quot;companyType&quot;:1,
            &quot;dr&quot;:&quot;N&quot;,
            &quot;enable&quot;:&quot;Y&quot;,
            &quot;id&quot;:&quot;3ACE1B0CA21A7BB9000163E0ADBA5000&quot;,
            &quot;ts&quot;:1541585780315
        },
        {
            &quot;brandName&quot;:&quot;甜暖我心咖啡店&quot;,
            &quot;businessLicense&quot;:&quot;099900&quot;,
            &quot;companyCode&quot;:&quot;hht003&quot;,
            &quot;companyName&quot;:&quot;甜暖我心咖啡店&quot;,
            &quot;companyType&quot;:1,
            &quot;dr&quot;:&quot;N&quot;,
            &quot;enable&quot;:&quot;Y&quot;,
            &quot;id&quot;:&quot;ABB81ED8E6FA11E791450894EF382663&quot;,
            &quot;isGroup&quot;:&quot;Y&quot;,
            &quot;ts&quot;:1495504548018
        },
        {
            &quot;area&quot;:&quot;&quot;,
            &quot;companyCode&quot;:&quot;973099&quot;,
            &quot;companyName&quot;:&quot;湖北燚火科技有限公司（演示）&quot;,
            &quot;companyType&quot;:2,
            &quot;dr&quot;:&quot;N&quot;,
            &quot;enable&quot;:&quot;Y&quot;,
            &quot;id&quot;:&quot;D6F13DFFD8000000D0000000001DE000&quot;,
            &quot;isGroup&quot;:&quot;N&quot;,
            &quot;ts&quot;:1519627953191
        },
        {
            &quot;area&quot;:&quot;&quot;,
            &quot;companyCode&quot;:&quot;687155&quot;,
            &quot;companyName&quot;:&quot;草根老火锅&quot;,
            &quot;companyType&quot;:1,
            &quot;dr&quot;:&quot;N&quot;,
            &quot;enable&quot;:&quot;Y&quot;,
            &quot;id&quot;:&quot;D8A314EC40000000A8000000001DE000&quot;,
            &quot;ts&quot;:1521449373858
        },
        {
            &quot;area&quot;:&quot;&quot;,
            &quot;companyCode&quot;:&quot;234686&quot;,
            &quot;companyName&quot;:&quot;浙江竹林人家餐饮有限公司&quot;,
            &quot;companyType&quot;:1,
            &quot;dr&quot;:&quot;N&quot;,
            &quot;enable&quot;:&quot;Y&quot;,
            &quot;id&quot;:&quot;DBC18C6BD8000000B0000000001DE000&quot;,
            &quot;ts&quot;:1524797013236
        },
        {
            &quot;area&quot;:&quot;&quot;,
            &quot;companyCode&quot;:&quot;726186&quot;,
            &quot;companyName&quot;:&quot;上海蒂昶实业有限公司&quot;,
            &quot;companyType&quot;:1,
            &quot;dr&quot;:&quot;N&quot;,
            &quot;enable&quot;:&quot;Y&quot;,
            &quot;id&quot;:&quot;E1F7DCDC0C000000A8000000001DE000&quot;,
            &quot;ts&quot;:1531468298479
        },
        {
            &quot;area&quot;:&quot;BDB056AC58000000800000000016E002,BDB0891008000000800000000016E000&quot;,
            &quot;companyCode&quot;:&quot;927555&quot;,
            &quot;companyName&quot;:&quot;北京为之味餐饮有限公司&quot;,
            &quot;companyType&quot;:1,
            &quot;dr&quot;:&quot;N&quot;,
            &quot;enable&quot;:&quot;Y&quot;,
            &quot;id&quot;:&quot;E5558A2A00000000A8000000001DE000&quot;,
            &quot;ts&quot;:1535085509596
        },
        {
            &quot;area&quot;:&quot;&quot;,
            &quot;companyCode&quot;:&quot;623741&quot;,
            &quot;companyName&quot;:&quot;重庆吉之源餐饮有限公司&quot;,
            &quot;companyType&quot;:1,
            &quot;dr&quot;:&quot;N&quot;,
            &quot;enable&quot;:&quot;Y&quot;,
            &quot;id&quot;:&quot;EE953E8D00000000A0000000001DE000&quot;,
            &quot;ts&quot;:1545011965051
        }
    ],
    &quot;result&quot;:201
}
</code></pre>
<hr />
<p>获取所有商户：</p>
<pre><code class="language-plain_text">https://aipos.honghuotai.com:8961/shop/getShops?companyId=DBC18C6BD8000000B0000000001DE000
</code></pre>
<p>参数：<code>GET</code></p>
<pre><code class="language-plain_text">companyId=DBC18C6BD8000000B0000000001DE000
</code></pre>
<p>返回结果：</p>
<pre><code class="language-plain_text">{
    &quot;code&quot;:200,
    &quot;data&quot;:[
        {
            &quot;id&quot;:&quot;36F08443ECFFE777000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;阿拉大牌档-聚亿店&quot;,
            &quot;shopNo&quot;:&quot;234284&quot;
        },
        {
            &quot;id&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
            &quot;shopNo&quot;:&quot;355601&quot;
        },
        {
            &quot;id&quot;:&quot;38B6AB267B5738F7000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;寻浙里-环球城店&quot;,
            &quot;shopNo&quot;:&quot;174487&quot;
        },
        {
            &quot;id&quot;:&quot;397ADD5589A704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-海港城店&quot;,
            &quot;shopNo&quot;:&quot;59167&quot;
        },
        {
            &quot;id&quot;:&quot;397B416109A704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-宏泰广场店&quot;,
            &quot;shopNo&quot;:&quot;992076&quot;
        },
        {
            &quot;id&quot;:&quot;397BA31A20A704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-洪塘店&quot;,
            &quot;shopNo&quot;:&quot;549449&quot;
        },
        {
            &quot;id&quot;:&quot;397BAAEC83A704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-宁海店&quot;,
            &quot;shopNo&quot;:&quot;177851&quot;
        },
        {
            &quot;id&quot;:&quot;397BABBEF1A704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-天伦广场店&quot;,
            &quot;shopNo&quot;:&quot;650812&quot;
        },
        {
            &quot;id&quot;:&quot;397BADB60FA704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-银亿都会店&quot;,
            &quot;shopNo&quot;:&quot;957159&quot;
        },
        {
            &quot;id&quot;:&quot;397BAF1782A704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-银亿东岸里店&quot;,
            &quot;shopNo&quot;:&quot;965022&quot;
        },
        {
            &quot;id&quot;:&quot;397BB4C8BAA704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;老宁波1381餐厅-鄞州利时店&quot;,
            &quot;shopNo&quot;:&quot;753473&quot;
        },
        {
            &quot;id&quot;:&quot;397BB7E18BA704A8000163E0ADBA5000&quot;,
            &quot;shopName&quot;:&quot;竹林人家-大剧院店&quot;,
            &quot;shopNo&quot;:&quot;243456&quot;
        }
    ]
}
</code></pre>
<hr />
<p>要货管理接口：<code>post</code></p>
<pre><code class="language-plain_text">https://aipos.honghuotai.com:8961/scmgoodsrequiredh/page
</code></pre>
<p>参数：sortSelect: 0-&gt;全部 1-&gt;待审核 2-&gt; 待上报 3-&gt;已上报 4-&gt;上报失败</p>
<pre><code class="language-plain_text">{
    &quot;pageNum&quot;:1,
    &quot;pageSize&quot;:10,
    &quot;sortSelect&quot;:1,
    &quot;params&quot;:{
        &quot;shopId&quot;:&quot;36F08443ECFFE777000163E0ADBA5000&quot;,
        &quot;companyId&quot;:&quot;DBC18C6BD8000000B0000000001DE000&quot;,
        &quot;billType&quot;:&quot;&quot;,
        &quot;applyDateStart&quot;:&quot;&quot;,
        &quot;applyDateEnd&quot;:&quot;&quot;,
        &quot;expectArrvDateStart&quot;:&quot;&quot;,
        &quot;expectArrvDateEnd&quot;:&quot;&quot;,
        &quot;billNo&quot;:&quot;&quot;,
        &quot;docMakerName&quot;:&quot;&quot;,
        &quot;isStaffMealRequired&quot;:&quot;&quot;,
        &quot;status&quot;:&quot;8&quot;,
        &quot;erpBillNo&quot;:&quot;&quot;,
        &quot;sort&quot;:&quot;descending&quot;,
        &quot;sortName&quot;:&quot;documentsTime&quot;,
        &quot;dishRequiredId&quot;:&quot;&quot;
    }
}
</code></pre>
<p>返回结果：</p>
<pre><code class="language-plain_text">{
    &quot;code&quot;:200,
    &quot;data&quot;:{
        &quot;content&quot;:[
            {
                &quot;applyDate&quot;:1570723200000,
                &quot;applyDateStr&quot;:&quot;2019-10-11&quot;,
                &quot;billNo&quot;:&quot;YH355601201910110001&quot;,
                &quot;companyId&quot;:&quot;DBC18C6BD8000000B0000000001DE000&quot;,
                &quot;dishRequiredId&quot;:&quot;&quot;,
                &quot;dishRequiredName&quot;:&quot;&quot;,
                &quot;dishRequiredNo&quot;:&quot;&quot;,
                &quot;docMakerName&quot;:&quot;测试&quot;,
                &quot;documentMakerId&quot;:&quot;370B542518FF5AA5000163E0ADBA5000&quot;,
                &quot;documentsTime&quot;:1570787479100,
                &quot;documentsTimeStr&quot;:&quot;2019-10-11 17:51:19&quot;,
                &quot;erpBillNo&quot;:&quot;&quot;,
                &quot;errorRemark&quot;:&quot;&quot;,
                &quot;expectArrvDate&quot;:1570809600000,
                &quot;goodsRequiredCategoryIds&quot;:&quot;&quot;,
                &quot;goodsRequiredCategoryNames&quot;:&quot;&quot;,
                &quot;id&quot;:&quot;41A5ADCA7CCB2ACF000163E0ADBA5000&quot;,
                &quot;isGeneInstockBill&quot;:&quot;N&quot;,
                &quot;isStaffMealRequired&quot;:&quot;N&quot;,
                &quot;materialCategoryAmount&quot;:1,
                &quot;materialCategoryAmountStr&quot;:&quot;1种&quot;,
                &quot;remark&quot;:&quot;&quot;,
                &quot;requiredModelName&quot;:&quot;&quot;,
                &quot;requiredModelNo&quot;:&quot;&quot;,
                &quot;requiredType&quot;:2,
                &quot;requiredTypeStr&quot;:&quot;直配&quot;,
                &quot;save&quot;:false,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;signTimeStr&quot;:&quot;&quot;,
                &quot;status&quot;:&quot;待审核&quot;,
                &quot;statusStr&quot;:&quot;待审核&quot;,
                &quot;ts&quot;:1570787479100
            }
        ],
        &quot;extraData&quot;:{

        },
        &quot;pageNum&quot;:1,
        &quot;pageSize&quot;:10,
        &quot;totalNum&quot;:1,
        &quot;totalPage&quot;:1
    }
}
</code></pre>
<hr />
<p>收货管理接口：<code>post</code></p>
<pre><code class="language-plain_text">https://aipos.honghuotai.com:8961/goodsCollect/list
</code></pre>
<p>参数：status 为&quot;&quot;-&gt; 全部  &quot;0&quot;-&gt;待签收 &quot;1&quot;-&gt;已签收</p>
<pre><code class="language-plain_text">{
    &quot;companyId&quot;:&quot;DBC18C6BD8000000B0000000001DE000&quot;,
    &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
    &quot;storageStartDate&quot;:&quot;2019-11-24&quot;,
    &quot;storageEndDate&quot;:&quot;2019-12-24&quot;,
    &quot;applyDateStart&quot;:&quot;&quot;,
    &quot;applyDateEnd&quot;:&quot;&quot;,
    &quot;expectDateStart&quot;:&quot;&quot;,
    &quot;expectDateEnd&quot;:&quot;&quot;,
    &quot;sort&quot;:&quot;&quot;,
    &quot;sortName&quot;:&quot;&quot;,
    &quot;warehouseName&quot;:&quot;&quot;,
    &quot;supplierName&quot;:&quot;&quot;,
    &quot;status&quot;:&quot;&quot;,
    &quot;reportState&quot;:&quot;&quot;,
    &quot;pageSize&quot;:10,
    &quot;pageNum&quot;:1,
    &quot;userId&quot;:&quot;370B542518FF5AA5000163E0ADBA5000&quot;
}
</code></pre>
<p>返回结果:</p>
<pre><code class="language-plain_text">{
    &quot;code&quot;:200,
    &quot;data&quot;:{
        &quot;content&quot;:[
            {
                &quot;supplierName&quot;:&quot;万三龙&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:2,
                &quot;supplierCode&quot;:&quot;2020048&quot;,
                &quot;warehouseName&quot;:&quot;余姚—烧烤铺分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911240003&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574564845000,
                &quot;instockBillId&quot;:&quot;428B9270D10ADC04000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;万三龙&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:3,
                &quot;supplierCode&quot;:&quot;2020048&quot;,
                &quot;warehouseName&quot;:&quot;余姚—时蔬铺分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911240004&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574564846000,
                &quot;instockBillId&quot;:&quot;428B9411C10ADC04000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;万三龙&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:24,
                &quot;supplierCode&quot;:&quot;2020048&quot;,
                &quot;warehouseName&quot;:&quot;余姚—热菜铺分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911240002&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574564843000,
                &quot;instockBillId&quot;:&quot;428B9949BF0ADC04000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;万三龙&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:3,
                &quot;supplierCode&quot;:&quot;2020048&quot;,
                &quot;warehouseName&quot;:&quot;余姚—冷菜铺分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911240005&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574564844000,
                &quot;instockBillId&quot;:&quot;428B99F6360ADC04000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;万三龙&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:9,
                &quot;supplierCode&quot;:&quot;2020048&quot;,
                &quot;warehouseName&quot;:&quot;余姚—员工餐分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911240001&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574564843000,
                &quot;instockBillId&quot;:&quot;429363B9EC286ED5000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;宁波市海曙心怡禽业专业合作社&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:1,
                &quot;supplierCode&quot;:&quot;2020007&quot;,
                &quot;warehouseName&quot;:&quot;余姚—员工餐分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911280001&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574895063000,
                &quot;instockBillId&quot;:&quot;42A228E64347F0CC000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;宁波市海曙心怡禽业专业合作社&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:1,
                &quot;supplierCode&quot;:&quot;2020007&quot;,
                &quot;warehouseName&quot;:&quot;余姚—热菜铺分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911280002&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574895063000,
                &quot;instockBillId&quot;:&quot;42A228FDFD47F0CC000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;宁波市海曙心怡禽业专业合作社&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:1,
                &quot;supplierCode&quot;:&quot;2020007&quot;,
                &quot;warehouseName&quot;:&quot;余姚—烤鸡铺分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911280003&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574895064000,
                &quot;instockBillId&quot;:&quot;42A229132547F0CC000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;冯国金&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:1,
                &quot;supplierCode&quot;:&quot;2020014&quot;,
                &quot;warehouseName&quot;:&quot;余姚—烧烤铺分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911280004&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574898719000,
                &quot;instockBillId&quot;:&quot;42A229298747F0CC000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            },
            {
                &quot;supplierName&quot;:&quot;冯国金&quot;,
                &quot;shopCode&quot;:&quot;355601&quot;,
                &quot;instockBillType&quot;:&quot;直配&quot;,
                &quot;shopName&quot;:&quot;老宁波1381餐厅-余姚店&quot;,
                &quot;goodsRequiredCategoryAmount&quot;:1,
                &quot;supplierCode&quot;:&quot;2020014&quot;,
                &quot;warehouseName&quot;:&quot;余姚—热菜铺分仓&quot;,
                &quot;instockBillNo&quot;:&quot;RK355601201911280005&quot;,
                &quot;instockBillDocName&quot;:&quot;董晓幸&quot;,
                &quot;instockBillDocTime&quot;:1574898720000,
                &quot;instockBillId&quot;:&quot;42A229400947F0CC000163E0ADBA5000&quot;,
                &quot;reportState&quot;:&quot;已上报&quot;,
                &quot;sourceBillId&quot;:&quot;&quot;,
                &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
                &quot;status&quot;:&quot;已入库&quot;
            }
        ],
        &quot;extraData&quot;:{

        },
        &quot;pageNum&quot;:1,
        &quot;pageSize&quot;:10,
        &quot;totalNum&quot;:1426,
        &quot;totalPage&quot;:143
    }
}
</code></pre>
<hr />
<p>盘点管理接口：<code>post</code></p>
<pre><code class="language-plain_text">https://aipos.honghuotai.com:8961/scmcheck/page
</code></pre>
<p>参数：status &quot;&quot;-&gt;全部 &quot;1&quot;-&gt;待处理 &quot;2&quot;-&gt;处理中 &quot;3&quot;-&gt;已完成 &quot;5&quot;-&gt;已驳回</p>
<pre><code class="language-plain_text">{
    &quot;pageNum&quot;:1,
    &quot;pageSize&quot;:10,
    &quot;params&quot;:{
        &quot;docMakerName&quot;:&quot;&quot;,
        &quot;billno&quot;:&quot;&quot;,
        &quot;checkDateBegin&quot;:&quot;2019-12-24&quot;,
        &quot;checkDateEnd&quot;:&quot;2019-12-24&quot;,
        &quot;checkType&quot;:&quot;&quot;,
        &quot;companyId&quot;:&quot;DBC18C6BD8000000B0000000001DE000&quot;,
        &quot;shopId&quot;:&quot;37EE6D387C5738F7000163E0ADBA5000&quot;,
        &quot;warehouseId&quot;:&quot;&quot;,
        &quot;sort&quot;:&quot;descending&quot;,
        &quot;sortName&quot;:&quot;creatTime&quot;,
        &quot;warehouseName&quot;:&quot;&quot;,
        &quot;status&quot;:&quot;&quot;
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402970215.html">如何给View添加点击事件</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>项目中有很多地方需要添加点击事件,重复代码很多,所以做了一个UIView的分类,专门做点击事件使用.<br />
项目地址:<a href="https://github.com/Mekor/UIView-Tap">UIView-Tap</a></p>
<p>代码很简单,主要有一点就是注意分类不能直接添加属性,需要用到运行时相关内容.</p>
<p>代码如下:</p>
<pre><code class="language-plain_text">\\UIView+Tap.h文件
@interface UIView (Tap)
- (void)addTapBlock:(void(^)(id obj))tapAction;
@end

\\UIView+Tap.m文件
#import &lt;objc/runtime.h&gt;

static const void* tagValue = &amp;tagValue;

@interface UIView ()
@property (nonatomic, copy) void(^tapAction)(id);
@end

@implementation UIView (Tap)
- (void)tap{
    if (self.tapAction) {
        self.tapAction(self);
    }
}
- (void)addTapBlock:(void(^)(id obj))tapAction{
    self.tapAction = tapAction;
    if (![self gestureRecognizers]) {
        self.userInteractionEnabled = YES;
        UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];
        [self addGestureRecognizer:tap];
    }
}

-(void)setTapAction:(void (^)(id))tapAction {
    objc_setAssociatedObject(self, tagValue, tapAction, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
-(void (^)(id))tapAction {
    return objc_getAssociatedObject(self, tagValue);
}
@end
</code></pre>
<p>正如大家所见,如果要接收点击事件,必须userInteractionEnabled设置为YES,所以不管怎么只要确认要给视图添加点击事件,都会被设置为<code>userInteractionEnabled = YES</code></p>
<p>简单实用:</p>
<pre><code class="language-plain_text">UIView *redView = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];
redView.backgroundColor = [UIColor redColor];
[redView addTapBlock:^(UIView* obj) {
    NSLog(@&quot;redView%@&quot;,obj.backgroundColor);
}];
[self.view addSubview:redView];

UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 250, 100, 100)];
imageView.image = [UIImage imageNamed:@&quot;icon&quot;];
[imageView addTapBlock:^(UIImageView* obj) {
    NSLog(@&quot;imageView:\n%@&quot;,obj.image);
}];
[self.view addSubview:imageView];

UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(150, 400, 100, 100)];
label.text = @&quot;这是label,点击这里...&quot;;
[label addTapBlock:^(UILabel* obj) {
    NSLog(@&quot;label:\n%@&quot;,obj.text);
}];
[self.view addSubview:label];

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402970428.html">CAGradientLayer</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:36+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="creating-a-cagradientlayer-https-stackoverflow-comdocumentationios1190cagradientlayer3856creating-a-cagradientlayer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/3856/creating-a-cagradientlayer">Creating a CAGradientLayer</a></h2>
<pre><code class="language-plain_text">// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.red.cgColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.yellow.cgColor

// Set colors.
gradientLayer.colors = [topColor, bottomColor]

// Set locations of the colors.
gradientLayer.locations = [0.0, 1.0]

// Insert gradient layer into view's layer heirarchy.
view.layer.insertSublayer(gradientLayer, at: 0)
</code></pre>
<p>Result :</p>
<p><img src="media/16587402970428/q26bv.png" alt="Simple CAGradientLayer." /></p>
<p>##<a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/12652/animating-a-color-change-in-cagradientlayer">Animating a color change in CAGradientLayer.</a></p>
<pre><code class="language-plain_text">// Get the current colors of the gradient.
let oldColors = self.gradientLayer.colors

// Define the new colors for the gradient.
let newColors = [UIColor.red.cgColor, UIColor.yellow.cgColor]

// Set the new colors of the gradient.
self.gradientLayer.colors = newColors

// Initialize new animation for changing the colors of the gradient.
let animation: CABasicAnimation = CABasicAnimation(keyPath: &quot;colors&quot;)

// Set current color value.
animation.fromValue = oldColors

// Set new color value.
animation.toValue = newColors

// Set duration of animation.
animation.duration = 0.3

// Set animation to remove once its completed.
animation.isRemovedOnCompletion = true

// Set receiver to remain visible in its final state when the animation is completed.
animation.fillMode = kCAFillModeForwards

// Set linear pacing, which causes an animation to occur evenly over its duration.
animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear)

// Set delegate of animation.
animation.delegate = self

// Add the animation.
self.gradientLayer.addAnimation(animation, forKey: &quot;animateGradientColorChange&quot;)
</code></pre>
<p>Result :</p>
<p><img src="media/16587402970428/AquKd.gif" alt="Basic CAGradientLayer color change animation." /></p>
<p>##<a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4229/creating-a-horizontal-cagradientlayer-with-multiple-colors">Creating a horizontal CAGradientLayer with multiple colors.</a></p>
<pre><code class="language-plain_text">// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.greenColor().CGColor

// Color at the middle of the gradient.
let middleColor: CGColor = UIColor.blueColor().CGColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.blackColor().CGColor

// Set colors.
gradientLayer.colors = [topColor, middleColor, bottomColor]

// Set start point.
gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)

// Set end point.
gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5)

// Insert gradient layer into view's layer heirarchy.
view.layer.insertSublayer(gradientLayer, atIndex: 0)
</code></pre>
<p>Result :</p>
<p><img src="media/16587402970428/I4OGH.png" alt="enter image description here" /></p>
<p>##<a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4228/creating-a-horizontal-cagradientlayer">Creating a horizontal CAGradientLayer.</a></p>
<pre><code class="language-plain_text">// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.redColor().CGColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.yellowColor().CGColor

// Set colors.
gradientLayer.colors = [topColor, bottomColor]

// Set start point.
gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)

// Set end point.
gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5)

// Insert gradient layer into view's layer heirarchy.
view.layer.insertSublayer(gradientLayer, atIndex: 0)
</code></pre>
<p>Result :</p>
<p><img src="media/16587402970428/7VCnW.png" alt="Horizontal CAGradientLayer." /></p>
<p>##<a href="https://stackoverflow.com/documentation/ios/1190/cagradientlayer/4227/creating-a-cggradientlayer-with-multiple-colors">Creating a CGGradientLayer with multiple colors.</a></p>
<pre><code class="language-plain_text">// View to hold the CAGradientLayer.
let view: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 320))

// Initialize gradient layer.
let gradientLayer: CAGradientLayer = CAGradientLayer()

// Set frame of gradient layer.
gradientLayer.frame = view.bounds

// Color at the top of the gradient.
let topColor: CGColor = UIColor.blue.cgColor

// Color at the middle of the gradient.
let middleColor: CGColor = UIColor.yellow.cgColor

// Color at the bottom of the gradient.
let bottomColor: CGColor = UIColor.green.cgColor

// Set colors.
gradientLayer.colors = [topColor, middleColor, bottomColor]

// Set locations of the colors.
gradientLayer.locations = [0.0, 0.5, 1.0]

// Insert gradient layer into view's layer heirarchy.
view.layer.insertSublayer(gradientLayer, at: 0)
</code></pre>
<p>Result :</p>
<p><img src="media/16587402970428/tV4OL.png" alt="Complex CAGradientLayer." /></p>
<hr />
<h2><a id="syntax" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Syntax</h2>
<pre><code class="language-plain_text">CAGradientLayer() // Returns an initialized CALayer object.
-------------------
CAGradientLayer(layer: layer) // Override to copy or initialize custom fields of the specified layer.
</code></pre>
<h2><a id="parameters" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Parameter</th>
<th style="text-align: left">Details</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">color</td>
<td style="text-align: left">An array of <code>CGColorRef</code> objects defining the color of each gradient stop. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">locations</td>
<td style="text-align: left">An optional array of <code>NSNumber</code> objects defining the location of each gradient stop. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">endPoint</td>
<td style="text-align: left">The end point of the gradient when drawn in the layer’s coordinate space. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">startPoint</td>
<td style="text-align: left">The start point of the gradient when drawn in the layer’s coordinate space. Animatable.</td>
</tr>
<tr>
<td style="text-align: left">type</td>
<td style="text-align: left">Style of gradient drawn by the layer. Defaults to <code>kCAGradientLayerAxial</code>.</td>
</tr>
</tbody>
</table>
<h2><a id="remarks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Remarks</h2>
<ul>
<li>Use <code>startPoint</code> and <code>endPoint</code> to change the orientation of the <code>CAGradientLayer</code>.</li>
<li>Use the <code>locations</code> to affect the spread/positions of the colors.</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402950437.html">引用类型用法总结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步 去掌握引用类型的使用方式。基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，那么当然引用类 型也是可以的。</p>
<h2><a id="4-1-class%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1 class作为成员变量</h2>
<p>在定义一个类Role（游戏角色）时，代码如下：</p>
<pre><code class="language-plain_text">class Role {
     int id; // 角色id 
     int blood; // 生命值 
     String name; // 角色名称 
}
</code></pre>
<p>使用 <code>int</code> 类型表示 角色id和生命值，使用 <code>String</code> 类型表示姓名。此时， <code>String</code> 本身就是引用类型，由于使用 的方式类似常量，所以往往忽略了它是引用类型的存在。如果我们继续丰富这个类的定义，给 <code>Role</code> 增加武器，穿 戴装备等属性，我们将如何编写呢？</p>
<p>定义武器类，将增加攻击能力：</p>
<pre><code class="language-plain_text">class Weapon {
     String name； // 武器名称 
     int hurt； // 伤害值 
}
</code></pre>
<p>定义穿戴盔甲类，将增加防御能力，也就是提升生命值：</p>
<pre><code class="language-plain_text">class Armour {
     String name；// 装备名称 
     int protect；// 防御值 
}
</code></pre>
<p>定义角色类：</p>
<pre><code class="language-plain_text">class Role {
    
    int id； 
    int blood； 
    String name； // 添加武器属性 
    Weapon wp； // 添加盔甲属性 
    Armour ar；
    
    // 提供get/set方法
    public Weapon getWp() {
        return wp; 
    } 
    public void setWeapon(Weapon wp) {
        this.wp = wp;
    } 
    public Armour getArmour() {
        return ar; 
    } 
    public void setArmour(Armour ar) {
        this.ar = ar; 
    }
    
    // 攻击方法 
    public void attack(){ 
        System.out.println(&quot;使用&quot;+ wp.getName() +&quot;, 造成&quot;+wp.getHurt()+&quot;点伤害&quot;); 
    }
    
    // 穿戴盔甲 
    public void wear(){
        // 增加防御,就是增加blood值
        this.blood += ar.getProtect();
        System.out.println(&quot;穿上&quot;+ar.getName()+&quot;, 生命值增加&quot;+ar.getProtect()); 
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-plain_text">public class Test {

    public static void main(String[] args) {
         // 创建Weapon 对象 
         Weapon wp = new Weapon(&quot;屠龙刀&quot; , 999999); 
         // 创建Armour 对象 
         Armour ar = new Armour(&quot;麒麟甲&quot;,10000); 
         // 创建Role 对象 
         Role r = new Role();
        
        // 设置武器属性 
        r.setWeapon(wp);
        // 设置盔甲属性 
        r.setArmour(ar);
        
        // 攻击 
        r.attack(); 
        // 穿戴盔甲 
        r.wear();
    }

} 

输出结果: 使用屠龙刀,造成999999点伤害 穿上麒麟甲 ,生命值增加10000
</code></pre>
<blockquote>
<p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。</p>
</blockquote>
<h2><a id="4-2-interface%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2 interface作为成员变量</h2>
<p>接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在 <code>Role</code> 中，可以增加接口作为成员变量，来设置不同的技能。</p>
<p>定义接口：</p>
<pre><code class="language-plain_text">// 法术攻击 
public interface FaShuSkill { 
    public abstract void faShuAttack();
}
</code></pre>
<p>定义角色类：</p>
<pre><code class="language-plain_text">public class Role { 
    FaShuSkill fs;
    
    public void setFaShuSkill(FaShuSkill fs) {
        this.fs = fs; 
    } 
    // 法术攻击 public 
    void faShuSkillAttack(){
        System.out.print(&quot;发动法术攻击:&quot;);
        fs.faShuAttack();
        System.out.println(&quot;攻击完毕&quot;); 
    }
}
</code></pre>
<p>定义测试类：</p>
<pre><code class="language-plain_text">public class Test {
    
    public static void main(String[] args) { 
        // 创建游戏角色 
        Role role = new Role(); 
        // 设置角色法术技能 
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void faShuAttack() { 
                System.out.println(&quot;纵横天下&quot;); 
            }
        });
        
        // 发动法术攻击 
        role.faShuSkillAttack();
        
        // 更换技能 
        role.setFaShuSkill(new FaShuSkill() {
            @Override
            public void faShuAttack() {
            System.out.println(&quot;逆转乾坤&quot;);
            } 
        }); 
        // 发动法术攻击 
        role.faShuSkillAttack();
    }
} 

输出结果: 发动法术攻击:纵横天下 攻击完毕

发动法术攻击:逆转乾坤 攻击完毕
</code></pre>
<blockquote>
<p>我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。 接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。</p>
</blockquote>
<h2><a id="4-3-interface%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.3 interface作为方法参数和返回值类型</h2>
<p>当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的 子类对象。<code>ArrayList</code> 类我们并不陌生，查看API我们发现，实际上，它是 <code>java.util.List</code> 接口的实现类。所以，当我们看见 <code>List</code> 接口作为参数或者返回值类型时，当然可以将 <code>ArrayList</code> 的对象进行传递或返回。 请观察如下方法：<strong>获取某集合中所有的偶数。</strong><br />
定义方法：</p>
<pre><code class="language-plain_text">public static List&lt;Integer&gt; getEvenNum(List&lt;Integer&gt; list) { 
    // 创建保存偶数的集合 
    ArrayList&lt;Integer&gt; evenList = new ArrayList&lt;&gt;(); 
    // 遍历集合list,判断元素为偶数,就添加到evenList中 
    for (int i = 0; i &lt; list.size(); i++) {
        Integer integer = list.get(i);
        if (integer % 2 == 0) { 
            evenList.add(integer); 
        }
    } 
    /*
    返回偶数集合 因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类,
    因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类, 所以evenList可以返回 
    */ 
    return evenList;
}
</code></pre>
<p>调用方法：</p>
<pre><code class="language-plain_text">public class Test {
    
    public static void main(String[] args) { 
        // 创建ArrayList集合,并添加数字 
        ArrayList&lt;Integer&gt; srcList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            srcList.add(i); 
        }
        /* 
        获取偶数集合 因为getEvenNum方法的参数是List,而ArrayList是List的子类, 所以srcList可以传递 
        */ 
        List list = getEvenNum(srcList);
        System.out.println(list);
    }
}
</code></pre>
<blockquote>
<p>接口作为参数时，传递它的子类对象。 接口作为返回值类型时，返回它的子类对象。</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402950578.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>{<br />
body =     {<br />
DATA =         {<br />
operatorid = 10002604;<br />
operatorpwd = 123456;<br />
};<br />
};<br />
header =     {<br />
ALERTMESSAGE = &quot;&quot;;<br />
BUSINESSID = tzxUserLoginService;<br />
CLIENTVERSION = &quot;&quot;;<br />
DEVICETYPE = 1;<br />
IP = &quot;192.168.21.160&quot;;<br />
LANGUAGE = 1;<br />
LASTBUSINESSID = &quot;&quot;;<br />
LASTDOSERVERTIME = &quot;&quot;;<br />
MAC = &quot;E0:B9:BA:29:52:35&quot;;<br />
PADVERSION = &quot;8.7.2017.1.16&quot;;<br />
RESULTCODE = &quot;&quot;;<br />
TABLEID = 006;<br />
UICOUNT = &quot;&quot;;<br />
UIID = &quot;&quot;;<br />
UUID = &quot;229E9DDA-91B2-4668-9BD1-C4E26F31CB8B&quot;;<br />
WAITERID = 10000583;<br />
billNo = 0000656527;<br />
flag = ch;<br />
remark1 = &quot;&quot;;<br />
remark2 = &quot;&quot;;<br />
remark3 = &quot;&quot;;<br />
remark4 = &quot;&quot;;<br />
remark5 = &quot;&quot;;<br />
};<br />
}</p>
<p>bodyDic = {<br />
DATA =     {<br />
accountEntity = 0;<br />
tableStaffEntitieList =         (<br />
{<br />
callbacks =                 (<br />
{<br />
}<br />
);<br />
deviceID = &quot;E0:B9:BA:29:52:35&quot;;<br />
tableID = 006;<br />
},<br />
{<br />
callbacks =                 (<br />
{<br />
}<br />
);<br />
deviceID = &quot;E0:B9:BA:29:52:35&quot;;<br />
tableID = 020;<br />
},<br />
{<br />
callbacks =                 (<br />
{<br />
}<br />
);<br />
deviceID = &quot;E0:B9:BA:29:52:35&quot;;<br />
tableID = 028;<br />
},<br />
{<br />
callbacks =                 (<br />
{<br />
}<br />
);<br />
deviceID = &quot;E0:B9:BA:29:52:35&quot;;<br />
tableID = 035;<br />
},<br />
{<br />
callbacks =                 (<br />
{<br />
}<br />
);<br />
deviceID = &quot;E0:B9:BA:29:52:35&quot;;<br />
tableID = 039;<br />
},<br />
{<br />
callbacks =                 (<br />
{<br />
}<br />
);<br />
deviceID = &quot;E0:B9:BA:29:52:35&quot;;<br />
tableID = 062;<br />
},<br />
{<br />
callbacks =                 (<br />
{<br />
}<br />
);<br />
deviceID = &quot;E0:B9:BA:29:52:35&quot;;<br />
tableID = 096;<br />
}<br />
);<br />
tzxData = &quot;&quot;;<br />
};<br />
}</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402950729.html">如何判等equals</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p><a href="https://stackoverflow.com/questions/9506303/public-boolean-equalsobject-other">Stackoverflow</a> 中有其他人提的写法，我感觉公司项目中的写法不错记录下</p>
</blockquote>
<pre><code class="language-plain_text">    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof CreateOrderDTO)) return false;
        CreateOrderDTO that = (CreateOrderDTO) o;
        return Objects.equal(getBusiId(), that.getBusiId()) &amp;&amp;
                Objects.equal(getBusiType(), that.getBusiType()) &amp;&amp;
                Objects.equal(getOrderAmount(), that.getOrderAmount());
    }
</code></pre>
<p>重写<a href="https://kapeli.com/dash_share?docset_file=Java&amp;docset_name=Java%20SE10&amp;path=java/lang/Object.html%23equals(java.lang.Object)&amp;platform=java&amp;repo=Main&amp;version=SE10">equals</a>需要满足 自反性，对称性，传递性，一致性，非空</p>
<p><img src="media/16587402950729/15465935663846.jpg" alt="" style="width:588px;" /></p>
<h2><a id="%E4%B8%8Eequals" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>== 与 equals</h2>
<p><em><strong>==</strong></em> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>
<p><em><strong>equals()</strong></em> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。<br />
情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402950880.html">Typescript</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简介</h2>
<p>typescript是JavaScript的超集。掌握typescript中的原始类型、字面量类型、数组类型、函数类型、类类型、接口类型、类型别名、联合与交叉类型、枚举类型、泛型等类型元素。以及推断、类型断言、类型缩小、类型放大等特性。<br />
相比于JavaScript更加严谨，编写代码的时候静态类型校验。<br />
安装<a href="https://www.npmjs.com/package/typescript">typescript环境</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402951024.html">Swift - 上周问题总结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>懒加载的正确姿势</h2>
<blockquote>
<p>使用Swift的时候用懒加载,但是我发现我使用的时候不能再懒加载中调用本文件中声明的属性,原因是我在写懒加载的时候没有注明类型,正确的姿势应该是:</p>
</blockquote>
<pre><code class="language-plain_text">    lazy var &lt;#property name#&gt;: &lt;#type name#&gt; = {
        &lt;#statements#&gt;
        return &lt;#value#&gt;
    }()
</code></pre>
<p>快捷键<br />
<img src="media/16587402951024/14815536582812.jpg" alt="" /><br />
采用这种方式声明的懒加载能够在内部使用self</p>
<h2><a id="oc%E4%B8%AD%E7%94%A8kvc%E8%B5%8B%E5%80%BC%E4%BD%BF-nsstring%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%90%91%E4%BA%86nsnumber%E5%AF%BC%E8%87%B4-swift%E4%B8%AD%E8%B0%83%E7%94%A8%E5%B4%A9%E6%BA%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>OC中用KVC赋值,使NSString类型指向了NSNumber,导致Swift中调用崩溃</h2>
<blockquote>
<p>崩溃信息:<code>reason: '-[__NSCFNumber length]: unrecognized selector sent to instance 0x00000XXXX</code></p>
</blockquote>
<p>原因分析:NSString指向的数据类型为NSNumber的数据,取值时崩溃.第一种方案找到赋值有误的地方修改,第二不修改原有的代码,提出一种解决方案,重写NSString数据的<code>set</code>方法,赋值前判断数据类型,如果是NSNumber类型就转换成NSString类型.ß®</p>
<h2><a id="%E8%A7%86%E5%9B%BE%E5%B1%82%E7%BA%A7%E6%B7%B1%E5%86%85%E9%83%A8%E8%A7%86%E5%9B%BE%E5%A6%82%E4%BD%95%E9%80%9A%E7%9F%A5%E6%8E%A7%E5%88%B6%E5%99%A8%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>视图层级深,内部视图如何通知控制器数据更新?</h2>
<p>我想到的一种方法是把函数当做参数来传递,这样能够在一定程度上减少层级结构.甲冠提出设置一个属性,然后在属性的<code>didSet</code>中调用方法.目前还没有做实践,目测层级结构没有任何减少,但是代码量会少些.需要实验验证下.</p>
<p>**注:**讨论中间有讨论MVC框架,这里附上苹果多MVC的介绍:<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW1">https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW1</a></p>
<p>传统:<br />
<img src="media/16587402951024/14815566784560.gif" alt="" /></p>
<p>Cocoa:<br />
<img src="media/16587402951024/14815567675257.gif" alt="" /></p>
<h2><a id="xcode%E5%8D%87%E7%BA%A7%E5%90%8E%E9%83%A8%E5%88%86%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%8A%A5%E9%94%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Xcode升级后部分第三方库报错</h2>
<p><img src="media/16587402951024/Snip20161215_3.png" alt="Snip20161215_3" /><br />
让第三方库不跟随Xcode的swift版本®</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402951352.html">Markdown 语法和 MWeb 写作使用说明</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="markdown%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Markdown 的设计哲学</h2>
<blockquote>
<p>Markdown 的目標是實現「易讀易寫」。<br />
不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。<br />
Markdown 的語法有個主要的目的：用來作為一種網路內容的<em>寫作</em>用語言。</p>
</blockquote>


		</div>

		 
		 <footer>
      	<a rel="full-article" href="16587402951352.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402951502.html">图片加载方式</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402951502/15299939112098.jpg" alt="" /><br />
<img src="media/16587402951502/15299939172785.jpg" alt="" /></p>
<p>图像的降采样</p>
<p>不要使用昂贵的UIImage：UIImage会解压原始的图片占用大量的内存<br />
内部的坐标变换也非常昂贵</p>
<p>使用ImageIO的CGImageSourceCreateThumbnailAtIndex API: 无视原始图片尺寸，resize的内存开销只是目标尺寸（请看Session中后半部分的Demo）</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402951661.html">安装tree命令</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>brew</code> 一行命令搞定 <code>brew install tree</code></p>
<p>效果图:</p>
<pre><code class="language-plain_text">.
├── LICENSE
├── MKShowDetail
│   ├── MKShowDetail.h
│   ├── XZBaseViewController.h
│   ├── XZBaseViewController.m
│   ├── XZBaseViewController.xib
│   ├── XZCustomViewController.h
│   ├── XZCustomViewController.m
│   ├── XZTableView.h
│   ├── XZTableView.m
│   └── bgImage.gif
├── MKShowDetail.podspec
├── MKShowDetailDemo
│   ├── DetailShow
│   │   ├── AppDelegate.h
│   │   ├── AppDelegate.m
│   │   ├── Assets.xcassets
│   │   │   ├── AppIcon.appiconset
│   │   │   │   └── Contents.json
│   │   │   ├── Contents.json
│   │   │   └── icon.imageset
│   │   │       ├── Contents.json
│   │   │       └── icon.jpg
│   │   ├── Base.lproj
│   │   │   ├── LaunchScreen.storyboard
│   │   │   └── Main.storyboard
│   │   ├── Info.plist
│   │   ├── OneViewController.h
│   │   ├── OneViewController.m
│   │   ├── TestViewController.h
│   │   ├── TestViewController.m
│   │   ├── ThreeViewController.h
│   │   ├── ThreeViewController.m
│   │   ├── TwoViewController.h
│   │   ├── TwoViewController.m
│   │   ├── ViewController.h
│   │   ├── ViewController.m
│   │   ├── lol.jpg
│   │   ├── main.m
│   │   └── timo.jpg
│   └── DetailShow.xcodeproj
│       ├── project.pbxproj
│       ├── project.xcworkspace
│       │   ├── contents.xcworkspacedata
│       │   └── xcuserdata
│       │       ├── mekor.xcuserdatad
│       │       │   └── UserInterfaceState.xcuserstate
│       │       └── weizhi.xcuserdatad
│       │           └── UserInterfaceState.xcuserstate
│       └── xcuserdata
│           ├── mekor.xcuserdatad
│           │   └── xcschemes
│           │       ├── DetailShow.xcscheme
│           │       └── xcschememanagement.plist
│           └── weizhi.xcuserdatad
│               ├── xcdebugger
│               │   └── Breakpoints_v2.xcbkptlist
│               └── xcschemes
│                   ├── DetailShow.xcscheme
│                   └── xcschememanagement.plist
├── README.md
└── shopdetail.gif

</code></pre>
<p>看起来效果不错.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402951807.html">ListView滚动条&下拉刷新&通知</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="list-view%E6%B7%BB%E5%8A%A0%E6%BB%9A%E5%8A%A8%E6%9D%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>List View添加滚动条</h2>
<ol>
<li>
<p>设置默认滚动条</p>
<p>可以在ListView外层包一层Scrollbar，这样就会根据不同的系统展示不同样式的滚动条</p>
</li>
<li>
<p>设置苹果风格的滚动条</p>
<p>苹果风格的滚动条是Cupertino Scrollbar，这样安卓手机也能显示苹果风格的样式了，也就是滚动条也能拖动了。</p>
<p>注意： 设置了滚动条后拖动，如果List View没有设置itemCount就会crash崩溃。</p>
</li>
<li>
<p>滚动条一直显示</p>
<p>默认情况是滚动后滚动条会隐藏起来，如果想要滚动条一直显示可以设置is Always Shown，同时要传入controller和List View的controller是同一个，保证对应。这样两个都操作后才会一直显示。</p>
</li>
</ol>
<h2><a id="%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>下拉刷新</h2>
<p>使用RefreshIndicator 组件就能实现下拉刷新，在onRefresh方法中设置网络请求。</p>
<pre><code class="language-dart">Widget build(BuildContext context) {
    return RefreshIndicator(
      onRefresh: () async {
        print(&quot;刷新&quot;);
        await Future.delayed(Duration(seconds: 1));
      },
      strokeWidth: 4.0, // 下拉刷新转动箭头的宽度
      color: Colors.white, // 下拉刷新转动箭头的颜色
      backgroundColor: Colors.black, // 下拉刷新的背景颜色
      child: Scrollbar(
        child: ListView.separated(
            itemBuilder: (context, index) {
              return Container(
                child: Text(&quot;当前是$index&quot;),
              );
            },
            separatorBuilder: (context, index) {
              return Divider();
            },
            itemCount: 100),
      ),
    );
  }
}
</code></pre>
<p>下拉刷新功能和样式修改<br />
<img src="media/16587402951807/Untitled.png" alt="Untitled" /></p>
<h2><a id="%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>事件通知</h2>
<p>为什么List View滚动的时候Refresh Indicator和Scrollbar能够知道？</p>
<p>list View在滚动的时候会不断的发送通知，我们可以在List View外层添加NotificationListener 来捕获。</p>
<pre><code class="language-dart">Widget build(BuildContext context) {
    return RefreshIndicator(
      onRefresh: () async {
        print(&quot;刷新&quot;);
        await Future.delayed(Duration(seconds: 1));
      },
      strokeWidth: 4.0, // 下拉刷新转动箭头的宽度
      color: Colors.white, // 下拉刷新转动箭头的颜色
      backgroundColor: Colors.black, // 下拉刷新的背景颜色
      child: Scrollbar(
        child: NotificationListener(
          onNotification: (ScrollNotification notification) {
            print(notification);
            return true;
          },
          child: ListView.separated(
              itemBuilder: (context, index) {
                return Container(
                  child: Text(&quot;当前是$index&quot;),
                );
              },
              separatorBuilder: (context, index) {
                return Divider();
              },
              itemCount: 100),
        ),
      ),
    );
  }
</code></pre>
<p><img src="media/16587402951807/Untitled%201.png" alt="Untitled 1" /></p>
<p>返回true的时候意味着捕获了，就不会继续往下传递了，也就是Scrollbar和RefrIndicator 不能获取道ListView发送的通知，对应的功能也就会失效。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402951960.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-plain_text"># Sets the target folders and the final framework product.
FMK_NAME=${PROJECT_NAME}
# Install dir will be the final output to the framework.
# The following line create it in the root folder of the current project.
INSTALL_DIR=${SRCROOT}/Products/${FMK_NAME}.framework
# Working dir will be deleted after the framework creation.
WRK_DIR=build
DEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.framework
SIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework
# Building both architectures.
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator
# Cleaning the oldest.
if [ -d &quot;${INSTALL_DIR}&quot; ]
then
rm -rf &quot;${INSTALL_DIR}&quot;
fi
# Creates and renews the final product folder.
mkdir -p &quot;${INSTALL_DIR}&quot;
# Copies the headers and resources files to the final product folder.
cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;
# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.
lipo -create &quot;${DEVICE_DIR}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR}/${FMK_NAME}&quot; -output &quot;${INSTALL_DIR}/${FMK_NAME}&quot;
rm -r &quot;${WRK_DIR}&quot;

open &quot;${INSTALL_DIR}&quot;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402952109.html">3D Touch</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##<a href="https://stackoverflow.com/documentation/ios/6705/3d-touch/22813/3d-touch-with-swift">3D Touch with Swift</a></p>
<p>3D touch has been introduced with iPhone 6s Plus. There are two behaviors added with this new interface layer: Peek and Pop.</p>
<p><strong>Peek and Pop in a nutshell</strong></p>
<p>Peek - Press hard</p>
<p>Pop - Press really hard</p>
<p><strong>Checking for 3D support</strong></p>
<p>You should check if the device has a 3D touch support. You can do this by checking the value of <em>forceTouchCapability</em> property of a <em>UITraitCollection</em> object. UITraitCollection describes the iOS interface environment for your app.</p>
<pre><code class="language-plain_text">if (traitCollection.forceTouchCapability == .Available) {    
    registerForPreviewingWithDelegate(self, sourceView: view)
}
</code></pre>
<p><strong>Implementing the delegate</strong></p>
<p>You need to implement the two methods of <em>UIViewControllerPreviewingDelegate</em> in your class. One of the methods is for <em>peek</em> and the other one is for <em>pop</em> behavior.</p>
<p>The method to be implemented for the <em>peek</em> is <em>previewingContext</em>.</p>
<pre><code class="language-plain_text">func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? {

    guard let indexPath = self.tableView.indexPathForRowAtPoint(location), cell = self.tableView.cellForRowAtIndexPath(indexPath) as? &lt;YourTableViewCell&gt; else {
        return nil
    }

    guard let datailVC = storyboard?.instantiateViewControllerWithIdentifier(&quot;&lt;YourViewControllerIdentifier&gt;&quot;) as? &lt;YourViewController&gt; else {
        return nil
    }

    datailVC.peekActive = true
    previewingContext.sourceRect = cell.frame

    // Do the stuff

    return datailVC

}
</code></pre>
<p>The method to be implemented for the <em>pop</em> is <em>previewingContext</em>. :)</p>
<pre><code class="language-plain_text">func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController) {

    let balanceViewController = viewControllerToCommit as! &lt;YourViewController&gt;

    // Do the stuff

    navigationController?.pushViewController(balanceViewController, animated: true)

}
</code></pre>
<p>As you can see they are overloaded methods. You can use 3D touch in any way implementing these methods.</p>
<p><strong>Objective-C</strong></p>
<pre><code class="language-plain_text">//Checking for 3-D Touch availability
if ([self.traitCollection respondsToSelector:@selector(forceTouchCapability)] &amp;&amp;
        (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable))
    {
        [self registerForPreviewingWithDelegate:self sourceView:self.view];
    }
//Peek
- (UIViewController *)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext
              viewControllerForLocation:(CGPoint)location {

    NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:location];
    Country *country = [self countryForIndexPath:indexPath];
    if (country) {
        CountryCell *cell = [self.tableView cellForRowAtIndexPath:indexPath];
        if (cell) {
            previewingContext.sourceRect = cell.frame;
            UINavigationController *navController = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;UYLCountryNavController&quot;];
            [self configureNavigationController:navController withCountry:country];
            return navController;
        }
    }
    return nil;
}
//Pop
- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit {

    [self showDetailViewController:viewControllerToCommit sender:self];
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402952262.html">Linux - 文件、磁盘管理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.文件管理</h2>
<h3><a id="%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%EF%BC%9Als" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查看文件信息：ls</h3>
<p>ls是英文单词list的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于DOS下的dir命令。</p>
<p><code>Linux文件或者目录名称最长可以有265个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。</code></p>
<p>ls常用参数：</p>
<table>
<thead>
<tr>
<th style="text-align: center">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">-a</td>
<td>显示指定目录下所有子目录与文件，包括隐藏文件</td>
</tr>
<tr>
<td style="text-align: center">-l</td>
<td>以列表方式显示文件的详细信息</td>
</tr>
<tr>
<td style="text-align: center">-h</td>
<td>配合 -l 以人性化的方式显示文件大小</td>
</tr>
</tbody>
</table>
<p><img src="media/16587402952262/14954529185223.jpg" alt="" /></p>
<p>图中列出的信息含义如下图所示：</p>
<p><img src="media/16587402952262/14954529393080.jpg" alt="" /></p>
<p>与DOS下的文件操作类似，在Unix/Linux系统中，也同样允许使用特殊字符来同时引用多个文件名，这些特殊字符被称为通配符。</p>
<table>
<thead>
<tr>
<th style="text-align: left">通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">*</td>
<td>文件代表文件名中所有字符</td>
</tr>
<tr>
<td style="text-align: left">ls te*</td>
<td>查找以te开头的文件</td>
</tr>
<tr>
<td style="text-align: left">ls *html</td>
<td>查找结尾为html的文件</td>
</tr>
<tr>
<td style="text-align: left">？</td>
<td>代表文件名中任意一个字符</td>
</tr>
<tr>
<td style="text-align: left">ls ?.c</td>
<td>只找第一个字符任意，后缀为.c的文件</td>
</tr>
<tr>
<td style="text-align: left">ls a.?</td>
<td>只找只有3个字符，前2字符为a.，最后一个字符任意的文件</td>
</tr>
<tr>
<td style="text-align: left">[]</td>
<td>[”和“]”将字符组括起来，表示可以匹配字符组中的任意一个。“-”用于表示字符范围。</td>
</tr>
<tr>
<td style="text-align: left">[abc]</td>
<td>匹配a、b、c中的任意一个</td>
</tr>
<tr>
<td style="text-align: left">[a-f]</td>
<td>匹配从a到f范围内的的任意一个字符</td>
</tr>
<tr>
<td style="text-align: left">ls [a-f]*</td>
<td>找到从a到f范围内的的任意一个字符开头的文件</td>
</tr>
<tr>
<td style="text-align: left">ls a-f</td>
<td>查找文件名为a-f的文件,当“-”处于方括号之外失去通配符的作用</td>
</tr>
<tr>
<td style="text-align: left">\</td>
<td>如果要使通配符作为普通字符使用，可以在其前面加上转义字符。“?”和“*”处于方括号内时不用使用转义字符就失去通配符的作用。</td>
</tr>
<tr>
<td style="text-align: left">ls *a</td>
<td>查找文件名为*a的文件</td>
</tr>
</tbody>
</table>
<h3><a id="%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%91%BD%E4%BB%A4%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>输出重定向命令：&gt;</h3>
<p>Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。</p>
<p>如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )</p>
<p><img src="media/16587402952262/14954530933243.jpg" alt="" /><br />
注意： <code>&gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。</code></p>
<h3><a id="%E5%88%86%E5%B1%8F%E6%98%BE%E7%A4%BA%EF%BC%9Amore" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分屏显示：more</h3>
<p>查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助。</p>
<p><img src="media/16587402952262/14954533115641.jpg" alt="" /></p>
<h3><a id="%E7%AE%A1%E9%81%93%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>管道：|</h3>
<p>管道：一个命令的输出可以通过管道做为另一个命令的输入。</p>
<p>管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。</p>
<p><img src="media/16587402952262/14954534699128.jpg" alt="" /></p>
<h3><a id="%E6%B8%85%E5%B1%8F%EF%BC%9Aclear" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>清屏：clear</h3>
<p>clear作用为清除终端上的显示(类似于DOS的cls清屏功能)，也可使用快捷键：Ctrl + l ( “l” 为字母 )。</p>
<h3><a id="%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%EF%BC%9Acd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>切换工作目录： cd</h3>
<p>在使用Unix/Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。<code>Linux所有的目录和文件名大小写敏感</code></p>
<p>cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。</p>
<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">cd</td>
<td>切换到当前用户的主目录(/home/用户目录)，用户登陆的时候，默认的目录就是用户的主目录。</td>
</tr>
<tr>
<td style="text-align: left">cd ~</td>
<td>切换到当前用户的主目录(/home/用户目录)</td>
</tr>
<tr>
<td style="text-align: left">cd .</td>
<td>切换到当前目录</td>
</tr>
<tr>
<td style="text-align: left">cd ..</td>
<td>切换到上级目录</td>
</tr>
<tr>
<td style="text-align: left">cd -</td>
<td>可进入上次所在的目录</td>
</tr>
</tbody>
</table>
<p><img src="media/16587402952262/14955894273051.jpg" alt="" /><br />
注意：</p>
<ul>
<li>如果路径是从根路径开始的，则路径的前面需要加上 “ / ”，如 “ /mnt ”，通常进入某个目录里的文件夹，前面不用加 “ / ”。</li>
</ul>
<p><img src="media/16587402952262/14955900895519.jpg" alt="" /></p>
<h3><a id="%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%EF%BC%9Apwd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>显示当前路径：pwd</h3>
<p>使用pwd命令可以显示当前的工作目录，该命令很简单，直接输入pwd即可，后面不带参数。</p>
<h3><a id="%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%EF%BC%9Amkdir" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建目录：mkdir</h3>
<p>通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。</p>
<p>需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。<br />
<img src="media/16587402952262/14955907314659.jpg" alt="" /></p>
<h3><a id="%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%EF%BC%9Armdir" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除目录：rmdir</h3>
<p>可使用rmdir命令删除一个目录。必须离开目录，并且目录必须为空目录，不然提示删除失败。</p>
<h3><a id="%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%EF%BC%9Arm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除文件：rm</h3>
<p>可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。</p>
<p>常用参数及含义如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">-i</td>
<td>以进行交互式方式执行</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>强制删除，忽略不存在的文件，无需提示</td>
</tr>
<tr>
<td style="text-align: left">-r</td>
<td>递归地删除目录下的内容，删除文件夹时必须加此参数</td>
</tr>
</tbody>
</table>
<h3><a id="%E5%BB%BA%E7%AB%8B%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6%EF%BC%9Aln" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建立链接文件：ln</h3>
<p>Linux链接文件类似于Windows下的快捷方式。</p>
<p>链接文件分为软链接和硬链接。</p>
<p>软链接：软链接不占用磁盘空间，源文件删除则软链接失效。</p>
<p>硬链接：硬链接只能链接普通文件，不能链接目录。</p>
<p>使用格式：</p>
<pre><code class="language-plain_text">ln 源文件 链接文件
ln -s 源文件 链接文件

</code></pre>
<p>如果<code>没有-s</code>选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。</p>
<p>注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。</p>
<h3><a id="%E6%9F%A5%E7%9C%8B%E6%88%96%E8%80%85%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%9Acat" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查看或者合并文件内容：cat</h3>
<h3><a id="%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%EF%BC%9Agrep" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文本搜索：grep</h3>
<p>Linux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。</p>
<p>grep一般格式为：</p>
<pre><code class="language-plain_text">grep [-选项] ‘搜索内容串’文件名

</code></pre>
<p>在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。</p>
<p>常用选项说明：</p>
<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">-v</td>
<td>显示不包含匹配文本的所有行（相当于求反）</td>
</tr>
<tr>
<td style="text-align: left">-n</td>
<td>显示匹配行及行号</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>忽略大小写</td>
</tr>
</tbody>
</table>
<p>grep搜索内容串可以是正则表达式。</p>
<p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>
<p>grep常用正则表达式：</p>
<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">^a</td>
<td>行首,搜寻以 m 开头的行；grep -n '^a' 1.txt</td>
</tr>
<tr>
<td style="text-align: left">ke$</td>
<td>行尾,搜寻以 ke 结束的行；grep -n 'ke$' 1.txt</td>
</tr>
<tr>
<td style="text-align: left">[Ss]igna[Ll]</td>
<td>匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n '[Ss]igna[Ll]' 1.txt</td>
</tr>
<tr>
<td style="text-align: left">.</td>
<td>(点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n 'e.e' 1.txt</td>
</tr>
</tbody>
</table>
<h3><a id="%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%EF%BC%9Afind" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查找文件：find</h3>
<p>find命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。</p>
<p>常用用法：</p>
<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">find ./ -name test.sh</td>
<td>查找当前目录下所有名为test.sh的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -name '*.sh'</td>
<td>查找当前目录下所有后缀为.sh的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -name &quot;[A-Z]*&quot;</td>
<td>查找当前目录下所有以大写字母开头的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size 2M</td>
<td>查找在/tmp 目录下等于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size +2M</td>
<td>查找在/tmp 目录下大于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find /tmp -size -2M</td>
<td>查找在/tmp 目录下小于2M的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -size +4k -size -5M</td>
<td>查找当前目录下大于4k，小于5M的文件</td>
</tr>
<tr>
<td style="text-align: left">find ./ -perm 0777</td>
<td>查找当前目录下权限为 777 的文件或目录</td>
</tr>
</tbody>
</table>
<h3><a id="%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%EF%BC%9Acp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拷贝文件：cp</h3>
<p>cp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。</p>
<p>常用选项说明：</p>
<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">-a</td>
<td>该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>已经存在的目标文件而不提示</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>交互式复制，在覆盖目标文件之前将给出提示要求用户确认</td>
</tr>
<tr>
<td style="text-align: left">-r</td>
<td>若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>显示拷贝进度</td>
</tr>
</tbody>
</table>
<p>cp vim_configure/ code/ -ivr 把文件夹 vim_configure 拷贝到 code 目录里：</p>
<p><strong>暂时缺图稍后补</strong></p>
<h3><a id="%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%EF%BC%9Amv" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>移动文件：mv</h3>
<p>用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。</p>
<p>常用选项说明：</p>
<table>
<thead>
<tr>
<th style="text-align: left">选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">-f</td>
<td>禁止交互式操作，如有覆盖也不会给出提示</td>
</tr>
<tr>
<td style="text-align: left">-i</td>
<td>确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>显示移动进度</td>
</tr>
</tbody>
</table>
<h3><a id="%E5%BD%92%E6%A1%A3%E7%AE%A1%E7%90%86%EF%BC%9Atar" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>归档管理：tar</h3>
<p>计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。</p>
<p>tar使用格式 tar [参数] 打包文件名 文件</p>
<p>tar命令很特殊，其参数前面可以使用“-”，也可以不使用。</p>
<p>常用参数：</p>
<table>
<thead>
<tr>
<th style="text-align: left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">-c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td style="text-align: left">-v</td>
<td>列出归档解档的详细过程，显示进度</td>
</tr>
<tr>
<td style="text-align: left">-f</td>
<td>指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后</td>
</tr>
<tr>
<td style="text-align: left">-t</td>
<td>列出档案中包含的文件</td>
</tr>
<tr>
<td style="text-align: left">-x</td>
<td>解开档案文件</td>
</tr>
</tbody>
</table>
<p>注意：除了f需要放在参数的最后，其它参数的顺序任意。</p>
<h3><a id="%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%EF%BC%9Agzip" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件压缩解压：gzip</h3>
<p>tar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。</p>
<p>gzip使用格式如下：</p>
<pre><code class="language-plain_text">gzip  [选项]  被压缩文件

</code></pre>
<p>常用选项：</p>
<p>|选项|含义| |-d|解压| |-r|压缩所有子目录|</p>
<p><strong>这里缺图</strong></p>
<p>tar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。</p>
<p>压缩用法：tar cvzf 压缩包包名 文件1 文件2 ...</p>
<pre><code class="language-plain_text">-z ：指定压缩包的格式为：file.tar.gz

</code></pre>
<p>例如： tar zcvf test.tar.gz 1.c 2.c 3.c 4.c把 1.c 2.c 3.c 4.c 压缩成 test.tar.gz<br />
<strong>这里缺图</strong></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402952478.html">Flutter 布局和列表</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>Row</code>水平方向布局<br />
<code>Column</code>垂直方向布局<br />
<code>Stack</code>堆叠布局，后面的Widget遮挡前面的Widget</p>
<p><code>flutter</code>没有内联样式，但是可以使用<code>Padding</code>，<code>Center</code>，<code>Column</code>，<code>Row</code>等，这些都是Widget，另外Widget也通常接受用于布局样式的构造参数，比如在<code>Text</code>Widget可以使用<code>TextStyle</code>类并将其应用于各个<code>Text</code>widgets。</p>
<pre><code class="language-dart">var textStyle = TextStyle(fontSize:32.0,color: Colors.cyan,fontWeight:FontWeight.w600);

…
Center(
child: Column(children:&lt;Widget&gt;                    
    [
        Text(‘Sample Text’,style: textStyle,),
        Padding(padding: EdgeInsets.all(20.0),child:Icon(Icons.lightbulb_outline,size:48.0,color:Colors.redAccent),
    ]);
)
</code></pre>
<p>List View 相当于ScrollView，和TableView。如果是动态变化的列表，可以使用ListView.builder,这样就能动态的改变List试图了。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402952633.html">GCD (Grand Central Dispatch) from Stack Overflow</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28284/dispatch-semaphore#t=201708240714182196184">Stack Overflow</a></p>
<h2><a id="dispatch-semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dispatch Semaphore (信号量)</h2>
<blockquote>
<p>DispatchSemaphore provides an efficient implementation of a traditional counting semaphore, which can be used to control access to a resource across multiple execution contexts.</p>
</blockquote>
<p>A scenario for when to use a semaphore could be if you are doing some file reading/writing, if multiple tasks are trying to read and write from file at the same time, it could increase your performance to make each task wait its turn so as to not overburden the I/O controller.</p>
<pre><code class="language-plain_text">func do2TasksAtATime () {
    print(&quot;starting long running tasks (2 at a time)&quot;)
    let sem = DispatchSemaphore(value: 2)            //this semaphore only allows 2 tasks to run at the same time (the resource count)
    for i in 0...7 {                                 //launch a bunch of tasks
        DispatchQueue.global().async {               //run tasks on a background thread
            sem.wait()                               //wait here if no resources available
            sleep(2)                                 //do some long task eg file access (here we are just sleeping for a 2 seconds for demonstration purposes)
            print(&quot;long task \(i) done! \(Date())&quot;)
            sem.signal()                             //let the semaphore know this resource is now available
        }
    }
}
</code></pre>
<p>Example output: (notice the time stamps)</p>
<pre><code class="language-plain_text">starting long running tasks (2 at a time)
long task 0 done! 2017-02-16 07:11:53 +0000
long task 1 done! 2017-02-16 07:11:53 +0000
long task 2 done! 2017-02-16 07:11:55 +0000
long task 3 done! 2017-02-16 07:11:55 +0000
long task 5 done! 2017-02-16 07:11:57 +0000
long task 4 done! 2017-02-16 07:11:57 +0000
long task 6 done! 2017-02-16 07:11:59 +0000
long task 7 done! 2017-02-16 07:11:59 +0000
</code></pre>
<h2><a id="dispatch-group" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dispatch Group</h2>
<blockquote>
<p>DispatchGroup allows for aggregate synchronization of work. You can use them to submit multiple different work items and track when they all complete, even though they might run on different queues. This behavior can be helpful when progress can’t be made until all of the specified tasks are complete.</p>
</blockquote>
<p>DispatchGroup allows for aggregate synchronization of work. You can use them to submit multiple different work items and track when they all complete, even though they might run on different queues. This behavior can be helpful when progress can’t be made until all of the specified tasks are complete.<br />
A Scenario when this could be useful is if you have multiple webservice calls that all need to finish before continuing. For example, you need to download multiple sets of data that needs to be processed by some function. You have to wait for all webservices to complete before calling the function to process all the received data.</p>
<pre><code class="language-plain_text">func doLongTasksAndWait () {
    print(&quot;starting long running tasks&quot;)
    let group = DispatchGroup()          //create a group for a bunch of tasks we are about to do
    for i in 0...3 {                     //launch a bunch of tasks (eg a bunch of webservice calls that all need to be finished before proceeding to the next ViewController)
        group.enter()                    //let the group know that something is being added
        DispatchQueue.global().async {   //run tasks on a background thread
            sleep(arc4random() % 4)      //do some long task eg webservice or database lookup (here we are just sleeping for a random amount of time for demonstration purposes)
            print(&quot;long task \(i) done!&quot;)
            group.leave()                //let group know that the task is finished
        }
    }
    group.wait()                         //will block whatever thread we are on here until all the above tasks have finished (so maybe dont use this function on your main thread)
    print(&quot;all tasks done!&quot;)
}
</code></pre>
<p>Alternatively, if you do not want to wait for the groups to finish, but instead want to run a function once all the tasks have completed, use the <code>notify</code> function in place of the <code>group.wait()</code></p>
<pre><code class="language-plain_text">group.notify(queue: DispatchQueue.main) { //the queue: parameter is which queue this block will run on, if you need to do UI updates, use the main queue
    print(&quot;all tasks done!&quot;)              //this will execute when all tasks have left the group
}
</code></pre>
<p>Example output:</p>
<pre><code class="language-plain_text">starting long running tasks
long task 0 done!
long task 3 done!
long task 1 done!
long task 2 done!
all tasks done!
</code></pre>
<h2><a id="serial-vs-concurrent-dispatch-queues%E4%B8%B2%E8%A1%8C%E5%B9%B6%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Serial vs Concurrent Dispatch Queues (串行,并行)</h2>
<p>###Serial Queue</p>
<pre><code class="language-plain_text">func serialQueues () {
    let serialQueue = DispatchQueue(label: &quot;com.example.serial&quot;) //default queue type is a serial queue
    let start = Date ()
    for i in 0...3 {                                             //launch a bunch of tasks
        serialQueue.async {                                      //run tasks on a background thread, using our serial queue
            sleep(2)                                             //do some long task eg webservice or database lookup
            let timeTaken = Date().timeIntervalSince(start)
            print(&quot;serial long task \(i) done! total time taken: \(timeTaken)&quot;)
        }
    }
}
</code></pre>
<p>Example output:</p>
<pre><code class="language-plain_text">serial long task 0 done! total time taken: 2.07241100072861
serial long task 1 done! total time taken: 4.16347700357437
serial long task 2 done! total time taken: 6.23209798336029
serial long task 3 done! total time taken: 8.30682599544525
</code></pre>
<p>###Concurrent Queue</p>
<pre><code class="language-plain_text">func concurrentQueues () {
    let concurrentQueue = DispatchQueue(label: &quot;com.example.concurrent&quot;, attributes: .concurrent) //explicitly specify the queue to be a concurrent queue
    let start = Date ()
    for i in 0...3 {            //launch a bunch of tasks
        concurrentQueue.async { //run tasks on a background thread, using our concurrent queue
            sleep(2)            //do some long task eg webservice or database lookup
            let timeTaken = Date().timeIntervalSince(start)
            print(&quot;concurrent long task \(i) done! total time taken: \(timeTaken)&quot;)
        }
    }
}
</code></pre>
<p>Example output:</p>
<pre><code class="language-plain_text">concurrent long task 3 done! total time taken: 2.07092100381851
concurrent long task 0 done! total time taken: 2.07087397575378
concurrent long task 2 done! total time taken: 2.07086700201035
concurrent long task 1 done! total time taken: 2.07089096307755
</code></pre>
<p><strong>Discussion</strong></p>
<p>As we can see from the examples above, a serial queue will complete each task in the order they are submitted to the queue. Each task will wait for the previous task to finish before executing. As for the concurrent queue, each task does not wait on the others in the queue and executes as soon as possible; the advantage is that all tasks on the queue will run at the same time on separate threads, making a concurrent queue take less time than a serial queue.</p>
<p>If order of execution of tasks is not important, always use a concurrent queue for the best efficiency.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402952790.html">服务器下发表整理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##已经不使用的表</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConfigSummary</td>
<td>摇一摇 推荐套餐  这个没有了</td>
</tr>
<tr>
<td>crmType</td>
<td>这个表也没有用到</td>
</tr>
<tr>
<td>customerIndividualDict</td>
<td>顾客变态需求表...这个也没有用</td>
</tr>
<tr>
<td>Disc_PotConfig</td>
<td>专属味碟相关  现在没有用到</td>
</tr>
<tr>
<td>Disc_Seasoning</td>
<td>专属味碟相关  现在没有用到</td>
</tr>
<tr>
<td>dishconfigable</td>
<td></td>
</tr>
<tr>
<td>dishdynamic</td>
<td>已估清数据  这个已经不用了,现在估清数据走网络请求轮询\</td>
</tr>
<tr>
<td>dishfavoriteinfo</td>
<td>项目中没有使用</td>
</tr>
<tr>
<td>dishquantity</td>
<td>项目中没有使用</td>
</tr>
<tr>
<td>frequentordereddish</td>
<td></td>
</tr>
<tr>
<td>guideconfig</td>
<td></td>
</tr>
<tr>
<td>getFirstleavelInfoArr</td>
<td></td>
</tr>
<tr>
<td>setinfo</td>
<td></td>
</tr>
<tr>
<td>setreplaceinfo</td>
<td></td>
</tr>
<tr>
<td>surveypaper</td>
<td></td>
</tr>
</tbody>
</table>
<h2><a id="%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%8E%89%E7%9A%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可以去掉的</h2>
<table>
<thead>
<tr>
<th>表名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>domainpanmap</td>
<td>区分是那个锅</td>
</tr>
<tr>
<td>packTypeRecommendConfig</td>
<td>推荐套餐人数列表...希望能够去掉,这样的话单纯走网络请求应该比走完数据库再走网络请求好些</td>
</tr>
<tr>
<td>pottypeconfig</td>
<td>这个表里写的是锅底名称,希望在一个表里把锅底名称确定好</td>
</tr>
<tr>
<td>rankinfo</td>
<td>菜每周每月每季每年点击次数</td>
</tr>
<tr>
<td>setdetail</td>
<td>推荐套餐相关的,希望改到后台做</td>
</tr>
</tbody>
</table>
<h2><a id="%E6%9C%AA%E7%A1%AE%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>未确定</h2>
<p>messagetypeconfig</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402952944.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>修改 jar 工程需要 install<br />
修改 war 工程要重启<br />
三套生命周期<br />
clean<br />
compile test package install<br />
deploy</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402953100.html">隐藏tabBar的小技巧</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>突然想起来 <code>微指App</code> 里面控制 tabBar 显示与隐藏非常麻烦,在控制器中的 <code>viewWillAppear</code> 和 <code>viewWillDisappear</code>中做处理,这样能保证在控制器中控制 tabBar 的显示与隐藏,但是也非常麻烦,每个控制器都需要控制..</p>
<p>一劳永逸的做法:</p>
<pre><code class="language-plain_text">    // 重写 push 方法
    override func pushViewController(_ viewController: UIViewController, animated: Bool) {
        // 如果不是栈底控制器才需要隐藏, 根控制器 不需要处理
        if childViewControllers.count &gt; 0 {
            // 隐藏底部的 TabBar
            viewController.hidesBottomBarWhenPushed = true
        }
        super.pushViewController(viewController, animated: true)
    }
</code></pre>
<p>在导航控制器中重写 <code>push</code> 方法,这样就能省去好多麻烦..</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402953267.html">UIWebView可能的优化方案</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>声明:Socket思想来源于手Q空间团队,Demo中提供了使用Socket模拟HTTP请求.</p>
</blockquote>
<p>我们都知道WebView加载页面非常缓慢,如果页面样式结构比较固定,则可以采用自己的自己封装的网络请求去获取数据,然后拼接成HTML显示.</p>
<p><strong>优点:</strong></p>
<ul>
<li>通常webview首次加载非常慢,使用Native网络请求会很快</li>
<li>离线包＋预加载(静态HTML、静态JS、静态CSS它们的加载、它们离线的东西）,首屏进入可直接加载默认数据</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>静态资源包离线下载,不能保证100%</li>
</ul>
<h2><a id="%E4%BC%A0%E7%BB%9Fh5%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传统H5加载流程</h2>
<p><img src="media/16587402953267/14737415611533.jpg" alt="" /></p>
<p>###<strong>这里有两个问题：</strong></p>
<p>WebView的耗时<br />
根据手Q的统计数据，Android的WebView平均打开启动的速度耗时是0.8秒，有些Android机型基于系统环境可能需要一点多或者两秒左右；</p>
<p>HTTP协议的网络层<br />
HTTP有DNS或者建立链接的耗时，HTTPS有建立SSL链接的耗时。</p>
<p>所以H5通常带给用户的体验是：我点进来不管是怎么时候，是第一次第二次还是第三次，我点进来先等两秒再说，看两秒白屏后页面才可以加载进来，其实这里我们只做了两个事情去优化首次加载流程：</p>
<p>####1. 把WebView启动和发送请求改成并行<br />
客户端在启动WebView的时候同时发起HTML的页面请求，这里可以实现一个效果：本来我的耗时是T1+T2，现在为T1或T2的最大值，这样达到并行加载的效果。<br />
<img src="media/16587402953267/14737420748297.jpg" alt="" /></p>
<p>当然这里还有一个优化的空间，我们其实已经由客户端接管了发送网络请求的事情，以前接管的时候是用HTTP协议，比如像iOS用的是URLSession模块，但已经让客户端接管了，为什么不能够更大胆一些呢？<br />
####2. Socket通道</p>
<p>其实我们可以不拘泥于数据传输的方式，所以这里我们把一个HTML的加载从HTTP/HTTPS改造成了一个Socket通道，这是一个App里面长连接的管道，如果手机内部有即时通讯模块的话，我们是用这个长连接的通道来做HTML的传输的，它的作用在于只要你的手机QQ能够收发消息，你的HTML页面就能够加载进来，这样就达到体验上的一致性，同时网络也有比较稳定的提升。<br />
<img src="media/16587402953267/14737423231640.jpg" alt="" /></p>
<p>我们基本上做了两个事情就达到首次进入加速的目的，但后面才是一个关键：首次进入我们已经做过优化了，但二次进入怎么去做优化去提高它的显示速度呢？</p>
<h2><a id="%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本地缓存</h2>
<p><img src="media/16587402953267/14737426997041.jpg" alt="" /></p>
<p>##Demo简单介绍</p>
<blockquote>
<p>关于加载优化Demo,地址:<a href="https://github.com/Mekor/Optimization-of-webView">https://github.com/Mekor/Optimization-of-webView</a></p>
</blockquote>
<h4><a id="webview%E5%8A%A0%E8%BD%BD%E8%80%97%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>webView加载耗时问题解决方案简介:</h4>
<ol>
<li>如果有界面变动不大,可以吧HTML直接在本地存放一份,然后从网上请求数据,拼接成HTML,这样加载速度会很快.这种可以参考用户版商品的图片简介.</li>
<li>如果内部动态变化的,但是样式和交互式规定好的,可以在本地存放一份,当然也可以每次启动app的时候更新本地存放的静态资源.这样的好处就是每次只替换更新的内容.</li>
</ol>
<p>下面以网易新闻为例,这里我抓包网易新闻的请求,新闻详情: <a href="http://c.m.163.com/nc/article/C0OBRVC7051789DB/full.html">http://c.m.163.com/nc/article/C0OBRVC7051789DB/full.html</a><br />
这里我们可以看出,网易新闻也不是直接用webView加载url的方式显示的.</p>
<pre><code class="language-plain_text">{
    &quot;C0OBRVC7051789DB&quot;: {
        &quot;body&quot;: &quot;&lt;p&gt;　　郭德纲的成功除了自身坚持不懈的努力外，当然也因郭德纲遇到了不少“贵人”的帮助，在这其中有一位也是其“贵人”，郭德纲曾经也在很多场合说其是自己的贵人，他就是大鹏。&lt;/p&gt;&lt;!--IMG#0--&gt;&lt;p&gt;　　不过，此大鹏非彼大鹏。如今一说到大鹏，都会想到导演电影《煎饼侠》的大鹏，那是赵本山的弟子，却和郭德纲没有什么关系。而帮助过郭德纲，使得其相声在北京能广受欢迎的大鹏，则是北京文艺广播《开心茶馆》主持人康大鹏。&lt;/p&gt;&lt;!--IMG#1--&gt;&lt;p&gt;　　康大鹏作为电台节目主持人，在没有听到郭德纲相声之前，给听众播放的也是一些经典的相声段子，不过翻来覆去时间长了也令听众生厌，久而久之就没有了兴趣。在这种情况下，大鹏听了郭德纲的相声后，才感到眼前一亮。&lt;/p&gt;&lt;!--IMG#2--&gt;&lt;p&gt;　　当时的郭德纲，虽然在北京也开始站住了脚跟，但是仅限于小部分观众知道，并且据说还备受各方打击，所以才会在相声中经常有“怨言”。在大鹏看了德云社郭德纲的相声后，认为这是个机会，德云社也需要听众，也需要帮助。&lt;/p&gt;&lt;!--IMG#3--&gt;&lt;p&gt;　　于是，大鹏就开始到德云社录音，然后播放给听众听。这在当时，也是一个不小的举动。毕竟郭德纲在当时还名不见经传，而为郭德纲录音还需要大鹏自己掏腰包购买录音器材，至于播出后效果如何也担有一定风险。&lt;/p&gt;&lt;!--IMG#4--&gt;&lt;p&gt;　　也正如大鹏所想象，郭德纲的相声在电台播出后便反响强烈，使得很多观众都开始迷上了相声，也迷上了郭德纲。在拥有了大批粉丝后，据说郭德纲随后开办了一场大型纪念演出，当时有不少电视台和电台的领导观看，而在郭德纲相声结束后，大鹏还给台下领导来了一个惊人的一跪。&lt;/p&gt;&lt;!--IMG#5--&gt;&lt;p&gt;　　虽然只是单膝点地，但在当时的报纸也给出了惊天一跪的标题，而大鹏的这一跪，也使得郭德纲和电视台结缘。尽管郭德纲的成名和大鹏有着不可分割的关系，但大鹏还是很谦虚的说两者是相互的关系，因为节目需要听众。&lt;/p&gt;&lt;!--IMG#6--&gt;&lt;p&gt;　　在郭德纲进入北京电视台主持《星夜故事秀》节目时，这也是郭德纲和北京电视台合作最好的时期，堪称两者的“蜜月期”。只是随着郭德纲的成名，郭德纲后来又转战到了天津卫视，自己在北京电视台的节目则交给了何云伟和李菁来做。&lt;/p&gt;&lt;!--IMG#7--&gt;&lt;p&gt;　　这其中的原因，有人说是因为报酬方面产生了分歧，说白了其他电视台给了更高的价钱。所以北京电视台才会批郭德纲“忘恩负义”，因北京电视台为郭德纲的宣传做了很大的努力，但也有人说是因郭德纲的加盟，才使得北京电视台节目火了起来。谁是谁非莫衷一是。&lt;/p&gt;&lt;!--IMG#8--&gt;&lt;p&gt;　　至于后来，两者闹得更是不可开交，直到最后变成了“冤家”。而和北京电视台闹分裂后，对原电台主持人大鹏自然也是有很大的影响，毕竟电视台和电台也是一脉相承的关系，不可能不对大鹏产生影响。&lt;/p&gt;&lt;!--IMG#9--&gt;&lt;p&gt;　　对与错是与非都是难以说清，正如大鹏所说，郭德纲的相声给其节目带来了听众，而电台也给郭德纲带去了名气，两者也是相辅相成。但不管怎样，大鹏的确是郭德纲演艺路上的一位“恩人”，起码让其早点脱颖而出扬眉吐气了。&lt;/p&gt;&lt;p&gt; 特别声明：本文为网易自媒体平台“网易号”作者上传并发布，仅代表该作者观点。网易仅提供信息发布平台。&lt;/p&gt;&quot;,
        &quot;users&quot;: [],
        &quot;replyCount&quot;: 1893,
        &quot;ydbaike&quot;: [],
        &quot;link&quot;: [],
        &quot;shareLink&quot;: &quot;http://c.m.163.com/news/a/C0OBRVC7051789DB.html?spss=newsapp&amp;spsw=1&quot;,
        &quot;votes&quot;: [],
        &quot;img&quot;: [
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#0--&gt;&quot;,
                &quot;pixel&quot;: &quot;400*263&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/s9VWjHPwFtTeqKoYJBULaIbs5TmzcYeGFQeljU0IFvZrD1473633706236.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#1--&gt;&quot;,
                &quot;pixel&quot;: &quot;412*256&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/6DXnTuxZs2jvgFJLMW2svrKoh1=KTYXhGwGUH2JlqdpZq1473633736663.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#2--&gt;&quot;,
                &quot;pixel&quot;: &quot;380*246&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/H5jHhCfSD5uhRhMFrHwze4LgrK97qwcG1GkwWGRZcOeqe1473633752645.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#3--&gt;&quot;,
                &quot;pixel&quot;: &quot;360*286&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/udjNFCksz6Fc7fCFAzCBwzUYxWB1TJUVis97X5ZRHpqg61473633775305.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#4--&gt;&quot;,
                &quot;pixel&quot;: &quot;407*255&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/7mbZrlli2D70eS9WHoRmd54RDkr6onqv8Zl1h6V5zJraj1473633824123compressflag.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#5--&gt;&quot;,
                &quot;pixel&quot;: &quot;400*266&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/HVmr=qRm5YReXaRAJBcSaI6WJpMn6DkKHJIVJBdbqMOYY1473633850729compressflag.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#6--&gt;&quot;,
                &quot;pixel&quot;: &quot;380*232&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/HQUW=i7soYmJqlUDaS1iv6pGBI9NzCdFqYU=yC=QT8BDQ1473633896632.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#7--&gt;&quot;,
                &quot;pixel&quot;: &quot;294*220&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/lEs43YivpKRxQqZPlmaIo=SpEOdRTqeYUywHCLqwIqR111473633914904.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#8--&gt;&quot;,
                &quot;pixel&quot;: &quot;402*238&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/bhzvrmx8JUQHVViXI5VKqvHG=c5RIIxx0dssbfTNM7mfE1473633962043.jpg&quot;
            },
            {
                &quot;ref&quot;: &quot;&lt;!--IMG#9--&gt;&quot;,
                &quot;pixel&quot;: &quot;329*220&quot;,
                &quot;alt&quot;: &quot;&quot;,
                &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/tN7dLuyOJ0SU3kXoPRrLdXkVMZGJtiS97Qh46opqH2Q0N1473634186617.jpg&quot;
            }
        ],
        &quot;digest&quot;: &quot;&quot;,
        &quot;topiclist_news&quot;: [],
        &quot;dkeys&quot;: &quot;null&quot;,
        &quot;topiclist&quot;: [
            {
                &quot;hasCover&quot;: false,
                &quot;subnum&quot;: &quot;2.8万&quot;,
                &quot;alias&quot;: &quot;娱乐八卦、影视评论&quot;,
                &quot;tname&quot;: &quot;娱乐大嘴&quot;,
                &quot;ename&quot;: &quot;T1439876075818&quot;,
                &quot;tid&quot;: &quot;T1439876075818&quot;,
                &quot;cid&quot;: &quot;C1374475306828&quot;
            }
        ],
        &quot;docid&quot;: &quot;C0OBRVC7051789DB&quot;,
        &quot;picnews&quot;: true,
        &quot;title&quot;: &quot;郭德纲从他的节目走红 此“贵人”却不求回报&quot;,
        &quot;sourceinfo&quot;: {
            &quot;alias&quot;: &quot;娱乐八卦、影视评论&quot;,
            &quot;ename&quot;: &quot;T1439876075818&quot;,
            &quot;tname&quot;: &quot;娱乐大嘴&quot;,
            &quot;tid&quot;: &quot;T1439876075818&quot;
        },
        &quot;tid&quot;: &quot;&quot;,
        &quot;template&quot;: &quot;normal1&quot;,
        &quot;threadVote&quot;: 108,
        &quot;askbar&quot;: [
            {
                &quot;title&quot;: &quot;主持人&quot;,
                &quot;headpicurl&quot;: &quot;http://dingyue.nosdn.127.net/27vmGgL=A4BbmMAUJIEOEJ2vUlnvIGE9Ufum0roxEDigT1472456332076.jpg&quot;,
                &quot;alias&quot;: &quot; 我是河北交通广播主持人月色，关于主持、情感和各种天马行空的问题，问我吧！ &quot;,
                &quot;expertId&quot;: &quot;EX880112773195081120&quot;,
                &quot;name&quot;: &quot;月色&quot;,
                &quot;concernCount&quot;: 6341
            }
        ],
        &quot;threadAgainst&quot;: 49,
        &quot;boboList&quot;: [],
        &quot;articleTags&quot;: &quot;网易号&quot;,
        &quot;replyBoard&quot;: &quot;dy_wemedia_bbs&quot;,
        &quot;source&quot;: &quot;娱乐大嘴&quot;,
        &quot;huati&quot;: [
            {
                &quot;topicId&quot;: &quot;SJ02345751487819348812&quot;,
                &quot;topicName&quot;: &quot;郭德纲&quot;
            },
            {
                &quot;topicId&quot;: &quot;SJ1851570047893940154&quot;,
                &quot;topicName&quot;: &quot;赵本山&quot;
            }
        ],
        &quot;hasNext&quot;: false,
        &quot;voicecomment&quot;: &quot;off&quot;,
        &quot;apps&quot;: [],
        &quot;relative_sys&quot;: [
            {
                &quot;id&quot;: &quot;C0RN7O7N00034VR2&quot;,
                &quot;title&quot;: &quot;郭德纲的综艺版图:交人脉、捧新人、强化德云IP&quot;,
                &quot;source&quot;: &quot;网易娱乐专稿&quot;,
                &quot;imgsrc&quot;: &quot;http://cms-bucket.nosdn.127.net/a11079eb004f445abdb7146850e4810d20160913141047.jpeg&quot;,
                &quot;docID&quot;: &quot;C0RN7O7N00034VR2&quot;,
                &quot;from&quot;: &quot;HZ&quot;,
                &quot;type&quot;: &quot;doc&quot;,
                &quot;ptime&quot;: &quot;2016-09-13 14:13:21&quot;,
                &quot;href&quot;: &quot;&quot;
            },
            {
                &quot;id&quot;: &quot;C0DBP4LV0517ACQ1&quot;,
                &quot;title&quot;: &quot;老梁说天下：郭德纲为什么这么能“惹事儿”&quot;,
                &quot;source&quot;: &quot;纵横娱乐&quot;,
                &quot;imgsrc&quot;: &quot;http://dingyue.nosdn.127.net/sYo3zfohiqrXHHZIhYV0wqZTpE7RavK7qWneE4BsRH6O=1473265404780compressflag.png&quot;,
                &quot;docID&quot;: &quot;C0DBP4LV0517ACQ1&quot;,
                &quot;from&quot;: &quot;HZ&quot;,
                &quot;type&quot;: &quot;doc&quot;,
                &quot;ptime&quot;: &quot;2016-09-08 00:23:46&quot;,
                &quot;href&quot;: &quot;&quot;
            },
            {
                &quot;id&quot;: &quot;C0R1QGIN051789DB&quot;,
                &quot;title&quot;: &quot;唯一被戏称德云社第一女弟子女星，却是郭德纲铁杆粉丝&quot;,
                &quot;source&quot;: &quot;娱乐大嘴&quot;,
                &quot;imgsrc&quot;: &quot;http://dingyue.nosdn.127.net/I=T7AyADVhb6T8KiCoR0Yw0mKqBXyzUNKWyafBy9PRvxF1473724249899.jpg&quot;,
                &quot;docID&quot;: &quot;C0R1QGIN051789DB&quot;,
                &quot;from&quot;: &quot;HZ&quot;,
                &quot;type&quot;: &quot;doc&quot;,
                &quot;ptime&quot;: &quot;2016-09-13 08:01:08&quot;,
                &quot;href&quot;: &quot;&quot;
            }
        ],
        &quot;ptime&quot;: &quot;2016-09-12 06:59:42&quot;
    }
}
</code></pre>
<p>我们可以看出, <code>body</code> 里面是配置好的html,同时里面也给出了图片占位符类似于 <code>&lt;!--IMG#0--&gt;</code>,通过 <code>img</code> 数组里面的的内容进行替换,img里面提供类似</p>
<pre><code class="language-plain_text">{
    &quot;ref&quot;: &quot;&lt;!--IMG#0--&gt;&quot;, 
    &quot;pixel&quot;: &quot;400*263&quot;, 
    &quot;alt&quot;: &quot;&quot;, 
    &quot;src&quot;: &quot;http://dingyue.nosdn.127.net/s9VWjHPwFtTeqKoYJBULaIbs5TmzcYeGFQeljU0IFvZrD1473633706236.jpg&quot;
},
</code></pre>
<p>提供了 <code>body</code> 里面的占位符,同时还提供了,pixel,alt,src等.这时我们可以做的事情就多了,根据占位符替换 <code>body</code> 中的占位,通过原生网络下载图片等等.Demo中我只做了简单的HTML拼接.拼接好HTML在把本地的模板添加进去,比如css,js等.最后直接把拼接好的完整的HTML给webView,让其显示.具体Demo已经提供了,仅供参考.效果图:</p>
<p><img src="media/16587402953267/14738361521187.gif" alt="" /><br />
(仅供参考,css我只是简单的按照大概写的,勿喷)</p>
<p>####Socket模拟HTTP请求<br />
第二个Demo中模拟了Socket发送HTTP请求的方式,当然我这里只是猜测手Q的实现方式.需要注意的地方就是拼接请求头.</p>
<pre><code class="language-plain_text">    //拼接http请求
    NSString *request = @&quot;GET / HTTP/1.1\n&quot;
    &quot;Connection: Close\n&quot;
    &quot;Host: m.baidu.com\n&quot;
    //告诉服务器客户端是mac
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36\n\n&quot;;
</code></pre>
<h2><a id="%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他优化方案</h2>
<p>可以设置url缓存,直接在Appdelegate中默认设置就好了..</p>
<pre><code class="language-plain_text">//网络缓存优化 -- 设置 4 MB 的内存缓存， 50MB 的磁盘缓存
    NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024 diskCapacity:50 * 1024 * 1024 diskPath:nil];
    [NSURLCache setSharedURLCache:URLCache];
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402953495.html">AbsorbPointer和IgnorePointer</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>iOS平台控件本身提供isUserInterfaceEnable 用来控制是否与用户交互，flutter中则需要AbsorbPointer和IgnorePointer来进行组件包装实现。</p>
<ul>
<li>参见 <a href="https://blog.csdn.net/mengks1987/article/details/105440465">Flutter AbsorbPointer 与 IgnorePointer的区别</a></li>
</ul>
<h2><a id="absorbpointer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AbsorbPointer</h2>
<p>AbsorbPointer是一种禁止用户输入的控件，比如按钮的点击、输入框的输入、ListView的滚动等，你可能说将按钮的onPressed设置为null，一样也可以实现，是的，但AbsorbPointer可以提供多组件的统一控制，而不需要你单独为每一个组件设置。</p>
<p>用法如下：</p>
<pre><code class="language-dart">AbsorbPointer(
  child: Row(
    children: &lt;Widget&gt;[
      RaisedButton(onPressed: (){},),
      RaisedButton(onPressed: (){},),
      RaisedButton(onPressed: (){},),
      RaisedButton(onPressed: (){},),

    ],
  ),
)
</code></pre>
<p>默认情况下，这些按钮是否响应点击事件的，如果想要响应点击事件只需设置absorbing为false即可：</p>
<pre><code class="language-dart">AbsorbPointer(
  absorbing: false,
  ...
)
</code></pre>
<h2><a id="ignorepointer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>IgnorePointer</h2>
<p>IgnorePointer的用法和AbsorbPointer一样，而且达到的效果一样，用法如下：</p>
<pre><code class="language-dart">IgnorePointer(
  child: Row(
    children: &lt;Widget&gt;[
      RaisedButton(onPressed: (){},),
      RaisedButton(onPressed: (){},),
      RaisedButton(onPressed: (){},),
      RaisedButton(onPressed: (){},),
    ],
  ),
)
</code></pre>
<h2><a id="%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>区别</h2>
<p>AbsorbPointer本身可以接收点击事件，消耗掉事件，而IgnorePointer无法接收点击事件，其下的控件可以接收到点击事件（不是子控件）。</p>
<p>如果有2个盒子，一个200x200的红色盒子，一个100x100的蓝色盒子，蓝色盒子位于红色盒子之上居中显示，给2个盒子添加点击事件，如下:</p>
<pre><code class="language-dart">return Container(
      height: 200,
      width: 200,
      child: Stack(
        alignment: Alignment.center,
        children: &lt;Widget&gt;[
          Listener(
            onPointerDown: (v) {
              print('click red');
            },
            child: Container(
              color: Colors.red,
            ),
          ),
          Listener(
            onPointerDown: (v) {
              print('click red');
            },
            child: Container(
              color: Colors.blue,
              width: 100,
              height: 100,
            ),
          ),
        ],
      ),
    );
</code></pre>
<p>点击蓝色盒子时，打印结果：</p>
<pre><code class="language-dart">flutter: click blue
</code></pre>
<p>点击蓝色盒子区域以外的红色盒子，打印结果：</p>
<pre><code class="language-dart">flutter: click red
</code></pre>
<p>此时用AbsorbPointer包裹蓝色盒子</p>
<pre><code class="language-dart">return Container(
  height: 200,
  width: 200,
  child: Stack(
    alignment: Alignment.center,
    children: &lt;Widget&gt;[
      Listener(
        onPointerDown: (v) {
          print('click red');
        },
        child: Container(
          color: Colors.red,
        ),
      ),
      Listener(
        onPointerDown: (v) {
          print('click blue self');
        },
        child: AbsorbPointer(
          child: Listener(
            onPointerDown: (v) {
              print('click blue child');
            },
            child: Container(
              color: Colors.blue,
              width: 100,
              height: 100,
            ),
          ),
        ),
      ),
    ],
  ),
);
</code></pre>
<p>点击蓝色盒子，打印如下：</p>
<pre><code class="language-dart">flutter: click blue self
</code></pre>
<p>说明AbsorbPointer本身接收到了点击事件，将AbsorbPointer改为IgnorePointer,打印如下：</p>
<pre><code class="language-dart">flutter: click red
</code></pre>
<p>点击事件穿透蓝色盒子到红色盒子，红色盒子接收到了点击事件。</p>
<h2><a id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用场景</h2>
<ol>
<li>根据业务需求禁用/启用多个组件。</li>
<li>根据业务需求禁用/启用整个App。</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402953663.html">Flutter 中 TabBarView 点击切换，监听会调用多出</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E8%B0%83%E7%94%A8%E5%A4%9A%E6%AC%A1%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用多次原因</h2>
<p>在Flutter源码中 <code>src/material/tab_controller.dart</code> 中 <code>void _changeIndex(int value, { Duration? duration, Curve? curve })</code> 方法里面动画调用会通知两次</p>
<pre><code class="language-Swift">
  void _changeIndex(int value, { Duration? duration, Curve? curve }) {
    assert(value != null);
    assert(value &gt;= 0 &amp;&amp; (value &lt; length || length == 0));
    assert(duration != null || curve == null);
    assert(_indexIsChangingCount &gt;= 0);
    if (value == _index || length &lt; 2)
      return;
    _previousIndex = index;
    _index = value;
    if (duration != null) { // 有动画执行
      _indexIsChangingCount += 1;
      // 通知1: 这里通知监听者 indexIsChanging
      notifyListeners(); // Because the value of indexIsChanging may have changed.
      _animationController!
        .animateTo(_index.toDouble(), duration: duration, curve: curve!)
        .whenCompleteOrCancel(() {
          if (_animationController != null) { // don't notify if we've been disposed  已经释放就不在通知
            _indexIsChangingCount -= 1;
            // 通知2：这里通知监听者 动画完成
            notifyListeners();
          }
        });
    } else {
      _indexIsChangingCount += 1;
      _animationController!.value = _index.toDouble();
      _indexIsChangingCount -= 1;
      // 不执行动画 只通知一次
      notifyListeners();
    }
  }
</code></pre>
<h2><a id="%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>怎么解决呢</h2>
<p>在该文件第222行中</p>
<pre><code class="language-plain_text">  _animationController!
        .animateTo(_index.toDouble(), duration: duration, curve: curve!)
</code></pre>
<p>这里是动画执行的时候把目标<code>target</code>传递给 <code>_animationController</code>, 而<code>animation_controller.dart</code> 中会做判断</p>
<ol>
<li>
<p>在第593行</p>
<pre><code class="language-plain_text">if (target == value) {
  // Already at target, don't animate.
  simulationDuration = Duration.zero;
}
</code></pre>
</li>
<li>
<p>在第600行</p>
<pre><code class="language-plain_text">_value = target.clamp(lowerBound, upperBound);
</code></pre>
</li>
</ol>
<p>执行到最后的时候 <code>_value</code> 就是传入的<code>target</code>。 如果不执行动画会直接进行赋值操作<code>_animationController!.value = _index.toDouble();</code> 。所以我们可以在通知中判断动画的值是否和target一致，一致就是动画完成了。这时再做处理就不会执行多次了。</p>
<p>所以我们可以做如下判断：</p>
<pre><code class="language-plain_text">_tabController.addListener(() {
    if(_tabController.index.toDouble() == _tabController.animation!.value){
      // 这里是我们要执行的。。。
    }
});
</code></pre>
<h2><a id="%E8%BF%99%E9%87%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E6%88%91%E8%A6%81%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>这里如果是我要怎么设计</h2>
<p><code>tab_controller.dart</code> 是经常和动画打交道的，所以可以选择添加</p>
<pre><code class="language-plain_text">void addStatusListener(AnimationStatusListener listener) {
  didRegisterListener();
  _statusListeners.add(listener);
}
</code></pre>
<p>根据状态来进行选择执行操作,这样也符合苹果设计的通知，notification中可以添加info根据info做判断。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402953824.html">Mac zsh 使用命令打开sublime</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1%E6%B7%BB%E5%8A%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1/添加</h2>
<p><code>vim .zshrc</code></p>
<p>添加<br />
<code>alias subl=&quot;open -a Sublime\ Text&quot;</code>（如果你是Sublime Text ）<br />
或者<br />
<code>alias subl=&quot;open -a Sublime\ Text\ 2&quot;</code> （如果你是Sublime Text 2）</p>
<h2><a id="2%E7%94%9F%E6%95%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2/生效</h2>
<p><code>source ~/.zshrc</code></p>
<h2><a id="3%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3/测试</h2>
<p>在命令行输入：<br />
<code>subl</code>     就可以打开sublime</p>
<p>输入：<br />
<code>subl test.txt</code> 就可以打开文件</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402953989.html">查询验证码</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>select * from crm_msg_send_log where phone='13651108116' order by ts desc ;</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402954157.html">Swift - Swift与JavaScript交互实战[转]</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>原地址:<a href="http://mp.weixin.qq.com/s?__biz=MzIzMzA4NjA5Mw==&amp;mid=214070747&amp;idx=1&amp;sn=57b45fa293d0500365d9a0a4ff74a4e1#rd">Swift与JavaScript交互实战（Swift版）</a></p>
</blockquote>
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>Swift与Js交互是常见的需求，可对于新手或者所谓的高手而言，其实并不是那么简单明了。这里只介绍iOS7.0后出来的JavaScriptCore framework。</p>
<h2><a id="%E5%85%B3%E4%BA%8Ejavascriptcore" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于JavaScriptCore</h2>
<p>本教程中所涉及到的几种类型：</p>
<ul>
<li><strong>JSContext</strong>, JSContext是代表JS的执行环境，通过-evaluateScript:方法就可以执行一JS代码</li>
<li><strong>JSValue</strong>, JSValue封装了JS与ObjC中的对应的类型，以及调用JS的API等</li>
<li><strong>JSExport</strong>, JSExport是一个协议，遵守此协议，就可以定义我们自己的协议，在协议中声明的API都会在JS中暴露出来，才能调用</li>
</ul>
<h2><a id="swift%E4%B8%8Ejs%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Swift与JS交互方式</h2>
<p>通过JSContext，我们有两种调用JS代码的方法：</p>
<ul>
<li>1、直接调用JS代码</li>
<li>2、在Swift中通过JSContext<strong>注入模型</strong>，然后调用模型的方法</li>
</ul>
<h3><a id="%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8js%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>直接调用JS代码</h3>
<p>我们可以不通过模型来调用方法，也可以直接调用方法</p>
<pre><code class="language-plain_text">let context = JSContext() 
context.evaluateScript(“var num = 10”)
context.evaluateScript(“function square(value) { return value * 2}”)

// 直接调用
let squareValue = context.evaluateScript(“square(num)”)
print(squareValue)

// 通过下标来获取到JS方法。
let squareFunc = context.objectForKeyedSubscript(“square”)
print(squareFunc.callWithArguments([“10”]).toString());
</code></pre>
<p>这种方式是没有注入模型到JS中的。这种方式使用起来不太合适，通常在JS中有很多全局的函数，为了防止名字重名，使用模型的方式是最好不过了。通过我们协商好的模型名称，在JS中直接通过模型来调用我们在Swift中所定义的模型所公开的API。</p>
<h2><a id="%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BA%A4%E4%BA%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注入模型的交互</h2>
<p>首先，我们需要先定义一个协议，而且这个协议必须要遵守JSExport协议。</p>
<p>All methods that should apply in Javascript,should be in the following protocol.注意，这里必须使用@objc，因为JavaScriptCore库是ObjectiveC版本的。如果不加@objc，则调用无效果。</p>
<pre><code class="language-plain_text">@objc protocol JavaScriptSwiftDelegate: JSExport { 
 func callSystemCamera();
 func showAlert(title: String, msg: String);
 func callWithDict(dict: [String: AnyObject]);
 func jsCallObjcAndObjcCallJsWithDict(dict: [String: AnyObject]);
}
</code></pre>
<p>接下来，我们还需要定义一个模型：</p>
<pre><code class="language-plain_text">@objc classJSObjCModel: NSObject, JavaScriptSwiftDelegate { 
  weak var controller: UIViewController? 
  weak var jsContext: JSContext? 

  func callSystemCamera() {   
    print(“js call objc method: callSystemCamera”);
    let jsFunc = self.jsContext?.objectForKeyedSubscript(“jsFunc”); 
    jsFunc?.callWithArguments([]);  
  }

  func showAlert(title: String, msg: String) {     
    dispatch_async(dispatch_get_main_queue()) { () -&gt; Void in   
      let alert = UIAlertController(title: title, message: msg, preferredStyle: .Alert)   
      alert.addAction(UIAlertAction(title: “ok”, style: .Default, handler: nil))      
      self.controller?.presentViewController(alert, animated: true, completion: nil)   
    }   
  }  

  // JS调用了我们的方法   
  func callWithDict(dict: [String : AnyObject]) {   
    print(“js call objc method: callWithDict, args: %@”, dict) 
  }

  // JS调用了我们的就去  
  func jsCallObjcAndObjcCallJsWithDict(dict: [String : AnyObject]) {     
    print(“js call objc method: jsCallObjcAndObjcCallJsWithDict, args: %@”, dict) 
    let jsParamFunc = self.jsContext?.objectForKeyedSubscript(“jsParamFunc”); 
    let dict = NSDictionary(dictionary: [“age”: 18, “height”: 168, “name”: “lili”])
    jsParamFunc?.callWithArguments([dict]) 
  }
}
</code></pre>
<p>接下来，我们在controller中在webview加载完成的代理中，给JS注入模型。</p>
<pre><code class="language-plain_text">// MARK: - UIWebViewDelegate
func webViewDidFinishLoad(webView: UIWebView) {
  let context = webView.valueForKeyPath(“documentView.webView.mainFrame.javaScriptContext”) as? JSContextlet 
  model = JSObjCModel() 
  model.controller = self
  model.jsContext = context
  self.jsContext = context

  // 这一步是将OCModel这个模型注入到JS中，在JS就
  // 可以通过OCModel调用我们公暴露的方法了。
  self.jsContext?.setObject(model, forKeyedSubscript: “OCModel”)
  self.jsContext?.exceptionHandler = { (context, exception) in 
     print(“exception @”, exception) 
  }
}
</code></pre>
<p>我们是通过webView的valueForKeyPath获取的，其路径为documentView.webView.mainFrame.javaScriptContext。<br />
这样就可以获取到JS的context，然后为这个context注入我们的模型对象。<br />
我们先写两个JS方法：</p>
<pre><code class="language-plain_text">var jsFunc = function() {
  alert(‘Objective-C call js to show alert’);
}

var jsParamFunc = function(argument) {
  document.getElementById(‘jsParamFuncSpan’).innerHTML
  = argument[‘name’];
}
</code></pre>
<p>这里我们定义了两个JS方法，一个是jsFunc，不带参数。<br />
另一个是jsParamFunc，带一个参数。<br />
接下来，我们在html中的body中添加以下代码：</p>
<p><code>Test how to use objective-c call js</code></p>
<p>现在就可以测试代码了。</p>
<p>当我们点击第一个按钮：Call ObjC system camera时，<br />
通过OCModel.callSystemCamera()，就可以在HTML中通过JS调用OC的方法。<br />
在Swift代码中，我们的callSystemCamera方法体中，添加了以下两行代码，就是获取HTML中所定义的JS就去jsFunc，然后调用它。</p>
<pre><code class="language-plain_text">let jsFunc = self.jsContext?.objectForKeyedSubscript(“jsFunc”); jsFunc?.callWithArguments([]);
</code></pre>
<p>这样就可以在JS调用Siwft方法时，也让Swift反馈给JS。<br />
注意：这里是通过objectForKeyedSubscript方法来获取变量jsFunc。<br />
方法也是变量。看看下面传字典参数：</p>
<pre><code class="language-plain_text">(void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary )params {
    NSLog(@”jsCallObjcAndObjcCallJsWithDict was called, params is %@”, params);
    // 调用JS的方法
    JSValue jsParamFunc = self.jsContext[@”jsParamFunc”];
    [jsParamFunc callWithArguments:@[@{@”age”: @10, @”name”: @”lili”, @”height”: @158}]];
}
</code></pre>
<p>获取我们在HTML中定义的jsParamFunc方法，然后调用它并传了一个字典作为参数。<br />
好了，就讲这么多吧，如果想要Demo源代码，请到</p>
<ul>
<li>github：<strong><a href="https://github.com/CoderJackyHuang/IOSCallJsOrJsCallIOS">https://github.com/CoderJackyHuang/IOSCallJsOrJsCallIOS</a></strong></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402954341.html">JDBC Class.forName vs DriverManager.registerDriver</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>要使用JDBC与数据库连接，需要选择获取相应数据库的驱动程序并注册该驱动程序,有两种方式可以注册</p>
<pre><code class="language-plain_text">DriverManager.registerDriver(new com.mysql.jdbc.Driver());
</code></pre>
<pre><code class="language-plain_text">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
</code></pre>
<p>当然现在也可以不用执行上面的操作也能正常执行,原因就是<code>SPI机制</code><br />
<a href="https://juejin.im/post/6844903605695152142">Java SPI机制详解</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402954511.html">Linux - 常用基本命令</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.命令使用方法</h2>
<p>Linux命令格式:</p>
<pre><code class="language-plain_text">    command  [-options]  [parameter1]  …
</code></pre>
<p>说明：</p>
<ul>
<li>command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，<code>[]代表可选</code> parameter1 …：传给命令的参数：可以是零个一个或多个</li>
</ul>
<p>例：</p>
<p><img src="media/16587402954511/14954519660499.jpg" alt="" /></p>
<h2><a id="2%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.查看帮助文档</h2>
<h3><a id="1-help" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>&lt;1&gt; --help</h3>
<p>一般是linux命令自带的帮助信息</p>
<p>如：ls --help</p>
<h3><a id="2-man%E6%9C%89%E9%97%AE%E9%A2%98%E6%89%BE%E7%94%B7%E4%BA%BA%EF%BC%8C-manual" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>&lt;2&gt; man(有问题找男人，manual)</h3>
<p>man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明</p>
<p>该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。</p>
<p>例：man ls ; man 2 printf</p>
<p>man中各个section意义如下：</p>
<ol>
<li>Standard commands（标准命令）</li>
<li>System calls（系统调用，如open,write）</li>
<li>Library functions（库函数，如printf,fopen）</li>
<li>Special devices（设备文件的说明，/dev下各种设备）</li>
<li>File formats（文件格式，如passwd）</li>
<li>Games and toys（游戏和娱乐）</li>
<li>Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</li>
<li>Administrative Commands（管理员命令，如ifconfig）</li>
</ol>
<p>man是按照手册的章节号的顺序进行搜索的。</p>
<p>man设置了如下的功能键：</p>
<table>
<thead>
<tr>
<th style="text-align: center">功能键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">空格键</td>
<td>显示手册页的下一屏</td>
</tr>
<tr>
<td style="text-align: center">Enter键</td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td style="text-align: center">b</td>
<td>回滚一屏</td>
</tr>
<tr>
<td style="text-align: center">f</td>
<td>前滚一屏</td>
</tr>
<tr>
<td style="text-align: center">q</td>
<td>退出man命令</td>
</tr>
<tr>
<td style="text-align: center">h</td>
<td>列出所有功能键</td>
</tr>
<tr>
<td style="text-align: center">/word</td>
<td>搜索word字符串</td>
</tr>
</tbody>
</table>
<p><img src="media/16587402954511/14954525011190.jpg" alt="" /></p>
<p>注意：实际上，我们不用指定第几个章节也用查看，如，man ls</p>
<h2><a id="3%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.自动补全：</h2>
<p>在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令</p>
<h2><a id="4%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.历史命令：</h2>
<p>当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402954722.html">Java开发环境搭建的准备工作</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3><a id="%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BF%AE%E6%94%B9hosts%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络配置（修改hosts）</h3>
<h4><a id="%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么时候需要</h4>
<p>比如我们在安装<a href="https://brew.sh">homeBrew</a>的时候会遇到</p>
<pre><code class="language-plain_text">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
</code></pre>
<p>发现脚本需要到 <code>raw.githubusercontent.com</code>上拉取代码,但是域名的DNS解析被污染，导致DNS解析过程不能获取正确的IP地址。</p>
<h4><a id="%E6%80%8E%E6%A0%B7%E6%89%BE%E6%9B%BF%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>怎样找替换</h4>
<p>打开 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a> 输入访问不了的域名,即<code>raw.githubusercontent.com</code><br />
可以看到<br />
<img src="media/16587402954722/15989690890684.jpg" alt="" /><br />
<img src="media/16587402954722/15989691067248.jpg" alt="" /></p>
<p>把找到的IP直接在<code>hosts</code>中映射就好了</p>
<h4><a id="%E6%80%8E%E6%A0%B7%E8%BF%9B%E8%A1%8Chosts%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>怎样进行hosts文件修改</h4>
<p>为了方便进行网络资源访问比如<code>github</code>我们需要对<code>hosts</code>文件进行修改，对于Mac常规的方式是在<code>Finder</code>中使用 快捷键<code> command + shift + G</code>。<br />
<img src="media/16587402954722/15989691425407.jpg" alt="" /></p>
<p>这里我推荐用第二种<a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a><br />
<img src="media/16587402954722/15989691528858.jpg" alt="" /></p>
<h3><a id="%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开发环境</h3>
<h4><a id="java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java环境搭建</h4>
<h5><a id="jdk%E4%B8%8B%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JDK下载</h5>
<p>Google <code>jdk download</code> 我们会找到Oracle网站，选择<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">jdk8版本下载</a></p>
<h5><a id="java%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java配置环境变量</h5>
<p>打开<code>terminal</code>,我喜欢用 <a href="https://iterm2.com/">iTerm2</a> 搭配<a href="https://ohmyz.sh/">Oh My Zsh</a>. 输入<code>code .bash_profile</code>(code 是vscode命令,怎么配置用vscode在terminal中使用见<a href="https://code.visualstudio.com/docs/setup/mac">Visual Studio Code on macOS<br />
</a>)</p>
<p><img src="media/16587402954722/15989691773089.jpg" alt="" /></p>
<p>如果是第一次配置环境变量，使用命令 <code>touch .bash_profile</code> 创建一个名为 <strong>.bash_profile</strong> 隐藏配置文件(怎么查看隐藏文件(快捷键 <code>command + shift + .</code>));</p>
<p>查看当前安装的Java版本号<br />
在<code>terminal</code>中输入<code>java -version</code><br />
<img src="media/16587402954722/15989691952963.jpg" alt="" /></p>
<p>在配置文件中输入下面的内容：</p>
<pre><code class="language-shell">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home
PATH=$JAVA_HOME/bin:$PATH:.
CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH
</code></pre>
<p>JAVA_Home 中版本号就是上面terminal中显示的版本号,当然这个办法比较土，也可以按照苹果开发者网站上的办法找<a href="https://developer.apple.com/library/archive/qa/qa1170/_index.html">Important Java Directories on Mac OS </a><br />
在terminal中输入<code>ls -l /usr/libexec/java_home</code><br />
<img src="media/16587402954722/15989692092687.jpg" alt="" /></p>
<p>出现文件的时候可以按住<code>command</code>点击目录跳转也就会显示出上面截图中的路径</p>
<h5><a id="%E9%98%85%E8%AF%BB%E5%85%AC%E5%8F%B8%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>阅读公司技术文档</h5>
<p>文档地址：<a href="http://10.10.70.44:7202/pages/viewpage.action?pageId=13729808">SpringCloud微服务架构</a></p>
<p>这篇文档中说明了项目的模块划分和环境信息等</p>
<h5><a id="%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%8C%85maven" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速导包(Maven)</h5>
<p>第一运行下载依赖包非常慢，然后同事把他电脑中的资源直接打包发给我替换掉原有的资源就完成了依赖包的下载过程。<br />
<img src="media/16587402954722/15989692306566.jpg" alt="" /></p>
<p>进入该文件夹，然后替换资源文件<br />
<img src="media/16587402954722/15989692404224.jpg" alt="" /></p>
<hr />
<p>到这里所有的前期准备工作都做完了可以运行项目了。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402954920.html">Swift - convenience 便利构造函数</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>具体解释可以参见 <strong>Swifter</strong> 中<code>Designated，Convenience 和 Required</code></p>
</blockquote>
<p>使用遍历工造函数的好处可以参见如下代码:</p>
<pre><code class="language-plain_text">import UIKit

extension UITextField {
    convenience init(frame:CGRect, placeholder:String,fontSize:CGFloat = 14) {
        self.init(frame:frame)
        
        self.borderStyle = .roundedRect
        self.placeholder = placeholder
        self.font = UIFont.systemFont(ofSize: fontSize)
    }
}

</code></pre>
<p><strong>好处:</strong></p>
<ol>
<li>判断条件,只有满足条件才实例化对象,可以防止造成不必要的内存开销</li>
<li>简化对象的创建  -&gt;利用<code>extension</code>抽取控件创建方法</li>
<li>本身不负责属性的创建和初始化工作</li>
<li>可以返回nil</li>
</ol>
<p><strong>注意点:</strong></p>
<ol>
<li>必须调用本类的 <code>self.init</code>,不能调用父类的<code>super.init</code></li>
<li>不能被重写</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402955078.html">算法总结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="fibonacci%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fibonacci （斐波那契数列实现）</h2>
<pre><code class="language-plain_text">///Fibonacci （斐波那契数列实现）
func fibonacci(_ n: Int) -&gt; Int{
    let result = [0,1]
    if n &lt; 2 {
        return result[n]
    }
    
    var fibNMinusOne = 1
    var fibNMinusTwo = 0
    var fibN = 0
    
    for _ in 2...n {
        fibN = fibNMinusOne + fibNMinusTwo
        fibNMinusTwo = fibNMinusOne
        fibNMinusOne = fibN
    }
    return fibN
}
</code></pre>
<h2><a id="binarysearch%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BinarySearch (二分查找)</h2>
<h3><a id="%E9%9D%9E%E9%80%92%E5%BD%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>非递归</h3>
<pre><code class="language-plain_text">func binarySearch&lt;T: Comparable&gt;(_ a:[T], key: T) -&gt; Int {
    print(key)
    var lowerBound = 0
    var upperBound = a.count
    while lowerBound &lt; upperBound {

        let midIndex = lowerBound + (upperBound - lowerBound)/2

        if a[midIndex] == key {
            return midIndex
        }else if a[midIndex] &lt; key {
            lowerBound = midIndex + 1
        }else {
            upperBound = midIndex
        }
    }
    return -1
}
</code></pre>
<p>###递归</p>
<pre><code class="language-plain_text">func binarySearch&lt;T : Comparable&gt;(startIndex: Int, endIndex: Int , arr:[T], key: T) -&gt; Int{
    let mind = startIndex + (endIndex - startIndex) / 2
    let mindValue = arr[mind]
    if mindValue == key {
        return mind
    }
    if mindValue &lt; key {
        return binarySearch(startIndex: mind + 1, endIndex: endIndex, arr: arr, key: key)
    } else if mindValue &gt; key {
        return binarySearch(startIndex: 0, endIndex: mind, arr: arr, key: key)
    }
    return -1
}
</code></pre>
<p>##快速排序</p>
<pre><code class="language-plain_text">func quicksort&lt;T: Comparable&gt;(_ unsort:[T]) -&gt; [T] {
    guard unsort.count &gt; 1 else {
        return unsort
    }
    
    let pivot = unsort[unsort.count / 2]
    let less = unsort.filter { $0 &lt; pivot }
    let equal = unsort.filter { $0 == pivot }
    let greater = unsort.filter { $0 &gt; pivot }
    
    return quicksort(less) + equal + quicksort(greater)
}
</code></pre>
<p>测试结果</p>
<pre><code class="language-plain_text">let list = [ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ]

print(list)
print(quicksort(list))
--------------------
[10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26]
[-1, 0, 1, 2, 3, 5, 8, 8, 9, 10, 14, 26, 27]

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402955237.html">静态方法和实例方法不同点</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>
<p>在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>
</li>
<li>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制.</p>
</li>
</ol>
<blockquote>
<p>注意: 在Swift中，静态方法不能通过 <code>对象名.方法名</code> 的方式调用。</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402955394.html">MKNetWork简介</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>用户版最新版本我将替换成最新的网络请求封装,这次我将封装一些常用的东西到网络请求中,让网络请求独立出一层,避免所有网络请求都写在控制器中.<br />
目录结构:</p>
<ul>
<li><strong>MKBaseRequest</strong>     :所有的网络请求类需要继承于 <code>MKBaseRequest</code> 类，每一个<code>MKBaseRequest</code> 类的子类代表一种专门的网络请求。<br />
MKBaseRequest 的基本的思想是把每一个网络请求封装成对象。所以使用 MKNetWork，你的每一种请求都需要继承 MKBaseRequest类，通过覆盖父类的一些方法来构造指定的网络请求。把每一个网络请求封装成对象其实是使用了设计模式中的 Command 模式。<br />
每一种网络请求继承 MKBaseRequest 类后，需要用方法覆盖（overwrite）的方式，来指定网络请求的具体信息。例如:</li>
</ul>
<pre><code class="language-plain_text">// 重写接口名称
-(NSString *)requestUrl {
    return @&quot;geocode/regeo&quot;;
}
// 重写请求方式
-(MKRequestMethod)requestMethod {
    return MKRequestMethodGet;
}
// 重写想要的放回数据解析方式
-(MKRequestSerializerType)requestSerializerType {
    return MKRequestSerializerTypeHTTP;
}
</code></pre>
<p>目前没有添加返回参数格式验证,如有需要可以在base中添加,让继承者重写.</p>
<ul>
<li><strong>MKNetWorkAgent</strong>    :MKNetWorkAgent最基础的网络请求封装,目前封装的AFN,如有必要可以替换</li>
<li><strong>MKNetworkConfig</strong>   :用于统一设置网络请求的服务器和 CDN 的地址。在实际业务中，我们的测试需要切换不同的服务器地址来测试。统一设置服务器地址到 MKNetworkConfig 类中，也便于我们统一切换服务器地址。</li>
</ul>
<pre><code class="language-plain_text"> - (void)setupRequestFilters {
    // 这里用高德Api进行测试
    NSString *appVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];
    MKNetworkConfig *config = [MKNetworkConfig sharedInstance];
    config.baseUrl = @&quot;http://restapi.amap.com/v3/&quot;;
    MKUrlArgumentsFilter *urlFilter = [MKUrlArgumentsFilter filterWithArguments:@{@&quot;version&quot;: appVersion}];
    [config addUrlFilter:urlFilter];
}


- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    [self setupRequestFilters];
    
    return YES;
} 
</code></pre>
<ul>
<li><strong>MKChainRequest</strong>    :用于管理有相互依赖的网络请求，它实际上最终可以用来管理多个拓扑排序后的网络请求。</li>
</ul>
<p>例如，我们有一个需求，需要用户在注册时，先发送注册的Api，然后:</p>
<ol>
<li>如果注册成功，再发送读取用户信息的Api。并且，读取用户信息的Api需要使用注册成功返回的用户id号。</li>
<li>如果注册失败，则不发送读取用户信息的Api了。</li>
</ol>
<p><strong>不足:</strong></p>
<ol>
<li>目前没有做缓存,由于项目中url是根据时间戳,可以使用已有的缓存作为补充.也可以写到网络层封装中.</li>
<li>串行网络请求封装了,但是由于默认就是并行网络请求,所以没有封装.如果需要限制最大并发数量,可以在<code>MKNetWorkAgent</code>中设置.</li>
<li>木有大量测试,可能存在bug</li>
</ol>
<p><strong>注意事项:</strong><br />
基本没有啥需要注意的...,具体使用方法可以参见Demo,关于参数可以实现代理方法,也可以直接传参.如果直接传参,会覆盖掉代理中的数据源.  Demo中实现了简单的下拉加载中关于page的封装.扩展功能我都写成代理,然后需要什么功能实现以下就可以了,避免<code>MKBaseRequest</code>中包含太多功能,这样可以实现自定义组成自己需要的功能.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402955552.html">Swift - 懒加载 lazy</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>为什么使用懒加载?</p>
<ol>
<li>能够延迟创建</li>
<li>解除解包的烦恼</li>
</ol>
<blockquote>
<p>参考<strong>Swifter</strong>中`lazy 修饰符和 lazy 方法</p>
</blockquote>
<p>##常用方法</p>
<p>OC中的懒加载</p>
<pre><code class="language-plain_text">// ClassA.h
@property (nonatomic, copy) NSString *testString;

// ClassA.m
- (NSString *)testString {
     if (!_testString) {
         _testString = @&quot;Hello&quot;;
        NSLog(@&quot;只在首次访问输出&quot;);
     }
     return _testString;
}
</code></pre>
<p>Swift中:</p>
<pre><code class="language-plain_text">class ClassA {
    lazy var str: String = {
        let str = &quot;Hello&quot;
        print(&quot;只在首次访问输出&quot;)
        return str
    }()
}
</code></pre>
<p>简化版本:</p>
<pre><code class="language-plain_text">lazy var str: String = &quot;Hello&quot;
</code></pre>
<p>##其他用法</p>
<pre><code class="language-plain_text">        let data = 1...3
        let result = data.map { (i:Int) -&gt; Int in
            print(&quot;正在处理\(i)&quot;)
            return 1*2
        }
        
        print(&quot;准备访问结果&quot;)
        
        for i in result {
            print(&quot;操作后结果为\(i)&quot;)
        }

</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">正在处理1
正在处理2
正在处理3
准备访问结果
操作后结果为2
操作后结果为4
操作后结果为6
</code></pre>
<p>如果使用lazy</p>
<pre><code class="language-plain_text">        let data = 1...3
        let result = data.lazy.map { (i:Int) -&gt; Int in
            print(&quot;正在处理\(i)&quot;)
            return i*2
        }
        
        print(&quot;准备访问结果&quot;)
        
        for i in result {
            print(&quot;操作后结果为\(i)&quot;)
        }

</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">准备访问结果
正在处理1
操作后结果为2
正在处理2
操作后结果为4
正在处理3
操作后结果为6
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402955711.html">一张图了解正则表达式</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402955711/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="正则表达式" /><br />
(图片源自CSDN)</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402955879.html">点菜数据逻辑</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>流程</h2>
<p>用户点击加减号调用:<code>OrderDishManager</code>中的<code>- (void)updateDishToLocalDishArray:(HTDishEntity *)dish;</code> 这个会把数据保存在<code>localDishArray</code>中,同时应该把数据存储在plist中.</p>
<p>所有的数据都在<code>localDishArray</code>中获取.</p>
<h2><a id="%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%90%8C%E6%AD%A5%E5%85%A8%E9%87%8F%E8%8F%9C%E5%93%81%E4%B8%8A%E4%BC%A0%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么时候同步(全量菜品上传接口)</h2>
<p>切台,换桌的时候需要把菜品上传到服务器(这个是讨论的时候确定的方案)</p>
<p>为了确保信息的完整,在用户将app切换到后台的时候也需要将菜品上传到服务器,崩溃的时候菜品上传到服务器</p>
<p>##下拉数据<br />
开台的时候本地没有数据需要下拉服务器数据.本地使用服务器下拉数据</p>
<p>##数据持久化策略:<br />
<strong>什么时候保存:</strong><br />
当<code>OrderDishManager</code>中的<code>localDishArray</code>改变的时候把<code>localDishArray</code>存储到plist文件中.(内存中的文件发生改变的时候)</p>
<p><strong>什么时候使用:</strong><br />
Pad在闪退、进程被杀掉等突发情况导致的程序非正常退出后，再次启动时保留程序上次退出时已点菜品的状态</p>
<p><strong>保存的是什么:</strong><br />
模型<code>HTDishEntity</code></p>
<h2><a id="orderdishmanager%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>OrderDishManager需要修改</h2>
<p>需要去掉的字段:<br />
addOrdDishArr<br />
updateOrdDishArr<br />
deleteOrdDishArr</p>
<p>不能确定删除的orderedDishArray//已点  目前跟点锅有关联</p>
<pre><code class="language-plain_text">/******************************************************************************
 函数名称 : judgeIfExistLocalYiXiaDish:withServerDish:
 函数描述 : 判断本地单个菜品是否在服务器返回的已下列表中
 输入参数 : N/A
 输出参数 : N/A
 返回值  :
 备  注  : 如果本地有还没来得及同步到服务器的菜品就不删，否则在网络不好的情况下会丢菜
 ******************************************************************************/
- (BOOL)judgeIfExistLocalYiXiaDish:(HTDishEntity *)localDish withServerDish:(TzxDishItem *)serverDish
</code></pre>
<pre><code class="language-plain_text">/******************************************************************************
 函数名称 : judgeIfExistLocalYiXuanDish:withServerDish:
 函数描述 : 判断本地单个菜品是否在服务器返回的已选列表中
 输入参数 : N/A
 输出参数 : N/A
 返回值  :
 备  注  : 如果本地有还没来得及同步到服务器的菜品就不删，否则在网络不好的情况下会丢菜
 ******************************************************************************/
- (BOOL)judgeIfExistLocalYiXuanDish:(HTDishEntity *)localDish withServerDish:(CustomerDishForYiXuan *)serverDish
</code></pre>
<pre><code class="language-plain_text">/******************************************************************************
 函数名称 : beginToDeleteTheExistDishesWithLocalArr:andServerArr:andType:
 函数描述 : 将服务器的数据同步到本地前，先比较一下服务器数据和本地数据，把完全一样的菜删掉
 输入参数 : type 0:已选  1:已下
 输出参数 : N/A
 返回值  :
 备  注  : 如果本地有还没来得及同步到服务器的菜品就不删，否则在网络不好的情况下会丢菜
 ******************************************************************************/
- (void)beginToDeleteTheExistDishesWithLocalArr:(NSMutableArray *)localArr
                                   andServerArr:(NSMutableArray *)serverArr
                                        andType:(int)type
</code></pre>
<pre><code class="language-plain_text">/// 服务员界面 新加菜全部清空按钮点击事件  david---
-(void)clearAllDish
</code></pre>
<p>这个方法中去掉同步</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402956046.html">Swift - 面向协议编程</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>跟全部写在base中比较:</p>
<ol>
<li>代码没有增多,却更复用</li>
<li>面向协议(接口),而不是实现,充分解耦</li>
<li>静态类型检查版主在编译时发现问题</li>
<li>写代码像搭积木,先设计接口,再逐一实现</li>
<li>依赖少,更容易调试</li>
</ol>
<pre><code class="language-plain_text">protocol Hello {
    func sayHello()
}

extension Hello {
    func sayHello() {
        print(&quot;Hello!&quot;)
    }
}

struct Person: Hello {
    
}

let p = Person()
p.sayHello()
</code></pre>
<p>创建一个协议,并且做一个默认实现.使用的时候可以直接调用</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402956214.html">Scroll UICollectionView to section header view</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>新界面左右联动的时候遇到了一个问题,怎么在左侧tableView点击某一cell的时候右侧collectionView跳转到对应的section</p>
<p>如果没有section header View 的时候直接跳转到这个section的第一个Item就ok了,但是如果有section header View 的时候就需要注意了,不能这样进行跳转了,下面👇是经过测试的方法能够完美跳转到相应的section:</p>
<pre><code class="language-plain_text">let attributes = self.collectionView.collectionViewLayout.layoutAttributesForSupplementaryViewOfKind(UICollectionElementKindSectionHeader, atIndexPath: NSIndexPath(forItem: 0, inSection: index))

self.collectionView.setContentOffset(CGPointMake(0, attributes!.frame.origin.y - self.collectionView.contentInset.top), animated: true)
</code></pre>
<p>参见:<a href="http://stackoverflow.com/questions/22100227/scroll-uicollectionview-to-section-header-view">Scroll UICollectionView to section header view</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402956390.html">会议记录(培训)</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##Scrum 快速迭代与反馈<br />
快速迭代得到用户的反馈<br />
##scrum概念<br />
敏捷宣言:个体与交互 高于 流程与工具<br />
工作的软件 高于 详尽的文档<br />
客户合作 高于 合同谈判<br />
相应变化 高于 遵循计划</p>
<p>在短时间内交付组稿价值的</p>
<p>Scrum框架  3 3 5 5<br />
###3个角色<br />
####PO(Product owner)产品经理</p>
<ul>
<li>一个人</li>
<li>产品决策</li>
<li>驱动产品走向成功</li>
<li>客户与团队的桥梁(双向的代表)</li>
<li>建立意愿</li>
<li>负责&quot;做什么&quot;</li>
<li>对Product Backlog 排优先级   (故事来表达条目,如果有其他的也可以)</li>
<li>决定发布日期</li>
<li>接受和退回工作成果</li>
</ul>
<p>####开发团队  --&gt; 规模 = 7+-2<br />
能力:职能全(编码/测试),团队做一个项目<br />
职责:产品增量(完整的可以上线的产品)<br />
持续自我改进:所有成员都要有</p>
<p>####SM(Sturm Master)</p>
<ul>
<li>管理层与团队的桥梁(双向代表)</li>
<li>帮助团队做决定,自己不做决定</li>
<li>团队内部教练</li>
<li>开放并善于聆听</li>
<li>营造和推进Scrum价值观</li>
<li>帮助团队移除障碍</li>
<li>为PO和团队服务</li>
<li>培养和保护团队  保护团队不受打扰</li>
<li>提升管队效率</li>
</ul>
<p>###3个工件(过程成果和交付物)</p>
<h4><a id="product-backlog" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Product Backlog</h4>
<ul>
<li>动态列表,包含产品功能(用户故事:)</li>
<li>其他能给用户带来的价值的工作(技术故事:一般由主设计由产品经理确认)</li>
<li>好的Product Backlog <strong>详细,规模估算,涌现式,优先级(绝对序号排序,不要用高中低)</strong></li>
<li>PO维护</li>
</ul>
<p>####Sprint backlog</p>
<ul>
<li>
<p>基于product backlog 拆分成更小的任务.关注与怎么做的问题</p>
</li>
<li>
<p>开发团队负责创建与维护</p>
<p><em>1</em> 选取要进行的Product backlog Item<br />
<em>2</em> 协作完成<br />
<em>3</em> 通过scrum任务版让团队自我管理Sprint Backlog<br />
<em>4</em> 通过燃尽图跟踪sprint进展情况并预测和管理开发的进展<br />
####Sprint产品增量</p>
</li>
<li>
<p>项目有一些列 sprint 组成</p>
</li>
<li>
<p>通常2-4周</p>
</li>
<li>
<p>固定周期    --&gt; 让开发团队适应节奏</p>
</li>
<li>
<p>时间盒结束sprint结束</p>
</li>
<li>
<p>计划会定义的工作要在sprint内全部完成</p>
</li>
</ul>
<p>###5个活动<br />
####Sprint计划会</p>
<ul>
<li>第一部分:定义目标,选择可以承诺完成的任务(例如:主流程能跑通)</li>
<li>第二部分:决定如何实现目标,创建Sprint backlog估算(故事清单,按清单做)<br />
####Daily Scrum 每日站立会</li>
<li>每日</li>
<li>相同时间地点</li>
<li>15分钟</li>
<li>站立 时间端,累 注意力集中</li>
<li>团队,+SM,PO</li>
</ul>
<p>####迭代评审会</p>
<ul>
<li>展示工作成果,获得客户反馈</li>
<li>PO接受或者回退工作</li>
<li>团队成员全部参家</li>
<li>邀请相关干系人</li>
</ul>
<p>####迭代回顾会</p>
<ul>
<li>团队开发过程会持续改进</li>
<li>最长3小时</li>
<li>全员参加,领导可以不参加</li>
<li>敏捷教练或者SM带领大家回顾</li>
<li>形成明确的改进计划,并在下一个迭代会回顾会检视效果</li>
</ul>
<p>####把Scrum本身也做为一个活动</p>
<h3><a id="5%E4%B8%AA%E4%BB%B7%E5%80%BC%E8%A7%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5个价值观</h3>
<p>##scrum拆解</p>
<p>#案例<br />
##1.团队要敏捷,从哪里开始<br />
###准备阶段<br />
团队组件:PO,SM(敏捷教练),开发团队(开发和测试不要很明确)<br />
###项目启动会<br />
##2.git支管理办法</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402956566.html">转载iOS MJ讲解面试题,并修改里面错误</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>原文链接:<a href="http://www.jianshu.com/p/9050e523e278">http://www.jianshu.com/p/9050e523e278</a></p>
</blockquote>
<h4><a id="1%E3%80%81kvo%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、KVO内部实现原理</h4>
<ul>
<li>1.KVO是基于runtime机制实现的</li>
<li>2.当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法。<br />
派生类在被重写的setter方法实现真正的通知机制（Person-&gt;NSKVONotifying_Person）</li>
</ul>
<h4><a id="2%E3%80%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%BE%E5%9C%A8nsnotificationcenter%E4%B8%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、是否可以把比较耗时的操作放在NSNotificationCenter中</h4>
<ul>
<li>通知中心所做的操作在主线程，比较耗时的一般开启一个线程单独去跑</li>
</ul>
<h4><a id="3%E3%80%81kvo%E3%80%81nsnotification%E3%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E9%82%A3%E4%B8%AA%EF%BC%9F%E5%A6%82%E6%9E%9C%E7%94%A8protocol%E5%92%8Cdelegate%EF%BC%88%E6%88%96%E8%80%85delegate%E7%9A%84array%EF%BC%89%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%AF%E8%83%BD%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%83%BD%EF%BC%8C%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E6%BD%9C%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、KVO、NSNotification、代理的区别和用法是什么？什么时候该用那个？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果能，会有什么潜在的问题？如果不能，为什么？</h4>
<h5><a id="%E7%AD%94%E6%A1%88%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>答案：</h5>
<p>参考：<a href="http://blog.csdn.net/dqjyong/article/details/7685933">http://blog.csdn.net/dqjyong/article/details/7685933</a></p>
<h6><a id="%E9%80%9A%E7%9F%A5%EF%BC%88nsnotification%EF%BC%89%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通知（NSNotification）：</h6>
<ul>
<li>比较灵活（1个通知能被多个对象接受，多个对象能接受多个通知）</li>
<li>没有耦合性（Ａ发出的通知，谁去接收并不知道）</li>
<li>缺点通知的Key容易被写错</li>
</ul>
<h6><a id="kvo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>KVO</h6>
<ul>
<li>性能不好（底层对会Runtime动态产成新的类NSNotifying_xx）</li>
<li>局限性（只能监听某个对象属性的改变，不推荐实用）</li>
<li>1个对象的属性能被多个对象监听，1个对象能监听多个对象的其他属性</li>
</ul>
<h6><a id="%E4%BB%A3%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代理</h6>
<ul>
<li>比较规范，所以安全性高</li>
<li>默认是1对1监听，可以用代理数组 a.delegates = @[b, c, d];(千万别这样写，违背的设计模式，这样写还不如同消息通知)</li>
</ul>
<h4><a id="4%E3%80%81runtime%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%B9%B2%E5%98%9B%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%AE%B0%E5%BE%97%E4%BD%A0%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E6%9F%90%E4%BA%9B%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、Runtime实现的机制是什么，怎么用，一般用于干嘛，你还记得你所使用的相关的头文件或者某些方法的名称吗？</h4>
<p>运行时机制，runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量，动态改变类的方法实现，为类动态添加新的方法等，需要导入</p>
<h5><a id="1%E4%BB%80%E4%B9%88%E6%98%AF-runtime" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.什么是Runtime</h5>
<ul>
<li>runtime是一套比较低层的纯C语言API，属于1个C语言库，包含许多C底层的C语言的API</li>
<li>平时编写的OC代码，在程序 运行过程中，其实最终都转换成了runtime的C语言代码，runtime算是OC的幕后工作者<br />
举例：<br />
OC:<br />
<code> [MJPerson alloc]init];</code><br />
runtime：<br />
<code> objc_msgSend(objc_msgSend(&quot;MJPerson&quot;, &quot;alloc&quot;), &quot;init&quot;)</code></li>
</ul>
<h5><a id="2%E7%94%A8%E8%BF%87%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.用过么？怎么用？</h5>
<ul>
<li>1.runtime是属于OC底层，可以进行 一些非常的操作（OC无法实现的，不容易实现的）
<ul>
<li>在程序运行过程中，动态创建一个类（比如KVO底层实现）</li>
<li>在程序运行过程中，动态地为某个类 添加属性、方法，修改属性值、方法</li>
<li>便利一个类的 所以成员变量（属性）、方法</li>
</ul>
</li>
</ul>
<h5><a id="3%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.相关应用</h5>
<ul>
<li>
<p>1.头文件</p>
<p>调用底层的消息发送方法</p>
</li>
<li>
<p>2.相关应用</p>
<ul>
<li>NSCoding（归档和解档，利用runtime遍历模型对象的所有属性）</li>
<li>字典 -&gt;模型 （利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上）</li>
<li>KVO（利用runtime动态产生一个类）</li>
<li>用于封装框架（想怎么改，就怎么改）</li>
</ul>
</li>
<li>
<p>3.相关函数</p>
<ul>
<li>objc_msgSend ： 给对象发送消息</li>
<li>class_copyMethodList ： 遍历某个所有方法</li>
<li>class_copyIvarList ： 遍历某个类所以的成员变量</li>
<li>class_addMethod ： 动态添加方法</li>
<li>class_addIval ：动态添加成员变量</li>
<li>class_.... class_开头的方法,是操作类的</li>
</ul>
</li>
</ul>
<h6><a id="%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8runtime%E5%BD%92%E6%A1%A3%E5%92%8C%E8%A7%A3%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>例：利用Runtime归档和解档</h6>
<pre><code class="language-plain_text">//  MJPerson.m
//  runtime进行归档和解档
//
//  Created by Zhanbo on 16/7/7.
//  Copyright © 2016年 Zhanbo. All rights reserved.
//

#import &quot;MJPerson.h&quot;
#import &lt;objc/runtime.h&gt;
@implementation MJPerson

- (void)encodeWithCoder:(NSCoder *)aCoder {

   unsigned int count = 0;
  //参数1：那个类
  //参数2：有几个成员变量
   Ivar *ivars = class_copyIvarList([MJPerson class], &amp;count);

    for (int i = 0; i &lt;count; i++) {
        //取出i位置对应的成员变量
        Ivar ivar = ivars[i];

        //查看成员变量
        const char *name = ivar_getName(ivar);
        NSLog(@&quot;%s&quot;, name);

        //归档
        NSString *key = [NSString stringWithUTF8String:name];
        id value = [self valueForKey:key];
        [aCoder encodeObject:value forKey:key];

    }
    //在C语言中使用copy要释放
    free(ivars);
}

- (instancetype)initWithCoder:(NSCoder *)aDecoder {

    if (self = [super init]) {

        unsigned int count = 0;
        Ivar *ivars = class_copyIvarList([MJPerson class], &amp;count);

        for (int i = 0; i &lt;count; i++) {
            //取出i位置对应的成员变量
            Ivar ivar = ivars[i];

            //查看成员变量
            const char *name = ivar_getName(ivar);
            NSLog(@&quot;%s&quot;, name);

            //解档
            NSString *key = [NSString stringWithUTF8String:name];
            id value = [aDecoder decodeObjectForKey:key];

            //设置到成员变量身上
            [self setValue:value forKey:key];

        }
        //在C语言中使用copy要释放
        free(ivars);
    }
    return self;
}

@end
</code></pre>
<h5><a id="4%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.必备常识</h5>
<ul>
<li>1.Ivar ： 成员变量</li>
<li>
<ol>
<li>Method ： 成员方法</li>
</ol>
</li>
</ul>
<h4><a id="5%E3%80%81foundation%E5%AF%B9%E8%B1%A1%E4%B8%8Ecore-foundation%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5、Foundation对象与Core Foundation对象有什么区别？</h4>
<ul>
<li>
<p>1.Foundation对象是OC的，Core Foundation对象是C对象</p>
</li>
<li>
<p>2.数据类型之间的转换(桥接)</p>
<ul>
<li>
<p>ARC：bridge_retained、 _bridge_transfer</p>
<pre><code class="language-plain_text">CFArrayRef array3 = CFArrayCreate(NULL, NULL, 10, NULL);

//Foundetion -&gt; Core Fountdation
(__bridge_retained )

//Core Fountdation -&gt; Foundetion
(__bridge_transfer )
NSArray *array4 = (__bridge_transfer NSArray *)array3);
</code></pre>
</li>
<li>
<p>MRC: _bridge</p>
<pre><code class="language-plain_text">Foundation -&gt; Core Foundation
NSArray *array1 = [NSArray array];
CFArrayRef array2 = (__bridge CFArrayRef)array1;
//记得释放内存
[array1 release];
</code></pre>
</li>
</ul>
</li>
</ul>
<h4><a id="6%E3%80%81%E4%B8%8D%E7%94%A8%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%EF%BC%8C%E7%94%A8%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2a%E5%92%8Cb%E7%9A%84%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6、不用中间变量，用两种方法交换A和B的值</h4>
<ul>
<li>
<ol>
<li>A = A + B<br />
B = A - B<br />
A = A- B</li>
</ol>
</li>
<li>2.使用位运算^能交换两个变量的值</li>
</ul>
<h4><a id="7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%EF%BC%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7、 什么是动态，举例说名</h4>
<ul>
<li>1.在线程运行过程才执行的操作，如Runtime动态创建成员变量和方法</li>
</ul>
<h4><a id="8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8、什么是多态</h4>
<ul>
<li>
<p>1.父类指针指向子类对象</p>
<pre><code class="language-plain_text">NSObject *obj = [NSArray array];
</code></pre>
</li>
</ul>
<h4><a id="9%E3%80%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E6%B1%A0%E6%BB%A1%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88cell%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>9、怎么解决缓存池满的问题（cell）</h4>
<ul>
<li>iOS中不存在缓存池满的情况，应为通常我们在iOS开发，对象都是在需要的时候才会创建，有种常用的说法叫懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会创建新对象，缓存池里最多就一两个对象，缓存池满的这中情况一般在开发Java中比较常见，Java中一般把最近最少使用的对象先释放</li>
<li>如果缓存池满了，判断哪个位置的cell是不经常使用的，先释放掉</li>
</ul>
<h3><a id="10%E3%80%81%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84uilabel" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>10、如何渲染自定义格式字符串的UILabel</h3>
<ul>
<li>
<p>1.通过NSAttributedString类</p>
<pre><code class="language-plain_text">  //1种写法，也可以用字典
NSMutableAttributedString *str = [[NSMutableAttributedString alloc]initWithString:@&quot;哈哈哈啦啦啦哇哇哇&quot;];
  //设置文字颜色
  [str addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 3)];
  [str addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(6, 3)];
  //设置字体
  [str addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(3, 3)];

  _label.attributedText = str;
</code></pre>
</li>
</ul>
<p><img src="media/16587402956566/1240." alt="" /></p>
<p>效果</p>
<h4><a id="11%E3%80%81scrollview%E7%9A%84contentsize%E8%83%BD%E5%9C%A8viewdidload%E9%87%8C%E8%AE%BE%E7%BD%AE%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>11、scrollView的contentSize能在ViewDidLoad里设置吗，为什么？</h4>
<ul>
<li>1.能，在哪里都能设置</li>
<li>2.但是最好不要在viewDidLoad里设置，因为视图刚创建不一定是我们想要的尺寸，在iPad开发中横竖屏是很好的例子</li>
</ul>
<h4><a id="12%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8view%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>12、控制器View的生命周期及相关函数什么？你在开发中是如何用的？</h4>
<ul>
<li>1.首先判断控制器是否有视图，如果没有就调用<strong>loadView</strong>方法创建：通过storyboard或者代码</li>
<li>2.随后调用<strong>viewDidLoad</strong>，可以进行下一步的初始化操作：只会被调用一次</li>
<li>3.在视图显示之前（即将显示）调用<strong>viewWillAppear</strong>，该函数可以多次调用</li>
<li>4.在视图显示，会调用<strong>viewDidAppear</strong></li>
<li>5.视图即将消失，调用<strong>viewWillDisappear</strong></li>
<li>6.视图已经消失，调用<strong>viewDidDisappear</strong></li>
<li>7.在布局变化前后，调用<strong>viewWillDidLayoutSubviews</strong>处理相关信息</li>
</ul>
<h4><a id="13%E3%80%81block%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>13、Block的内存管理</h4>
<ul>
<li>1.默认情况下，block的内存是在栈中
<ul>
<li>它不会对所引用的对象进行任何操作</li>
</ul>
</li>
<li>2.如果对block做一次copy操作，block的内存就会在堆中
<ul>
<li>它会对所引用的对象做一次retain操作</li>
<li>ARC ：如果所引用的对象用了**__unsafe_unretained<strong>或者</strong>__weak**修饰，就不会做retain操作</li>
<li>非ARC(MRC) ： 如果所引用的对象用**__block**修饰，就不会做retain操作；MRC记得释放blockBlock_release(_block);</li>
</ul>
</li>
</ul>
<pre><code class="language-plain_text">- (void)dealloc {
    //MRC记得在dealloc释放blcok，[super dealloc];要写最后
    Block_release(_block);
    [super dealloc];
}
</code></pre>
<h4><a id="14%E3%80%81mrc%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%BC%80%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>14、MRC中如何做开发</h4>
<p>1.MRC中retain相当于ARC中strong<br />
assign相当于ARC中weak<br />
2.只要声明对象属性就要写retain</p>
<pre><code class="language-plain_text">@property (nonatomic, retain)NSArray *array; +1(计数器 = 1)
</code></pre>
<p>3.声明控件、协议用assgin</p>
<p>4.MRC的内存管理原则</p>
<ul>
<li>如果调用了alloc、new、copy产生了一个新对象，最后肯定要调用1次releace或者autorelease</li>
<li>如果让一个对象做了retain操作（计数器+1），最后肯定要调用1次release或者autorelease</li>
<li>原则：有+ 就有-</li>
</ul>
<pre><code class="language-plain_text">self.array = [NSArray alloc]init]autorelease];
alloc后 +1(计数器 = 2)； autorelease后 -1(计数器 = 1)
//或者这样写，就不需要写autorelease，系统内部自动写好
self.array = [NSArray array];
</code></pre>
<ul>
<li>最后要在dealloc释放内存</li>
</ul>
<pre><code class="language-plain_text">//当控制器将被释放的时候对调用
- (void)dealloc {
//最好这样写
self.array = nil;
-1(计数器 = 0)

//也可以这样写
self.array = [array release];
//最后调用
[supe dealloc];
}
</code></pre>
<p>如果是iOS版本在5.0之前要在3个地方释放内存</p>
<pre><code class="language-plain_text">//控制器的View被卸载，会调用
- (void)viewDidUnload {

    [super viewDidUnload];
    self.array = nil;
}

//接收到内存警告，会调用
- (void)didReceiveMemoryWarning {

    [super didReceiveMemoryWarning];
    self.array = nil;
}

- (void)dealloc {

    self.array = nil;

    [super dealloc];
}
</code></pre>
<h4><a id="15%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BA%BF%E4%B9%8B%E9%97%B4%E9%80%9A%E8%AE%AF%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>15、多线程如何进行线之间通讯？</h4>
<pre><code class="language-plain_text">//在主线程执行某个方法，传参（该方法用于子线程对主线程进行通讯）
[self performSelectorOnMainThread: withObject: waitUntilDone:]

//指定线程，调用方法，传参
[self performSelector: onThread: withObject: waitUntilDone: modes: *)#&gt;

//GCD在异步线程做事情
dispatch_async(, )
</code></pre>
<h4><a id="16%E3%80%81%E7%94%A8nsoperation%E5%92%8Cnsoperationqueue%E5%A4%84%E7%90%86a-b-c%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%A6%81%E6%B1%82%E6%89%A7%E8%A1%8C%E5%AE%8Ca-b%E6%89%8D%E8%83%BD%E6%89%A7%E8%A1%8Cc%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>16、用NSOperation和NSOperationQueue处理A,B,C三个线程，要求执行完A,B才能执行C，怎么做？</h4>
<ul>
<li>1.第一种方法添加依赖</li>
</ul>
<pre><code class="language-plain_text">//创建列队
NSOperationQueue *queue = [NSOperationQueue alloc]init];
//创建3个操作
NSOperation *a = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation1....&quot;);
}];

NSOperation *c = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation2....&quot;);
}];

NSOperation *b = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;operation3....&quot;);
}];
//======添加依赖=======
//只有当a操作执行完毕后，才会执行c操作
[c addDependency:a];
//只有当b操作执行完毕后，才会执行c操作
[c addDependency:b];

[queue addOperation:a];
[queue addOperation:b];
[queue addOperation:c];
</code></pre>
<ul>
<li>2.第二种方法 可 以设置优先级</li>
</ul>
<pre><code class="language-plain_text">- (NSOperationQueuePriority)queuePriority;
</code></pre>
<h4><a id="17%E3%80%81gcd%E5%86%85%E9%83%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>17、GCD内部怎么实现的</h4>
<ul>
<li>1.iSO和OS X的核心是XNU内核，GCD是基于XNU内核实现的</li>
<li>2.GCD的API全部在libdispatch库中</li>
<li>3.GCD的底层实现主要有Dispatch Queue和 Dispatch Source
<ul>
<li>Disatch Queue ：管理block（操作，block里的代码块，根据类型在哪个线程执行）</li>
<li>Disatch Source ： 处理事件（底层实现，处理线程之间的事件，如主线程会到什么线程，异步线程回到什么线程）</li>
</ul>
</li>
</ul>
<h4><a id="18%E3%80%81nsoperatinqueue%E5%92%8Ccgd%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8nsoperationqueue%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8gcd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>18、NSOperatinQueue和CGD的区别，什么情况下用NSOperationQueue，什么情况下用GCD</h4>
<ul>
<li>1.GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本封装</li>
<li>2.GCD只支持FIFO的列队（先进先出），NSOperationQueue可以很方便地调整执行顺序（设置优先级 ），设置最大并发数量</li>
<li>3.NSOperatinQueue可以轻松在Operation间设置依赖关系，而GCD需要些很多代码才能实现</li>
<li>4.NSOperationQueue支持KVO，可以监听operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）；系统内部已经做好的KVO</li>
<li>5.GCD的执行速度比NSOperationQueue快</li>
<li>什么时候，用哪个
<ul>
<li>1.任务之间有依赖/或者要监听任务的执行情况：NSOperatinQueue（任务需要时刻监听；任务严格需要按顺序执行）</li>
<li>2.任务之间不太相互依赖就用：CGD</li>
</ul>
</li>
</ul>
<h4><a id="19%E3%80%81%E6%97%A2%E7%84%B6%E8%AF%B4%E5%88%B0gcd%EF%BC%8C%E9%82%A3%E4%B9%88%E9%97%AE%E4%B8%8B%E5%9C%A8%E4%BD%BF%E7%94%A8gcd%E5%B7%B2%E7%BB%8Fblock%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>19、既然说到GCD，那么问下在使用GCD已经block需要注意什么？</h4>
<ul>
<li>1.GCD的注意18题已有说明</li>
<li>2.Block的使用注意
<ul>
<li>1.block的内存管理(13题已有说明)</li>
<li>2.防止循环retain
<ul>
<li>ARC：**weak/**unsafe_unretained</li>
<li>MRC: __block 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><a id="20%E3%80%81%E5%A6%82%E6%9E%9C%E5%90%8E%E6%9C%9F%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%BD%BF%E7%94%A8coredata%E5%91%A2%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>20、如果后期需要增加数据库中的字段怎么实现，如果不使用CoreData呢？</h4>
<p>编写SQL语句来操作原来表中的字段</p>
<ul>
<li>1.增加表字段<br />
ALTER TABLE 表名 DROP COLUMN 字段名 字段类型</li>
<li>2.删除表字段<br />
ALTER TABLE 表名 DROP COLUMN 字段名</li>
<li>3.修改表字段<br />
ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名</li>
</ul>
<h4><a id="21%E3%80%81%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>21、简单描述下客户端的缓存机制</h4>
<ul>
<li>1.缓存可以分为：内存数据缓存、数据库缓存、文件缓存</li>
<li>2.每次想获取数据的时候
<ul>
<li>先检测内存中有无缓存</li>
<li>在检测本地有无缓存（数据库/文件）</li>
<li>最终发送网络请求</li>
<li>将服务器返回的网络数据进行缓存（内存、数据库、文件），已便下次读取</li>
</ul>
</li>
</ul>
<h4><a id="22%E3%80%81%E6%9C%89%E4%BA%9B%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%AF%94%E8%BE%83%E6%85%A2%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>22、有些图片加载的比较慢怎么处理？你是怎么优化程序的性能的？</h4>
<ul>
<li>1.图片下载放在异步线程</li>
<li>2.图片下载过程中使用占位图，提高用户的天</li>
<li>3.如果图片比较大，可以考虑多线程断点下载（开辟多个线程下载一张图片，需要服务器设置请求体信息）</li>
</ul>
<h4><a id="23%E3%80%81%E4%BD%A0%E5%AE%9E%E7%8E%B0%E8%BF%87%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6%E6%88%96%E8%80%85%E5%BA%93%E4%BB%A5%E4%BE%9B%E5%88%AB%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E8%AF%B7%E8%B0%88%E4%B8%80%E8%B0%88%E6%9E%84%E5%BB%BA%E6%A1%86%E6%9E%B6%E6%88%96%E8%80%85%E5%BA%93%E6%97%B6%E5%80%99%E7%9A%84%E7%BB%8F%E9%AA%8C%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%EF%BC%8C%E8%AF%B7%E8%AE%BE%E6%83%B3%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E7%9A%84public%E7%9A%84api%EF%BC%8C%E5%B9%B6%E6%8C%87%E5%87%BA%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E5%A6%82%E4%BD%95%E5%81%9A%E3%80%81%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%80%E4%BA%9B%E4%BB%80%E4%B9%88%E6%96%B9%E9%9D%A2%EF%BC%8C%E6%9D%A5%E4%BD%BF%E5%88%AB%E4%BA%BA%E5%AE%B9%E6%98%93%E5%9C%B0%E4%BD%BF%E7%94%A8%E4%BD%A0%E7%9A%84%E6%A1%86%E6%9E%B6%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>23、你实现过一个框架或者库以供别人使用吗？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。</h4>
<ul>
<li>1.提供给外界的接口功能是否实用、够用</li>
<li>2.别人使用我的框架时，能不能根据类名、方法名就猜出接口的具体作用</li>
<li>3.别人调用接口时，提供的参数是否够用、调用起来是否简单</li>
<li>4.别人使用我的框架时，要不要再导入依赖其他的框架</li>
</ul>
<h4><a id="24%E3%80%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%BE%E5%9C%A8nsnotificationcenter%E4%B8%AD%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>24、是否可以把比较耗时的操作放在NSNotificationCenter中？</h4>
<ul>
<li>1.如果在异步线程发的通知，那么可以执行比较耗时的操作</li>
<li>2.如果在主线程发的通知，那么就不可以执行比较耗时的操作<br />
补充：NSNotificationCenter默认是主线程的，但是在异步线程发通知，那么NSNotificationCenter就会变成异步线程</li>
</ul>
<h4><a id="25%E3%80%81sdwebimage%E5%85%B7%E4%BD%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>25、SDWebImage具体如何实现</h4>
<ul>
<li>1.利用NSOperationQueue和NSOperation下载图片，还使用了GCD的一些函数（解码GIF图片）</li>
<li>2.利用URL作为key，NSOperation作为value</li>
<li>3.利用URL作为key，UIImage作为value</li>
</ul>
<h4><a id="26%E3%80%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3sqlite%E9%94%81%E5%AE%9A%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>26、怎么解决sqlite锁定的问题</h4>
<ul>
<li>1.设置数据库锁定的处理函数</li>
</ul>
<pre><code class="language-plain_text">当数据库被锁时，会调用该方法
//参数1传入数据库，
//参数2传入函数名(在该函数中做操作)
int sqlite3_busy_handler(sqlite3*, test);
</code></pre>
<ul>
<li>
<p>2.设置锁定时的等待时间</p>
<pre><code class="language-plain_text">int sqlite3_busy_timeout(sqlite3*, int ms);
</code></pre>
</li>
</ul>
<h4><a id="27%E3%80%81cocoa%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%AF%B9%E5%87%A0%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%B9%B6%E8%B0%88%E8%B0%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>27、cocoa中常见对几种多线程的实现，并谈谈多线程安全的几种解决办法及多线程安全怎么控制？</h4>
<ul>
<li>1.只在主线程刷新访问UI</li>
<li>2.如果要防止资源抢夺，得用synchroized进行加锁保护</li>
<li>3.如果异步操作要保证线程安全等问题，尽量使用GCD（有些函数默认就是安全的）</li>
</ul>
<h4><a id="28%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFrun-loop%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>28、什么是run loop？</h4>
<ul>
<li>1.runloop是消息循环，内部有定时源和输入源来运作</li>
<li>2.在创建的程序不需要显示的创建run loop；每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象，主线程会自行创建并运行run loop</li>
<li>3.run loop处理的输入事件有两种不同的来源：输入源（input source）和定时源（timer source）</li>
<li>4.输入源处理传递异步消息，通常来自于其他线程或者程序。定时源则处理传递同步消息，在特定时间或者一定的时间间隔发生</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402956754.html">Swift - 使用代理和闭包传值</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##代理传值</p>
<p>声明协议:</p>
<pre><code class="language-plain_text">protocol FunctionButtonViewDelegate {
    func gotoViewController(vcString:String)
}
</code></pre>
<pre><code class="language-plain_text">var delegate :FunctionButtonViewDelegate?
</code></pre>
<p>这里<code>?</code>就具有<code>weak</code>的作用</p>
<p>传值:</p>
<pre><code class="language-plain_text">delegate?.gotoViewController(vcString: button.currentTitle!)
</code></pre>
<p>实现代理方法</p>
<pre><code class="language-plain_text">extension PersonalCenterViewController:FunctionButtonViewDelegate {
    //MARK: - 跳转到对应的功能模块
    func gotoViewController(vcString: String) {
        print(vcString)
    }
}
</code></pre>
<p>##闭包传值</p>
<p>声明:</p>
<pre><code class="language-plain_text">var callback : ((Int?) -&gt; Void)?
</code></pre>
<p>传值</p>
<pre><code class="language-plain_text">if let cb = callback {
    cb(200)
}
</code></pre>
<p>实现:</p>
<pre><code class="language-plain_text">bottomView.callback = { (num)-&gt;Void in
    print(num ?? 0)
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402956933.html">转发机制</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>基本逻辑来源自官方文档 <a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html">Message Forwarding</a> ,这里只做相关例子的解析.</p>
</blockquote>
<p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以 [object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运 行时才能确定object是否能接收message消息。如果不能，则程序崩溃。<br />
通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：</p>
<pre><code class="language-plain_text">if ([self respondsToSelector:@selector(method)]) {
    [self performSelector:@selector(method)];
}
</code></pre>
<p>当不使用<code>respondsToSelector:</code>判断时,就会启动'消息转发(message forwarding)'机制,通过这一机制我们可以告诉对象如何处理未知的消息.如果不做任何处理会导致程序崩溃,我们可以看到异常信息如下:</p>
<pre><code class="language-plain_text">2016-09-08 13:26:53.094 selfsuper[65176:7154658] -[Student eat]: unrecognized selector sent to instance 0x7ff1b9f9f690
2016-09-08 13:26:53.103 selfsuper[65176:7154658] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Student eat]: unrecognized selector sent to instance 0x7ff1b9f9f690'
</code></pre>
<p>这段异常信息实际上是由NSObject的<code>doesNotRecognizeSelector</code>方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>
<p>动态方法解析</p>
</li>
<li>
<p>备用接收者</p>
</li>
<li>
<p>完整转发</p>
</li>
</ol>
<p>##动态方法解析<br />
对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或 者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经 实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。如下代码所示：</p>
<pre><code class="language-plain_text">// void(*)()
// 默认方法都有两个隐式参数，
void eat(id self,SEL sel)
{
    NSLog(@&quot;%@ %@&quot;,self,NSStringFromSelector(sel));
}

// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.
// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    if (sel == NSSelectorFromString(@&quot;eat&quot;)) {
        // 动态添加eat方法
        
        // 第一个参数：给哪个类添加方法
        // 第二个参数：添加方法的方法编号
        // 第三个参数：添加方法的函数实现（函数地址）
        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd
        class_addMethod(self, NSSelectorFromString(@&quot;eat&quot;), (IMP)eat, &quot;v@:&quot;);
        
    }
    
    return [super resolveInstanceMethod:sel];
}

</code></pre>
<p>不过这种方案更多的是为了实现@dynamic属性。</p>
<p>##备用接收者<br />
如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<pre><code class="language-plain_text">- (id)forwardingTargetForSelector:(SEL)aSelector
</code></pre>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>
<pre><code class="language-plain_text">/**
 * 测试消息转发
 */
-(id)forwardingTargetForSelector:(SEL)aSelector {
    NSLog(@&quot;消息转发&quot;);
    NSString *selectorString = NSStringFromSelector(aSelector);
    if ([selectorString isEqualToString:@&quot;eat2&quot;]){
        // 将消息转给 RuntimeHelper 对象,让他来处理
        return [RuntimeHelper new];
    }
    return [super forwardingTargetForSelector:aSelector];
}

</code></pre>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。如果需要修改参数和返回值,可以使用完整消息转发.</p>
<p>##完整消息转发<br />
如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法:</p>
<pre><code class="language-plain_text">- (void)forwardInvocation:(NSInvocation *)anInvocation
</code></pre>
<p>完整代码:</p>
<pre><code class="language-plain_text">/**
 *  完整的消息转发
 */

/* 必须重写 (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
 * 消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。
 */
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];
    
    if (!signature) {
        if ([RuntimeHelper instancesRespondToSelector:aSelector]) {
            signature = [RuntimeHelper instanceMethodSignatureForSelector:aSelector];
        }
    }
    
    return signature;
}

-(void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([RuntimeHelper instanceMethodSignatureForSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:[RuntimeHelper new]];
    }
}
</code></pre>
<p>关于 NSInvocation 可以参见<a href="https://github.com/Mekor/MKExtension">MKExtension</a>中<code>NSObject+SEL</code>,里面有关于 NSInvocation 的应用.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402957111.html">企业证书需要</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>邓白氏码  不清楚公司是否申请过,如果没有申请过可能需要半个月左右时间(最快1周)</li>
<li>申请企业证书, 现在苹果对国内企业证书申请比较严格最快1周可能需要半个月甚至更久(美国快过圣诞节和元旦了)</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402957294.html">方便实用的小组件</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1-fittedbox" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. FittedBox</h2>
<pre><code class="language-plain_text">这个组件可以缩放子组件，组件的大小不够的时候可以缩放子组件。比如：

```dart
Container(
	color: Colors.red,
	width:double.infinity,
	child:FittedBox(
		fit: BoxFit.sacleDown, // 小于等于当前的控件大小. 也就是字体小于等于20
		child:Text(&quot;You have pushed the button this many times&quot;, style: TextStyle(fontSize:20),),	
	),	
),
```

当Container组件所在的宽度不够文本宽度的时候，就会缩小文本的字体大小。
</code></pre>
<h2><a id="2-safearea" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. SafeArea</h2>
<pre><code class="language-plain_text">和iOS中的SafeArea一样，为了异形屏显示而做的适配工作。

```dart
// 除了 top/bottom/left/right 等参数可以设置外，还有一个好用的参数 minimum。这个参数可以设置最小padding，也就是满足安全区域的时候使用安全区域，没有安全区域的时候使用minimum。
```

注意： 使用的时候不要把Safe Area 放在顶层，哪里需要放在哪里就好了，有些组件就是需要延伸到安全区域才美观的。
</code></pre>
<h2><a id="3-layoutbuilder" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. LayoutBuilder</h2>
<pre><code class="language-plain_text">约束组件，会把constraint传递给子组件。

```dart
...
LayoutBuilder(
	builder: (BuildContext context, BoxConstraints constranits) {
		print(constraints);
		return SizedBox(
			height: constraints.maxHeight / 2,
			child: Text(&quot;xxxxxxxx&quot; * 500),
		);
	}
),
```

上述代码实现了文本组件是父组件一半的高度。当然也可以使用Culum之类的组件通过Expend做到类似的效果。

首页中可以使用LayoutBuilder计算剩余的空间，而不用使用MediaQuery.of(content).size 来自己就散各个组件的高度。
</code></pre>
<h2><a id="4-defaulttextstyle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. DefaultTextStyle</h2>
<pre><code class="language-plain_text">默认的文本样式，这样子组件就能使用外层的默认样式了。

```dart
...
DefaultTextStyle(
	style: TextStyle(color: Colors.red),// 子组件如果没有设置颜色的话就会使用改处设置的颜色。
	child: Center(
		child: Column(
			mainAxisAlignment: MainAxisAlignment.center,
			children:&lt;Widget&gt;[Text(&quot;hhhh&quot;),Text(&quot;字体大小更改&quot;,style: TextStyle(fontSize:48)),Text(&quot;颜色使用自己的&quot;,style: TextStyle(color: Colors.black))],
		),	
	),
),
```

当然我们使用的过程中如果需要使用上层组件的样式可以这样。DefaultTextStyle.merge 这样默认样式就会和上层的样式merge。比如Scaffold中也会有默认样式（Material中会有默认样式），我们只是想要更改颜色就可以这样写：

```dart
return Scaffold(
	...
	body: DefaultTextStyle.merge(
		style: TextStyle(color: Colors.red),// 这样就会设置默认的颜色为红色，其他的样式使用上层的样式。
	),
);
```

隐式动画

AnimatedDefaultTextStyle
</code></pre>
<h2><a id="5-interactiveviewer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. InteractiveViewer</h2>
<pre><code class="language-plain_text">如果子组件超出屏幕范围可以任意方向滚动

```dart
...
InteractiveViewer(
	constrained: false,// 表示不去约束子组件
	child: SizeBox(
		width: 800, // 超出屏幕宽度，这样能狗左右滑动
		maxScale:5, // 最大缩放5倍
		minScale:0.2,// 最小缩放0.2倍

		child: Column(
			mainAxisAlignment: MainAxisAlignment.center,
			children:&lt;Widget&gt;[Text(&quot;hello world&quot; * 200),],
		),
	),

),
```

SingleChildScrollView 是一个维度的滚动，InteractiveViewer是二维滚动。
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402957663.html">Linux - 文件和目录</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E7%B1%BBunix%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类Unix系统目录结构</h2>
<p>ubuntu没有盘符这个概念，只有一个根目录/，所有文件都在它下面</p>
<p><img src="media/16587402957663/14954378312055.jpg" alt="" /></p>
<h2><a id="linux%E7%9B%AE%E5%BD%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linux 目录</h2>
<ul>
<li>/：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。</li>
<li>/bin: /usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</li>
<li>/boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。</li>
<li>/dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。</li>
<li>/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</li>
<li>/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。</li>
<li>/lib: /usr/lib: /usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</li>
<li>/lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li>/mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</li>
<li>/opt：给主机额外安装软件所摆放的目录。</li>
<li>/proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。</li>
<li>/root：系统管理员root的家目录。</li>
<li>/sbin: /usr/sbin: /usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用。</li>
<li>/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</li>
<li>/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。</li>
<li>/usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。</li>
<li>/var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。</li>
</ul>
<h2><a id="%E7%94%A8%E6%88%B7%E7%9B%AE%E5%BD%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户目录</h2>
<p>位于/home/user，称之为用户工作目录或家目录,表示方式：</p>
<pre><code class="language-plain_text">/home/user
~

</code></pre>
<h3><a id="%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相对路径和绝对路径</h3>
<h4><a id="%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>绝对路径</h4>
<p>从/目录开始描述的路径为绝对路径，如：</p>
<pre><code class="language-plain_text">cd /home
ls /usr

</code></pre>
<h4><a id="%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相对路径</h4>
<p>从当前位置开始描述的路径为相对路径，如：</p>
<pre><code class="language-plain_text">cd ../../
ls abc/def

</code></pre>
<h4><a id="%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>.和..</h4>
<p>每个目录下都有.和..</p>
<p>. 表示当前目录</p>
<p>.. 表示上一级目录，即父目录</p>
<p>根目录下的.和..都表示当前目录</p>
<h2><a id="%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件权限</h2>
<p>文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。</p>
<p>Unix/Linux系统是一个典型的多用户系统，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。</p>
<p>在 Unix/Linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。</p>
<h3><a id="%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>访问用户</h3>
<p>通过设定权限可以从以下三种访问方式限制访问权限：</p>
<ul>
<li>
<p>只允许用户自己访问（所有者） 所有者就是创建文件的用户，用户是所有用户所创建文件的所有者，用户可以允许所在的用户组能访问用户的文件。</p>
</li>
<li>
<p>允许一个预先指定的用户组中的用户访问（用户组） 用户都组合成用户组，例如，某一类或某一项目中的所有用户都能够被系统管理员归为一个用户组，一个用户能够授予所在用户组的其他成员的文件访问权限。</p>
</li>
<li>
<p>允许系统中的任何用户访问（其他用户） 用户也将自己的文件向系统内的所有用户开放，在这种情况下，系统内的所有用户都能够访问用户的目录或文件。在这种意义上，系统内的其他所有用户就是 other 用户类</p>
</li>
</ul>
<p>这有点类似于 QQ 空间的访问权限：<br />
<img src="media/16587402957663/14954384555256.jpg" alt="" /></p>
<ul>
<li>这个 QQ 空间是属于我的，我相当于管理者（也就是“所有者”），我想怎么访问就怎么访问。</li>
<li>同时，我可以设置允许 QQ 好友访问，而这些 QQ 好友则类似于“用户组”。</li>
<li>当然，我可以允许所有人访问，这里的所有人则类似于“其他用户”。</li>
</ul>
<h3><a id="%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>访问权限</h3>
<p>用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限：</p>
<ul>
<li>读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。</li>
<li>写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</li>
<li>可执行权限（x） 对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。</li>
</ul>
<p>注意：通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。</p>
<h3><a id="%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例说明</h3>
<p><img src="media/16587402957663/14954394260837.jpg" alt="" /><br />
(图中  用户改为 用户组)</p>
<p>第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后 9 个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。</p>
<p>每一个用户都有它自身的读、写和执行权限。</p>
<ul>
<li>第一组权限控制访问自己的文件权限，即所有者权限。</li>
<li>第二组权限控制用户组访问其中一个用户的文件的权限。</li>
<li>第三组权限控制其他所有用户访问一个用户的文件的权限。</li>
</ul>
<p>这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构成了一个有9种类型的权限组。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402957863.html">一 按照结构分类时，所有英文句子能够被分成三类</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402957863/IMG_0581134F049E-1.jpeg" alt="IMG_0581134F049E-1" /></p>
<h3><a id="%E4%BA%8C%E4%B8%BB%E8%B0%93%E5%AE%BE%E5%92%8C%E5%AE%83%E7%9A%84%E4%BA%94%E4%B8%AA%E5%85%84%E5%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二主谓宾和它的五个兄弟</h3>
<p><img src="media/16587402957863/IMG_B282F3324D1D-1.jpeg" alt="IMG_B282F3324D1D-1" /></p>
<p>及物动词与不及物动词有交集。上图需要修改<img src="media/16587402957863/IMG_0465B00EBF8B-1.jpeg" alt="IMG_0465B00EBF8B-1" /></p>
<h3><a id="%E4%B8%89%E4%BB%8E%E5%8F%A5%EF%BC%8C%E5%BC%95%E5%AF%BC%E8%AF%8D%E4%B8%BB%E8%B0%93%E5%AE%BE%EF%BC%88%E6%88%96%E5%85%B6%E4%BA%94%E4%B8%AA%E5%85%84%E5%BC%9F%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三 从句，引导词+主谓宾（或其五个兄弟）</h3>
<p><img src="media/16587402957863/IMG_58B1732546E8-1.jpeg" alt="IMG_58B1732546E8-1" /></p>
<p>that whether what</p>
<p>That he field the test shocked his parent</p>
<p><img src="media/16587402957863/IMG_A0FBE986BA34-1.jpeg" alt="IMG_A0FBE986BA34-1" /></p>
<p><img src="media/16587402957863/IMG_C3AA5C829BD0-1.jpeg" alt="IMG_C3AA5C829BD0-1" /></p>
<p>同位语从句永远都是that</p>
<p><img src="media/16587402957863/IMG_DA6777699741-1.jpeg" alt="IMG_DA6777699741-1" /><br />
<img src="media/16587402957863/IMG_3C7BCDC696C1-1.jpeg" alt="IMG_3C7BCDC696C1-1" /><br />
<img src="media/16587402957863/IMG_3603BAA2FDE9-1.jpeg" alt="IMG_3603BAA2FDE9-1" /><br />
<img src="media/16587402957863/IMG_E142F1161417-1.jpeg" alt="IMG_E142F1161417-1" /><br />
<img src="media/16587402957863/IMG_1BC5EE0D647F-1.jpeg" alt="IMG_1BC5EE0D647F-1" /><br />
<img src="media/16587402957863/IMG_8099C6D1037C-1.jpeg" alt="IMG_8099C6D1037C-1" /><br />
<img src="media/16587402957863/IMG_82FC1FC24EDF-1.jpeg" alt="IMG_82FC1FC24EDF-1" /><br />
<img src="media/16587402957863/IMG_0A619B7194C5-1.jpeg" alt="IMG_0A619B7194C5-1" /><br />
<img src="media/16587402957863/IMG_02A7B560DB2A-1.jpeg" alt="IMG_02A7B560DB2A-1" /></p>
<p>条件状语从句-&gt;主将从现</p>
<p><img src="media/16587402957863/IMG_0EE1F8ECD4C2-1.jpeg" alt="IMG_0EE1F8ECD4C2-1" /><img src="media/16587402957863/IMG_A2C0E4B86B09-1.jpeg" alt="IMG_A2C0E4B86B09-1" /></p>
<ul>
<li>特殊情况：he lost his job 一般过去时 没有影响现在。陈述了一个事实而已。如果说he has lost his job.他已经丢掉了工作，对现在造成了影响。</li>
</ul>
<p><img src="media/16587402957863/IMG_006B1BCB04CF-1.jpeg" alt="IMG_006B1BCB04CF-1" /><br />
<img src="media/16587402957863/IMG_CD5C1E472D39-1.jpeg" alt="IMG_CD5C1E472D39-1" /><br />
动词变形表</p>
<p>过去式和过去分词一样的有<br />
I checked my homework yesterday 过去式<br />
my homework is checked. 过去分词</p>
<p>不一样的有<br />
i drew a mouse yesterday<br />
a mouse is drawn on the paper</p>
<p><img src="media/16587402957863/IMG_3600471E2FE5-1.jpeg" alt="IMG_3600471E2FE5-1" /></p>
<p><a href="https://b23.tv/av47618740">https://b23.tv/av47618740</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402958112.html">setProperty 应用</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>项目中使用<code>Nacos</code>,想覆盖nacos的默认配置,配置信息如下:</p>
<pre><code class="language-plain_text">/**
 * @author cloud
 * @date 2019-10-31
 * &lt;p&gt;
 * 覆盖nacos 默认配置
 */
public interface ConfigConstants {
    /**
     * The System property name of  Standalone mode
     */
    String STANDALONE_MODE = &quot;nacos.standalone&quot;;

    /**
     * tomcat 目录
     */
    String TOMCAT_DIR = &quot;server.tomcat.basedir&quot;;

    /**
     * tomcat 日志配置
     */
    String TOMCAT_ACCESS_LOG = &quot;server.tomcat.accesslog.enabled&quot;;

    /**
     * 是否开启认证
     */
    String AUTH_ENABLED = &quot;nacos.core.auth.enabled&quot;;
}
</code></pre>
<p>在启动类中设置想要覆盖配置的值</p>
<pre><code class="language-plain_text">/**
 * @author nacos
 * &lt;p&gt;
 * nacos console 源码运行，方便开发
 * 生产建议从官网下载最新版配置运行
 */
@EnableScheduling
@SpringBootApplication
public class CloudNacosApplication {

	public static void main(String[] args) {
		System.setProperty(ConfigConstants.TOMCAT_DIR, &quot;logs&quot;);
		System.setProperty(ConfigConstants.TOMCAT_ACCESS_LOG, &quot;false&quot;);
        System.setProperty(ConfigConstants.STANDALONE_MODE, &quot;true&quot;);
        System.setProperty(ConfigConstants.AUTH_ENABLED, &quot;false&quot;);
		SpringApplication.run(CloudNacosApplication.class, args);
	}
}

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402958310.html">数组</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##杨辉三角形</p>
<pre><code class="language-plain_text">1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 
1 9 36 84 126 126 84 36 9 1 
</code></pre>
<pre><code class="language-plain_text">        int[][] yangHui = new int[10][];
        for (int i = 0; i &lt; yangHui.length ; i++) {
            yangHui[i] = new int[i+1];

            // 首末为1
            yangHui[i][0] = yangHui[i][i] = 1;

            // 从第三行开始给中间的元素赋值
            for (int j = 1; j &lt; i; j++) {
                yangHui[i][j] = yangHui[i - 1][j - 1] + yangHui[i - 1][j];
            }
        }
        
        for (int i = 0; i &lt; yangHui.length; i++) {
            for (int j = 0; j &lt; yangHui[i].length; j++) {
                System.out.print(yangHui[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
</code></pre>
<h2><a id="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二分查找</h2>
<pre><code class="language-plain_text">        int[] arr = new int[]{12,23,44,45,60,70,73,87,92,98};
        int startPoint = 0;
        int endPoint = arr.length - 1;

        int desc = 46;
        // 没有找到
        boolean isFlag = true;
        while (startPoint &lt;= endPoint) {
            int middle = (startPoint + endPoint) / 2;
            int value = arr[middle];
            if (value == desc) {
                System.out.println(&quot;查找到目标&quot;+desc);
                isFlag = false;
                break;
            }else if (value &lt; desc) {
                startPoint = middle + 1;
            }else {
                endPoint = middle - 1;
            }
        }

        if (isFlag) {
            System.out.println(&quot;没有查找到目标&quot;);
        }
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402958505.html">开台:14号-18 开始做  -  4天</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	

		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402958692.html">登录中密码加密</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>使用第三方框架 <code>import CryptoSwift</code></p>
<pre><code class="language-plain_text">        let key = &quot;hht_private_keys&quot;
        let iv = &quot;hht_private_ivss&quot;
        let salt = &quot;honghuotai&quot;
        
        let aes = try? AES(key: key, iv: iv,padding: .noPadding)
        let value = &quot;123456&quot; + salt
        let result = try? aes?.encrypt(value.bytes)
        print(result?.toBase64())
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402958889.html">Cocoapods的安装</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-plain_text">1.先升级Gem
    sudo gem update --system
2.切换cocoapods的数据源
    【先删除，再添加，查看】
    gem sources --remove https://rubygems.org/
    gem sources -a https://ruby.taobao.org/
    gem sources -l
3.安装cocoapods
    sudo gem install cocoapods
    或者（如10.11系统）sudo gem install -n /usr/local/bin cocoapods
4.(可忽略)将Podspec文件托管地址从github切换到国内的oschina
    【先删除，再添加，再更新】
    pod repo remove master
    pod repo add master http://git.oschina.net/akuandev/Specs.git
    pod repo add master https://gitcafe.com/akuandev/Specs.git
    pod repo update
5.设置pod仓库
    pod setup
6.测试
    【如果有版本号，则说明已经安装成功】
    pod --version
7.利用cocoapods来安装第三方框架
    01 进入要安装框架的项目的.xcodeproj同级文件夹
    02 在该文件夹中新建一个文件podfile
    03 在文件中告诉cocoapods需要安装的框架信息
        a.该框架支持的平台
        b.适用的iOS版本
        c.框架的名称
        d.框架的版本
8.安装
pod install --no-repo-update
pod update --no-repo-update

9.说明
platform :ios, '8.0' 用来设置所有第三方库所支持的iOS最低版本
pod 'SDWebImage','~&gt;2.6' 设置框架的名称和版本号
版本号的规则：
'&gt;1.0'    可以安装任何高于1.0的版本
'&gt;=1.0'   可以安装任何高于或等于1.0的版本
'&lt;1.0'    任何低于1.0的版本
'&lt;=1.0'   任何低于或等于1.0的版本
'~&gt;0.1'   任何高于或等于0.1的版本，但是不包含高于1.0的版本
'~&gt;0'     任何版本，相当于不指定版本，默认采用最新版本号

10.使用pod install命令安装框架后的大致过程：
01 分析依赖:该步骤会分析Podfile,查看不同类库之间的依赖情况。如果有多个类库依赖于同一个类库，但是依赖于不同的版本，那么cocoaPods会自动设置一个兼容的版本。
02 下载依赖:根据分析依赖的结果，下载指定版本的类库到本地项目中。
03 生成Pods项目：创建一个Pods项目专门用来编译和管理第三方框架，CocoaPods会将所需的框架，库等内容添加到项目中，并且进行相应的配置。
04 整合Pods项目：将Pods和项目整合到一个工作空间中，并且设置文件链接。

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402959086.html">SwiftTips - 集中处理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E9%9B%86%E4%B8%AD%E5%A4%84%E7%90%86objc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>集中处理@objc</h2>
<p><img src="media/16587402959086/WX20180113-112401@2x.png" alt="WX20180113-112401@2x" /></p>
<h2><a id="%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8D%E8%83%BD%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8D%95%E7%8B%AC%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模拟器不能执行的代码单独处理</h2>
<p><img src="media/16587402959086/15159872783257.jpg" alt="" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402959502.html">iOS 模拟器 添加图片到相册的小技巧</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>把图片拖到模拟器主屏幕,或者Safari中,保存图片7<br />
<img src="media/16587402959502/tips.gif" alt="tips" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402959705.html">Swift - 在swift中如何使用 hexcolor 值表示颜色</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>结果来自<a href="http://stackoverflow.com/questions/24263007/how-to-use-hex-colour-values-in-swift-ios">How to use hex colour values in Swift, iOS</a></p>
</blockquote>
<pre><code class="language-plain_text">extension UIColor {
    convenience init(hexString: String) {
        let hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int = UInt32()
        Scanner(string: hex).scanHexInt32(&amp;int)
        let a, r, g, b: UInt32
        switch hex.characters.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int &gt;&gt; 8) * 17, (int &gt;&gt; 4 &amp; 0xF) * 17, (int &amp; 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int &gt;&gt; 16, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int &gt;&gt; 24, int &gt;&gt; 16 &amp; 0xFF, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255)
    }
}
</code></pre>
<p>使用方法:</p>
<pre><code class="language-plain_text">let darkGrey = UIColor(hexString: &quot;#757575&quot;)
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402959934.html">左右联动效果再实现</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>在微指的时候,商户详情界面中就存在左右联动,具体实现可见<a href="https://github.com/Mekor/MKShowDetail">MKShowDetail</a> .当然这次和微指的时候有所不同,层级结构更深,所属视图跨控制器.下面是正文👇</p>
</blockquote>
<p>##数据结构<br />
在海底捞Pad版本项目中,点菜和点锅是两种完全不同的东西,但是又都属于点菜类中,所以数据结构比较复杂:</p>
<pre><code class="language-plain_text">点锅: 大分类 --&gt; 具体的锅底
点菜: 大分类 --&gt; 小分类 --&gt; 具体菜品
</code></pre>
<p><strong>需求:</strong> <em>大分类下如果有小分类并且小分类个数大于1个的时候显示小分类,如果小于一个则不显示.</em></p>
<p>这样两种数据结构完全不同的数据需要整合成相同的显示样式,跟同事讨论后决定粗暴的也是最简单的方法修改点锅数据,给大分类后面强行包裹一层小分类.</p>
<p>##视图设计<br />
数据层搞定了,又到了显示问题了:<br />
分类显示马上想到了<code>tableView</code>,但是<code>点锅</code>和<code>点菜</code>互不干扰,我想到的就是分成两个<code>section</code>,这时又有一个问题,需求又要求大分类和小分类的样式是不一样的,不一样的,不一样的...怎么办? 使用<code>tableViewSectionHeader</code>.按大类进行划分,<code>点锅</code>和<code>点菜</code>之间的区分用数据.小分类则用cell表示.</p>
<p>###tableViewSectionHeader 设计<br />
既然已经决定了用<code>headerView</code>那么怎么设计呢?</p>
<ol>
<li>点击事件</li>
<li>确定具体点击的是哪个</li>
</ol>
<p>所以我在设计<code>headerView</code>的时候让它在显示数据的时候也要传入当前的<code>index</code>:</p>
<pre><code class="language-plain_text">    func setName(_ name: String, index: Int) {
        nameLabel.text = name
        self.index = index
    }
</code></pre>
<p>(ps: 不要吐槽,刚开始用Swift写项目😂)</p>
<p>这样我自己记录下传入的<code>index</code>当点击事件的时候再告诉外界具体点击的是哪一个:</p>
<pre><code class="language-plain_text">    @objc private func labelClick() {
        delegate?.didSelectedHeader(section : self.index)
    }
</code></pre>
<p>很明显的知道我是使用代理进行数据传递的..说下为啥不使用属性记录<code>index</code>?? 任性😁</p>
<p>到这里<code>headerView</code>基本完成了,控制器实现代理方法就好了,然后根据<code>index</code>让右侧具体的菜品滚动到相应的位置就好了...</p>
<p>###点锅点菜区分&amp;跳转<br />
接上,左侧显示的大分类与小分类都是统一的了,但是右侧的点菜与点锅是分开的<strong>锅是锅,菜是菜</strong>.怎样区分呢?使用两套数据源,然后随时切换&gt;?? 不行🚫...要求要像淘宝或者京东详情页那样,可以滚动到下一页还可以滚回到上一页...怎么办? 使用两个collection控制器,一个显示点锅数据,一个显示点菜数据.这样做能够尽量减少某一个单独的控制器中存在过多的逻辑代码.那么谁来承载这两个控制器呢?再创建一个控制器然后把这两个放进去? 这样也能实现,就是控制器太多了...我想用的是一个<code>scrollow</code>来包裹这两个控制器,好处是能够控制显示那个控制器,逻辑也比较简单..比如说滚到第一个视图:</p>
<pre><code class="language-plain_text">        UIView.animate(withDuration: 0.25, delay: 0, options: .layoutSubviews, animations: ({
            self.contentView.contentOffset = CGPoint(x: 0, y: 0)
        }), completion: nil)
</code></pre>
<p>直接设置<code>scrollow</code>的<code>contentOffset</code>就可以了</p>
<p><strong>怎么做到电商网站中详情页与图文详情页滚动呢?</strong> 以当前项目为例(点锅在首屏),最简单的一种实现方式:</p>
<p>使用下拉刷新&amp;上拉加载更多实现</p>
<ol>
<li>点锅页面上拉加载更多跳转到点菜页面(通过上面代码设置<code>scrollow</code>的<code>contentOffset</code>实现)</li>
<li>点菜页面下拉刷新跳转到点锅页面,实现方式同上..</li>
</ol>
<p>这样很容易实现两个页面之间的跳转.</p>
<p>###右侧具体菜品数据处理<br />
终于到数据处理了...这里的主要矛盾点在与collectionView是一个二级结构数据即可分成<code>section</code>与具体的<code>Item</code>,<code>点锅</code>数据还好,可以强制抹除大分类和具体内容之间强加的子分类封装,那么点菜数据怎么处理呢?毕竟右侧数据滚动后还要通知左侧视图跳转到相应的分类...<br />
我想到的一种处理方式,可能不是最好的,但是这是我在短时间内想到比较行之有效的方法:</p>
<p>把点菜数据也通过一层操作转成两层数据:  <code>三层数据 --&gt; 遍历 --&gt; 数组 + 字典 </code><br />
具体点就是遍历三层数据,然后使用IndexPath当做 key ,具体的<code>Item</code>数组当做 value 这样就转换成立一个二级结构数据.具体<code>IndexPath</code>中<code>section</code>存放原有的大分类信息,<code>row</code>存放子分类数据信息..这样我们就可以通过 key 找到原有的数据结构信息,然后通过 key 把原有的信息传递到tableView,实现联动.</p>
<p>###具体联动效果实现</p>
<p>左侧点击后使用 <code>collectionView?.scrollToItem(at: IndexPath(item: 0, section: section), at: .top, animated: true)</code> 让右侧数据滚动到相应位置,关键是右侧滚动怎么判断左侧滚动到相应位置</p>
<p>在<code>scrollViewDidScroll</code>方法中获得当前显示的<code>Item</code>,具体计算方法如下:</p>
<pre><code class="language-plain_text">    private func minCurrentSection(collectionView:UICollectionView) -&gt; Int {
        // 根据屏幕的某一坐标,获取当前的index
        // 将collectionView在控制器屏幕的点转化成collectionView上的坐标
        let topPoint = CGPoint(x: UIScreen.main.bounds.size.width*0.5, y: 64)
        let pInView = view.convert(topPoint, to: collectionView)
        
        // 获取这一点的indexPath
        let  indexPathNow = collectionView.indexPathForItem(at: pInView)

        // 赋值给记录当前坐标的变量
        return indexPathNow?.section ?? 0
    }

</code></pre>
<p>这样就能够得到当前<code>Item</code>的<code>section</code>,<code>点锅</code>数据就可以直接让row等于0 然后直接回调就OK了,点菜数据还有些差别:<br />
点菜需要返回具体的<code>indexPathNow</code>而不是只返回所在<code>section</code>,因为我们需要返回来的<code>index</code>寻找所在的<code>Item</code></p>
<pre><code class="language-plain_text">guard let cell = collectionView?.cellForItem(at: index) as? OrderDishOrPotCollectionCell else {
            return
        }
        delegate?.orderDishCurrent(position: IndexPath(row:cell.index.row , section: cell.index.section))
</code></pre>
<p>如上,我在<code>cell</code>中存放一个使用元组的属性</p>
<pre><code class="language-plain_text">    // 记录对应的大分类与小分类
    var index:(section:Int,row:Int) = (section: 0,row: 0)
</code></pre>
<p>处理菜品数据的时候所说的,<code>点菜</code>比较特殊我用<code>IndexPath</code>来记录原先所在的大分类与小分类,那么这里的属性就是记录<code>Key</code>中<code>IndexPath</code>所对应的值.我们既然能够找到这个<code>Item</code>那么问题就都解决了,就像上面代码中的回调.</p>
<p>###注意<br />
因为这次需求是右侧数据滚动的过程中让左侧数据及时响应,而不是滚动结束的时候响应,所以需要判断是触摸滚动还是左侧数据点击后右侧数据滚动,毕竟两侧联动吗不做处理的话点击右侧数据左侧滚动,在左侧数据滚动的过程中又会及时回调让左侧数据滚动..</p>
<p>###思考🤔</p>
<p>第一种:<br />
<img src="media/16587402959934/14809480143802.jpg" alt="" /><br />
第二种:(目前采用)<br />
<img src="media/16587402959934/14809473897512.jpg" alt="" /></p>
<p>第一种是所要展现的内容控制器是底层控制器的自控制器<br />
第二种是所要展现内容的控制器在collectionView中,collectionView将不仅仅是一个视图而是变成了一个中间层<br />
这两种方式那种更好?</p>
<p>--- 12.7 ----<br />
需求有变动,不过改动起来看,还是第二种修改方便些😂,所有的逻辑跳转代码没有混合在最外层VC.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402960224.html">GCD(Grand Central Dispatch)使用</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:35+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>可以让程序长时间压后台</p>
<pre><code class="language-plain_text">//  后台执行：
dispatch_async(dispatch_get_global_queue(0, 0), ^{
  // something
});

// 主线程执行：
dispatch_async(dispatch_get_main_queue(), ^{
  // something
});

// 一次性执行：
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
  // code to be executed once
});

// 延迟2秒执行：
double delayInSeconds = 2.0;
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
   // code to be executed on the main queue after delay
});

// 自定义dispatch_queue_t
dispatch_queue_t urls_queue = dispatch_queue_create(&quot;blog.devtang.com&quot;, NULL);
dispatch_async(urls_queue, ^{
  // your code
});
dispatch_release(urls_queue);

// 合并汇总结果
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
  // 并行执行的线程一
});
dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
  // 并行执行的线程二
});
dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{
  // 汇总结果
});
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940350.html">优化iPad 2 总结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>实施反馈项目在<code>iPad 2</code>上比较卡顿,所以要对项目进行优化.</p>
<h2><a id="%E4%BC%98%E5%8C%96%E9%9B%86%E4%B8%AD%E7%82%B9%E4%B8%BAcollectionview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化集中点为collectionView</h2>
<p>项目有两种显示效果,一种是图片模式,一种是纯文字模式. 纯文字模式滑动起来还不错,图片模式就比较卡了.经分析,项目做了部分修改,使滑动效果比较顺畅.</p>
<ul>
<li>栅格化: 目的是离屏渲染,不过还是卡顿</li>
</ul>
<pre><code class="language-plain_text">    self.layer.shouldRasterize = true
    self.layer.rasterizationScale = UIScreen.main.scale
    self.layer.drawsAsynchronously = true
</code></pre>
<ul>
<li>Color Blended Layers 处理<br />
<img src="media/16587402940350/15058027400968.jpg" alt="" /><br />
发现部分UILabel存在问题,解决方案:<br />
<img src="media/16587402940350/15058028256147.jpg" alt="" /></li>
</ul>
<p>添加 <code>label.layer.masksToBounds = true</code>,效果还是不行.</p>
<ul>
<li>使用iOS最新的API<code>UICollectionViewDataSourcePrefetching</code></li>
</ul>
<pre><code class="language-plain_text">extension DishesViewController: UICollectionViewDataSourcePrefetching {
    func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {
        let urls = indexPaths.flatMap { (index) -&gt; URL? in
            let big = dishsArray[index.section]
            let key = big.keys.first!
            let small = big[key]!
            let item = small[index.item]
            return URL(string: item.dishModel.smallImageUrl)
        }
        
        ImagePrefetcher(urls: urls).start()
    }
}

</code></pre>
<ul>
<li>上面优化后效果不是很明显,最后采取了<strong>以空间换时间</strong>的方式优化图片列表页<br />
提前用<code>Kingfisher</code>下载图片(这个过程原先就有)下载过图片也做了不再下载的处理,由于图片过多导致不会有太多列表页的图片缓存中内存中. 针对这个问题,我采用了每次进入app就把列表页的图片使用<code>NSCache&lt;NSString, UIImage&gt;</code>缓存起来,效果很明显.</li>
</ul>
<h2><a id="%E7%9B%AE%E5%89%8D%E8%BF%98%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>目前还存在问题</h2>
<p>下载图片失败率还是很高的,我设置的超时时间为60s <code>downloader.downloadTimeout = 60</code> 但是还是有很多图片下载超时,导致首次加载的时候需要下载图片滑动卡顿.<br />
由于<code>NSCache</code>的特殊性,不能保证图片一直在内存中,正在考虑是否替换成Dictionary,然后自己处理内存警告.这个稍后验证下.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940455.html">百度坐标&火星坐标转换</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>LocationHelper.h文件</p>
<pre><code class="language-plain_text">#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreLocation/CoreLocation.h&gt;

@interface LocationHelper : NSObject

//百度转火星坐标
+ (CLLocationCoordinate2D )bdToGGEncrypt:(CLLocationCoordinate2D)coord;
//火星转百度坐标
+ (CLLocationCoordinate2D )ggToBDEncrypt:(CLLocationCoordinate2D)coord;

@end
</code></pre>
<p>LocationHelper.m文件</p>
<pre><code class="language-plain_text">//
//  LocationHelper.m
//  Coding_iOS
//
//  Created by Kevin on 3/21/15.
//  Copyright (c) 2015 Coding. All rights reserved.
//

#import &quot;LocationHelper.h&quot;

@implementation LocationHelper

//百度转火星坐标
+ (CLLocationCoordinate2D )bdToGGEncrypt:(CLLocationCoordinate2D)coord
{
    double x = coord.longitude - 0.0065, y = coord.latitude - 0.006;
    double z = sqrt(x * x + y * y) - 0.00002 * sin(y * M_PI);
    double theta = atan2(y, x) - 0.000003 * cos(x * M_PI);
    CLLocationCoordinate2D transformLocation ;
    transformLocation.longitude = z * cos(theta);
    transformLocation.latitude = z * sin(theta);
    return transformLocation;
}

//火星坐标转百度坐标
+ (CLLocationCoordinate2D )ggToBDEncrypt:(CLLocationCoordinate2D)coord
{
    double x = coord.longitude, y = coord.latitude;
    
    double z = sqrt(x * x + y * y) + 0.00002 * sin(y * M_PI);
    double theta = atan2(y, x) + 0.000003 * cos(x * M_PI);
    
    CLLocationCoordinate2D transformLocation ;
    transformLocation.longitude = z * cos(theta) + 0.0065;
    transformLocation.latitude = z * sin(theta) + 0.006;
    
    return transformLocation;
}

@end

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940546.html">常见的十种排序算法</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>选择排序 -&gt; 直接选择排序</li>
<li>选择排序 -&gt; 堆排序</li>
<li>交换排序 -&gt; 冒泡排序</li>
<li>交换排序 -&gt; 快速排序</li>
<li>插入排序 -&gt; 直接插入排序</li>
<li>插入排序 -&gt; 折半插入排序</li>
<li>插入排序 -&gt; Shell排序（希尔排序）</li>
<li>归并排序</li>
<li>桶式排序</li>
<li>基数排序</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940639.html">framework脚本</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-plain_text">if [ &quot;${ACTION}&quot; = &quot;build&quot; ]

then

INSTALL_DIR=${SRCROOT}/Products/${PROJECT_NAME}.framework

DEVICE_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework

SIMULATOR_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework

SIMULATOR_SWIFT_MODULE_DIR=&quot;${SIMULATOR_DIR}/Modules/${PROJECT_NAME}.swiftmodule/*&quot;

INSTALL_SWIFT_MODULE_DIR=${INSTALL_DIR}/Modules/${PROJECT_NAME}.swiftmodule/

if [ -d &quot;${INSTALL_DIR}&quot; ]

then

rm -rf &quot;${INSTALL_DIR}&quot;

fi

mkdir -p &quot;${INSTALL_DIR}&quot;

cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;

#ditto &quot;${DEVICE_DIR}/Headers&quot; &quot;${INSTALL_DIR}/Headers&quot;

lipo -create &quot;${DEVICE_DIR}/${PROJECT_NAME}&quot; &quot;${SIMULATOR_DIR}/${PROJECT_NAME}&quot; -output &quot;${INSTALL_DIR}/${PROJECT_NAME}&quot;

cp ${SIMULATOR_SWIFT_MODULE_DIR} &quot;${INSTALL_SWIFT_MODULE_DIR}&quot;

#open &quot;${DEVICE_DIR}&quot;

open &quot;${SRCROOT}/Products&quot;

fi
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940736.html">runtime(内部分享草稿)</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>本文涉及到的Demo地址 <a href="https://github.com/Mekor/runtimeDemo">https://github.com/Mekor/runtimeDemo</a></p>
</blockquote>
<p>##理解self,super,class,superclass</p>
<p>创建一个Person里面有一个类方法:</p>
<pre><code class="language-objc">#import &quot;Person.h&quot;

@implementation Person
+(void)study {
    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
}
@end
</code></pre>
<p>Student继承自Person,重写父类方法</p>
<pre><code class="language-objc">#import &quot;Student.h&quot;

@implementation Student
+(void)study {
    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
}
@end
</code></pre>
<!--more-->
<p>这两个输出的都是什么?<br />
<img src="media/16587402940736/14729913552743.jpg" alt="" /></p>
<p>这时,我们在Student中用这样写:</p>
<pre><code class="language-objc">#import &quot;Student.h&quot;

@implementation Student
+(void)study {
//    NSLog(@&quot;%@ %@ %@ %@&quot;,[self class],[self superclass],[super class],[super superclass]);
    
    [super study];
}
@end
</code></pre>
<p>打断点我们可以看到:<br />
<img src="media/16587402940736/14729934417192.jpg" alt="" /></p>
<p>可以看出:</p>
<pre><code class="language-objc">super：是编译器指示符，仅仅是一个标志,并不是指针，仅仅是标志的当前对象去调用父类的方法，本质还是当前对象调用
super:并不是让父类对象调用方法，调用者还是本身
class：获取方法调用者的类
superclass:获取方法调用者的父类
</code></pre>
<p>消息机制:(来自:<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">官方文档</a>)<br />
<img src="media/16587402940736/messaging1.gif" alt="消息框架" /></p>
<p>当对象收到消息时,消息函数首先根据该对象的 isa 指针找到该对象所对应的类的方法表,并从表中寻找 该消息对应的方法选标。如果找不到,objc_msgSend 将继续从父类中寻找,直到 NSObject 类。一旦找到了方法选标, objc_msgSend 则以消息接收者对象为参数调用,调用该选标对应的方法实现。</p>
<p>##self是从哪里来的?</p>
<blockquote>
<p>官方解释:<a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">Objective-C Runtime Programming Guide</a><img src="media/16587402940736/14729941396965.jpg" alt="" /></p>
</blockquote>
<p>简单说每个方法都存在并且隐藏的两个参数(self,_cmd),随便写个方法看下:<br />
Student中写个text方法,然后打印下这两个隐藏参数.<br />
<img src="media/16587402940736/14729960900273.jpg" alt="" /><br />
<img src="media/16587402940736/14729961142923.jpg" alt="" /></p>
<p>##动态添加方法<br />
上面说了一些貌似和runtime没有什么关系,runtime基础知识类似类的构成,对象的构成这里不再介绍,可以自己去看定义.当然也可以去<a href="http://opensource.apple.com/source/objc4/objc4-680/runtime/">苹果的开源网站</a>查看,如果网站不方便可以去苹果的<a href="https://github.com/opensource-apple/objc4">github</a>下载开源代码研究...  ...继续...那么根据上面所说的方法说下动态添加方法.</p>
<blockquote>
<p>思考一下,咱们new项目中将采用路由模式进行页面跳转,从网页跳转进入app调用一个方法,一般情况下都是移动端和后台协议好的内容,这样跳转不会出现问题.但是如果后台写错了或者传输中出现问题导致url中包含的方法名不是规定的方法名.这时怎么办?</p>
</blockquote>
<pre><code class="language-objc">    Student *s = [Student new];
    
    // 1. 比如我们要调用 Student中的eat方法, 默认这样写[s eat]; 但是不行,因为我们没有定义.
//    [s eat];
    // 2. 也可以这样调用[s performSelector:@selector(eat)];这样没有问题,@selector中参数是字符串,这个参考swift
//    [s performSelector:@selector(eat)];
    // 3. 使用string创建SEL
    
#pragma clang diagnostic push
#pragma clang diagnostic ignored&quot;-Warc-performSelector-leaks&quot;
    [s performSelector:NSSelectorFromString(@&quot;eat&quot;)];
#pragma clang diagnostic pop
    
    // 上面这样调用会报错,我们在对象调用未实现方法的时候动态的创建一个方法,避免抛出异常.
</code></pre>
<p>怎么忽略编译器警告已经分享过,可以参考:<a href="http://www.citynight.cn/Blog/14676105703423.html">http://www.citynight.cn/Blog/14676105703423.html</a></p>
<p>###怎么动态添加方法呢?<br />
<img src="media/16587402940736/14729983827897.jpg" alt="" /><br />
上面是动态添加对象方法的例子,动态添加类方法也是一样的<code>+(BOOL)resolveClassMethod:(SEL)sel</code><br />
**注意:**上面函数类型,有人可能好奇这块为什么写成&quot;v@:&quot;  ?参见:函数类型, 更多关于转发机制参见:<a href="http://www.citynight.cn/Blog/14733118707964.html">转发机制</a></p>
<h3><a id="%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于函数类型</h3>
<p>先看文档:<br />
<img src="media/16587402940736/14730056768742.jpg" alt="" /><br />
查看<code>Objective-C type encodings</code> <img src="media/16587402940736/14730058881001.jpg" alt="" /><br />
所以上面void eat(...)应该表述成 <code>&quot;v@:&quot;</code></p>
<p><strong>补充:</strong> 动态调用方法系统默认提供一到两个参数的方法调用, <del>这里封装了一个无限参数的方法调用.<a href="https://github.com/Mekor/NSObject-SEL">NSObject-SEL****</a></del>  我把一些扩展进行了总结,还不完善,地址<a href="https://github.com/Mekor/MKExtension">MKExtension</a></p>
<p>###关于IMP(函数指针)</p>
<pre><code class="language-objc">/// A pointer to the function of a method implementation. 
#if !OBJC_OLD_DISPATCH_PROTOTYPES
typedef void (*IMP)(void /* id, SEL, ... */ ); 
#else
typedef id (*IMP)(id, SEL, ...); 
#endif
</code></pre>
<p>当前版本Xcode如果使用IMP的话,默认是选择第一个也就是无参无返回值.如果需要参数有返回值的话,需要修改配置文件.如下:</p>
<h2><a id="%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2method-swizzling%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法交换(Method Swizzling:传说中的黑魔法)</h2>
<p>一般使用方法交换都是想给系统提供的方法添加一些其他的功能的时候使用.new中使用方法交换的例子:</p>
<pre><code class="language-objc">#import &quot;UIActionSheet+Front.h&quot;

#import &lt;objc/runtime.h&gt;

@implementation UIActionSheet (Front)
- (void)customShowInView:(UIView *)view{
    for(UIWindow * tmpWin in [[UIApplication sharedApplication] windows]){
        [tmpWin endEditing:NO];
    }
    [self customShowInView:view];
}
+ (void)load{
    swizzleAllActionSheet();
}
@end

void swizzleAllActionSheet(){
    Class c = [UIActionSheet class];
    SEL origSEL = @selector(showInView:);
    SEL newSEL = @selector(customShowInView:);
    Method origMethod = class_getInstanceMethod(c, origSEL);
    Method newMethod = class_getInstanceMethod(c, newSEL);
    method_exchangeImplementations(origMethod, newMethod);
}
</code></pre>
<p>关于方法交换,在new项目中已经封装好了,代码如下:</p>
<pre><code class="language-objc">// ObjcRuntime.h文件
void Swizzle(Class c, SEL origSEL, SEL newSEL);

//ObjcRuntime.m文件
//静态就交换静态，实例方法就交换实例方法
void Swizzle(Class c, SEL origSEL, SEL newSEL)
{
    Method origMethod = class_getInstanceMethod(c, origSEL);
    Method newMethod = nil;
    if (!origMethod) {
        origMethod = class_getClassMethod(c, origSEL);
        if (!origMethod) {
            return;
        }
        newMethod = class_getClassMethod(c, newSEL);
        if (!newMethod) {
            return;
        }
    }else{
        newMethod = class_getInstanceMethod(c, newSEL);
        if (!newMethod) {
            return;
        }
    }
    
    //自身已经有了就添加不成功，直接交换即可
    if(class_addMethod(c, origSEL, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))){
        class_replaceMethod(c, newSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
    }else{
        method_exchangeImplementations(origMethod, newMethod);
    }
}
</code></pre>
<p>用法(还是以Student为例):<br />
Student中添加两个对象方法,一个run,一个sleep.我们的目的是交换两个方法的实现</p>
<pre><code class="language-objc">-(void)run {
    NSLog(@&quot;跑🏃&quot;);
}
-(void)sleep {
    NSLog(@&quot;睡觉😴&quot;);
}
+(void)load {
    Swizzle(self, @selector(run), @selector(sleep));
}
</code></pre>
<p>控制器调用的结果:<br />
<img src="media/16587402940736/14730042652865.jpg" alt="" /></p>
<p>##添加属性<br />
动态添加属性用的最多的地方应该是给分类添加属性.  <del>我在项目中添加过一个分类<code> UIView+Tap</code>这个也可以在这里查看<a href="https://github.com/Mekor/UIView-Tap">UIView-Tap</a></del>  我把一些扩展进行了总结,还不完善,地址<a href="https://github.com/Mekor/MKExtension">MKExtension</a></p>
<pre><code class="language-objc">#import &quot;UIView+Tap.h&quot;
#import &lt;objc/runtime.h&gt;

static const void* tagValue = &amp;tagValue;

@interface UIView ()
@property (nonatomic, copy) void(^tapAction)(id);
@end

@implementation UIView (Tap)
- (void)tap{
    if (self.tapAction) {
        self.tapAction(self);
    }
}
- (void)addTapBlock:(void(^)(id obj))tapAction{
    self.tapAction = tapAction;
    if (![self gestureRecognizers]) {
        self.userInteractionEnabled = YES;
        UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];
        [self addGestureRecognizer:tap];
    }
}

-(void)setTapAction:(void (^)(id))tapAction {
    objc_setAssociatedObject(self, tagValue, tapAction, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
-(void (^)(id))tapAction {
    return objc_getAssociatedObject(self, tagValue);
}
@end
</code></pre>
<p>主要是set&amp;get方法,这点注意了也就没啥了..</p>
<p>##其他</p>
<ol>
<li>系统中常见的使用到runtime的地方:<br />
<a href="http://www.citynight.cn/Blog/14726525723684.html">KVO内部实现原理</a></li>
<li>日常开发中使用到runtime的地方:</li>
</ol>
<ul>
<li>字典转模型: 可以参看<code>MJExtension</code> 它的核心代码在:<code>NSObject+MJProperty.m</code>第150行开始</li>
</ul>
<pre><code class="language-objc">#pragma mark - 公共方法
+ (NSMutableArray *)properties
{
    NSMutableArray *cachedProperties = [self dictForKey:&amp;MJCachedPropertiesKey][NSStringFromClass(self)];
    
    if (cachedProperties == nil) {
        cachedProperties = [NSMutableArray array];
        
        [self mj_enumerateClasses:^(__unsafe_unretained Class c, BOOL *stop) {
            // 1.获得所有的成员变量
            unsigned int outCount = 0;
            objc_property_t *properties = class_copyPropertyList(c, &amp;outCount);
            
            // 2.遍历每一个成员变量
            for (unsigned int i = 0; i&lt;outCount; i++) {
                MJProperty *property = [MJProperty cachedPropertyWithProperty:properties[i]];
                // 过滤掉Foundation框架类里面的属性
                if ([MJFoundation isClassFromFoundation:property.srcClass]) continue;
                property.srcClass = c;
                [property setOriginKey:[self propertyKey:property.name] forClass:self];
                [property setObjectClassInArray:[self propertyObjectClassInArray:property.name] forClass:self];
                [cachedProperties addObject:property];
            }
            
            // 3.释放内存
            free(properties);
        }];
        
        [self dictForKey:&amp;MJCachedPropertiesKey][NSStringFromClass(self)] = cachedProperties;
    }
    
    return cachedProperties;
}
</code></pre>
<p>自定义字典转模型中log的输出可以参见Xcode插件<code>ESJsonFormat</code>中<code>ESJsonFormatManager.m</code>第47行:</p>
<pre><code class="language-objc">/**
 *  格式化OC属性字符串
 *
 *  @param key       JSON里面key字段
 *  @param value     JSON里面key对应的NSDiction或者NSArray
 *  @param classInfo 类信息
 *
 *  @return
 */
+ (NSString *)formatObjcWithKey:(NSString *)key value:(NSObject *)value classInfo:(ESClassInfo *)classInfo{
    NSString *qualifierStr = @&quot;copy&quot;;
    NSString *typeStr = @&quot;NSString&quot;;
    //判断大小写
    if ([ESUppercaseKeyWords containsObject:key] &amp;&amp; [ESJsonFormatSetting defaultSetting].uppercaseKeyWordForId) {
        key = [key uppercaseString];
    }
    if ([value isKindOfClass:[NSString class]]) {
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[@(YES) class]]){
        //the 'NSCFBoolean' is private subclass of 'NSNumber'
        qualifierStr = @&quot;assign&quot;;
        typeStr = @&quot;BOOL&quot;;
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ %@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[NSNumber class]]){
        qualifierStr = @&quot;assign&quot;;
        NSString *valueStr = [NSString stringWithFormat:@&quot;%@&quot;,value];
        if ([valueStr rangeOfString:@&quot;.&quot;].location!=NSNotFound){
            typeStr = @&quot;CGFloat&quot;;
        }else{
            NSNumber *valueNumber = (NSNumber *)value;
            if ([valueNumber longValue]&lt;2147483648) {
                typeStr = @&quot;NSInteger&quot;;
            }else{
                typeStr = @&quot;long long&quot;;
            }
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ %@;&quot;,qualifierStr,typeStr,key];
    }else if([value isKindOfClass:[NSArray class]]){
        NSArray *array = (NSArray *)value;
        
        //May be 'NSString'，will crash
        NSString *genericTypeStr = @&quot;&quot;;
        NSObject *firstObj = [array firstObject];
        if ([firstObj isKindOfClass:[NSDictionary class]]) {
            ESClassInfo *childInfo = classInfo.propertyArrayDic[key];
            genericTypeStr = [NSString stringWithFormat:@&quot;&lt;%@ *&gt;&quot;,childInfo.className];
        }else if ([firstObj isKindOfClass:[NSString class]]){
            genericTypeStr = @&quot;&lt;NSString *&gt;&quot;;
        }else if ([firstObj isKindOfClass:[NSNumber class]]){
            genericTypeStr = @&quot;&lt;NSNumber *&gt;&quot;;
        }
        
        qualifierStr = @&quot;strong&quot;;
        typeStr = @&quot;NSArray&quot;;
        if ([ESJsonFormatSetting defaultSetting].useGeneric &amp;&amp; [ESUtils isXcode7AndLater]) {
            return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@%@ *%@;&quot;,qualifierStr,typeStr,genericTypeStr,key];
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }else if ([value isKindOfClass:[NSDictionary class]]){
        qualifierStr = @&quot;strong&quot;;
        ESClassInfo *childInfo = classInfo.propertyClassDic[key];
        typeStr = childInfo.className;
        if (!typeStr) {
            typeStr = [key capitalizedString];
        }
        return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
    }
    return [NSString stringWithFormat:@&quot;@property (nonatomic, %@) %@ *%@;&quot;,qualifierStr,typeStr,key];
}

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940863.html">数据库复习</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>项目中部分功能打算使用数据库进行数据本地存储,所以复习了下数据库语句</p>
</blockquote>
<p>##DDL</p>
<pre><code class="language-plain_text">/*
删除表,如果存在表就删除表
*/
DROP TABLE IF EXISTS 't_student';

/*
创建表
*/

CREATE TABLE IF NOT EXISTS 't_student' (
	'id' INTEGER NOT NULL PRIMARY KEY  AUTOINCREMENT,
	'name' TEXT,
	'age' INTEGER
);
</code></pre>
<p>##DML</p>
<pre><code class="language-plain_text">/*
插入数据
*/
/*
INSERT INTO 't_student' (name, age) VALUES ('lxz1', 18);
INSERT INTO 't_student' (name, age) VALUES ('lxz2', 19);
INSERT INTO 't_student' (name, age) VALUES ('lxz3', 21);
INSERT INTO 't_student' (name, age) VALUES ('lxz4', 22);
*/

/*更新*/
-- UPDATE t_student SET age = 20 WHERE name = 'lxz1'
UPDATE t_student SET name = 'xxx' WHERE age &gt; 20


/*删除*/
DELETE FROM t_student WHERE name = 'xxx'
</code></pre>
<p>##DQL</p>
<pre><code class="language-plain_text">/*查询语句*/
-- SELECT * FROM t_student;

/*查询特殊的字段*/
-- SELECT name,age FROM t_student;

/*通过条件来查询语句*/
-- SELECT name, age FROM t_student WHERE age &lt; 20;

/*模糊查询*/
-- SELECT name,age FROM t_student WHERE name LIKE '%l%'

/*多个条件的查询
AND 并且
OR 或者
*/
-- SELECT name, age FROM t_student WHERE name LIKE '%l%' AND age &lt; 20;

/*计算个数*/
-- SELECT count(*) FROM t_student WHERE age &lt; 20

/*排序
升序 ASC
降序 DESC
*/
-- SELECT * FROM t_student ORDER BY age DESC

-- SELECT * FROM t_student ORDER BY age ASC, name DESC;

/*起别名*/
-- 给表起别名
SELECT s.name, s.age FROM t_student AS s;
-- 给字段起别名
SELECT name AS myName, age AS myAge FROM t_student;


/*分页查询 limt
数字1的意思是前面跳过多少条数据
数字2的意思是本次查询多少条数据
SELECT * FROM t_student LIMIT 数字1,数字2

跳过0条数据查询5条数据
SELECT * FROM t_student LIMIT 5
*/
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940959.html">忽略编译器警告</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一种方法</h2>
<p>举例<br />
<img src="media/14672570618572/14672571503878.jpg" alt="" /><br />
<img src="media/14672570618572/14672573103735.jpg" alt="" /><br />
接下来,<br />
<img src="media/14672570618572/14672575411986.jpg" alt="" /><br />
<img src="media/14672570618572/14672577757507.jpg" alt="" /></p>
<h2><a id="%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二种方法</h2>
<pre><code class="language-plain_text">#pragma clang diagnostic push
#pragma clang diagnostic ignored&quot; -Wcompare-distinct-pointer-types&quot;
    //写在这个中间的代码,都不会被编译器提示-Wcompare-distinct-pointer-types
#pragma clang diagnostic pop 
</code></pre>
<p>##Xib警告: This file is set to build for a version older than the deployment target. Functionality may be limited.<br />
类似于这种<br />
<img src="media/14672570618572/14672589919425.jpg" alt="" /></p>
<p>双击进入Xib文件<br />
<img src="media/14672570618572/14672592962938.jpg" alt="" /><br />
OK,这样就没有警告了</p>
<p>##非源文件参与编译错误<br />
<img src="media/14672570618572/Snip20160630_15.png" alt="Snip20160630_15" /><br />
项目中有一个README.md的文件,这个文件主要记录使用第三方的一些情况,默认就参与编译了,我们需要这样做</p>
<p><img src="media/14672570618572/Snip20160630_16.png" alt="Snip20160630_16" /></p>
<p>找到这个文件,然后移除,这样就不会有问题了.<br />
参考: <a href="http://stackoverflow.com/questions/6509600/compilation-warning-no-rule-to-process-file-for-architecture-i386">compilation warning: no rule to process file for architecture i386</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941058.html">金额显示</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-plain_text">//初始化NumberFormatter
let format = NumberFormatter()
//设置numberStyle（有多种格式）
format.numberStyle = .decimal
//转换后的string
let string = format.string(from: NSNumber(value: 1234567.89))
//打印
print(string)  //1,234,567.89

//显示样式和输出样式
numberStyle:
public enum Style : UInt {  

        case none //1234567.89

        case decimal //1,234,567.89

        case currency //￥1,234,567.89

        case percent //123,456,789%

        case scientific //1.23456789E6

        case spellOut //一百二十三万四千五百六十七点八九

        @available(iOS 9.0, *)
        case ordinal //第123,4568

        @available(iOS 9.0, *)
        case currencyISOCode //CNY1,234,567.89

        @available(iOS 9.0, *)
        case currencyPlural//1,234,567.89人民币

        @available(iOS 9.0, *)
        case currencyAccounting//￥1,234,567.89
    }

//输入123456789分别输出
// 123456789
// 123,456,789
//￥123,456,789.00
//12345678900%
//1.23456789E8
//一亿二千三百四十五万六千七百八十九
//第1,2345,6789
//CNY123,456,789.00
//123,456,789.00人民币
//￥123,456,789.00
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941158.html">关于tableViewCell加载图片优化</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>cell的创建</p>
<pre><code class="language-plain_text">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
</code></pre>
<p>数据处理建议在这里进行:</p>
<pre><code class="language-plain_text">-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath
</code></pre>
<p>cell将要显示的时候我们进行一些处理(来自苹果Demo)</p>
<pre><code class="language-plain_text">// Only load cached images; defer new downloads until scrolling ends
if (!appRecord.appIcon)
{
    if (self.tableView.dragging == NO &amp;&amp; self.tableView.decelerating == NO)
    {
        [self startIconDownload:appRecord forIndexPath:indexPath];
    }
    // if a download is deferred or in progress, return a placeholder image
    cell.imageView.image = [UIImage imageNamed:@&quot;Placeholder.png&quot;];
}
else
{
    cell.imageView.image = appRecord.appIcon;
}
</code></pre>
<p>这里可以看出,拖拽和滚动的时候不进行图片下载,只有停止的时候才进行.当然我们还需要在scrollView停止滚动和拖拽的时候进行下载</p>
<pre><code class="language-plain_text">#pragma mark - UIScrollViewDelegate

// -------------------------------------------------------------------------------
//	scrollViewDidEndDragging:willDecelerate:
//  Load images for all onscreen rows when scrolling is finished.
// -------------------------------------------------------------------------------
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate
{
    if (!decelerate)
	{
        [self loadImagesForOnscreenRows];
    }
}

// -------------------------------------------------------------------------------
//	scrollViewDidEndDecelerating:scrollView
//  When scrolling stops, proceed to load the app icons that are on screen.
// -------------------------------------------------------------------------------
- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView
{
    [self loadImagesForOnscreenRows];
}

</code></pre>
<p>下载显示cell的图片</p>
<pre><code class="language-plain_text">// -------------------------------------------------------------------------------
//	loadImagesForOnscreenRows
//  This method is used in case the user scrolled into a set of cells that don't
//  have their app icons yet.
// -------------------------------------------------------------------------------
- (void)loadImagesForOnscreenRows
{
    if (self.entries.count &gt; 0)
    {
        NSArray *visiblePaths = [self.tableView indexPathsForVisibleRows];
        for (NSIndexPath *indexPath in visiblePaths)
        {
            AppRecord *appRecord = (self.entries)[indexPath.row];
            
            if (!appRecord.appIcon)
            // Avoid the app icon download if the app already has an icon
            {
                [self startIconDownload:appRecord forIndexPath:indexPath];
            }
        }
    }
}
</code></pre>
<p>具体下载:</p>
<pre><code class="language-plain_text">#pragma mark - Table cell image support

// -------------------------------------------------------------------------------
//	startIconDownload:forIndexPath:
// -------------------------------------------------------------------------------
- (void)startIconDownload:(AppRecord *)appRecord forIndexPath:(NSIndexPath *)indexPath
{
    NSLog(@&quot;下载图片&quot;);
    IconDownloader *iconDownloader = (self.imageDownloadsInProgress)[indexPath];
    if (iconDownloader == nil) 
    {
        iconDownloader = [[IconDownloader alloc] init];
        iconDownloader.appRecord = appRecord;
        [iconDownloader setCompletionHandler:^{
            
            UITableViewCell *cell = [self.tableView cellForRowAtIndexPath:indexPath];
            
            // Display the newly loaded image
            cell.imageView.image = appRecord.appIcon;
            
            // Remove the IconDownloader from the in progress list.
            // This will result in it being deallocated.
            [self.imageDownloadsInProgress removeObjectForKey:indexPath];
            
        }];
        (self.imageDownloadsInProgress)[indexPath] = iconDownloader;
        [iconDownloader startDownload];  
    }
}
</code></pre>
<p>IconDownloader文件</p>
<pre><code class="language-plain_text">//.h文件
@class AppRecord;

@interface IconDownloader : NSObject

@property (nonatomic, strong) AppRecord *appRecord;
@property (nonatomic, copy) void (^completionHandler)(void);

- (void)startDownload;
- (void)cancelDownload;

@end


//.m文件
#import &quot;IconDownloader.h&quot;
#import &quot;AppRecord.h&quot;

#define kAppIconSize 48


@interface IconDownloader ()

@property (nonatomic, strong) NSURLSessionDataTask *sessionTask;

@end


#pragma mark -

@implementation IconDownloader

// -------------------------------------------------------------------------------
//	startDownload
// -------------------------------------------------------------------------------
- (void)startDownload
{
    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:self.appRecord.imageURLString]];

    // create an session data task to obtain and download the app icon
    _sessionTask = [[NSURLSession sharedSession] dataTaskWithRequest:request
                                                   completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        
        // in case we want to know the response status code
        //NSInteger HTTPStatusCode = [(NSHTTPURLResponse *)response statusCode];

        if (error != nil)
        {
            if ([error code] == NSURLErrorAppTransportSecurityRequiresSecureConnection)
            {
                // if you get error NSURLErrorAppTransportSecurityRequiresSecureConnection (-1022),
                // then your Info.plist has not been properly configured to match the target server.
                //
                abort();
            }
        }
                                                       
        [[NSOperationQueue mainQueue] addOperationWithBlock: ^{
            
            // Set appIcon and clear temporary data/image
            UIImage *image = [[UIImage alloc] initWithData:data];
            
            if (image.size.width != kAppIconSize || image.size.height != kAppIconSize)
            {
                CGSize itemSize = CGSizeMake(kAppIconSize, kAppIconSize);
                UIGraphicsBeginImageContextWithOptions(itemSize, NO, 0.0f);
                CGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);
                [image drawInRect:imageRect];
                self.appRecord.appIcon = UIGraphicsGetImageFromCurrentImageContext();
                UIGraphicsEndImageContext();
            }
            else
            {
                self.appRecord.appIcon = image;
            }
            
            // call our completion handler to tell our client that our icon is ready for display
            if (self.completionHandler != nil)
            {
                self.completionHandler();
            }
        }];
    }];
    
    [self.sessionTask resume];
}

// -------------------------------------------------------------------------------
//	cancelDownload
// -------------------------------------------------------------------------------
- (void)cancelDownload
{
    [self.sessionTask cancel];
    _sessionTask = nil;
}
</code></pre>
<blockquote>
<p><a href="https://developer.apple.com/library/ios/samplecode/LazyTableImages/Introduction/Intro.html">Apple Demo</a></p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941258.html">数据刷新崩溃</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402941258/15460678427638.jpg" alt="" style="width:531px;" /><br />
<img src="media/16587402941258/15460678670280.jpg" alt="" style="width:1054px;" /></p>
<p>发生崩溃的原因是<code>tableView</code> <code>reloadData</code> 的时候直接设置<code>tableView</code> 的 <code>scrollRectToVisible</code> 解决方案</p>
<pre><code class="language-plain_text">        UIView.animate(withDuration: 0, animations: {
            self.tableView.reloadData()
        }) { (finish) in
            let rect = self.tableView.rect(forSection: section)
            self.tableView.scrollRectToVisible(rect, animated: true)
        }
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941369.html">Java 分页的实现</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>背景: 公司在用Play框架,所以分页功能是在这个基础上来处理的.分页功能已经是一个完成的功能,刚接触后台,所以尝试分析一下分页功能实现的流程.</p>
</blockquote>
<p>在项目启动的时候回加载配置信息,在主配置文件<em>application.conf</em>中添加当Play启动的时候加载的module,我们需要对MyBatisModule</p>
<p><img src="media/16587402941369/15724200395131.jpg" alt="" style="width:699px;" /></p>
<p><code>MyBatisModule</code> 是继承自<code>org.mybatis.guice.MyBatisModule</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941471.html">调试</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>离屏渲染: 黄色是离屏的,紫色的是苹果label做的一些优化</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941573.html">在包含UITableView视图中添加单击手势</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>如果在包含UITableView视图中添加单击手势，这个单击手势会屏蔽掉UITableView的</p>
<pre><code class="language-plain_text">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>
<p>可以利用<code>UIGestureRecognizer</code>的<code>Delegate</code>中的</p>
<pre><code class="language-plain_text">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;
</code></pre>
<p>在单击点位于UITableView内的时候取消响应</p>
<pre><code class="language-plain_text">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
    CGPoint point = [gestureRecognizer locationInView:self];
    if(CGRectContainsPoint(menuTableView.frame, point)){
        return NO;
    }
    return YES;
}
</code></pre>
<p>或者将单击手势的cancelsTouchesInView设置为NO</p>
<pre><code class="language-plain_text">singleTap.cancelsTouchesInView = NO;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941680.html">欢迎使用 MWeb</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>首先介绍一下 MWeb 是什么，MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件。</p>
<p>然后这里<strong>重点说明</strong>一下：MWeb 有<strong>两个模式</strong>，外部模式和文档库模式。外部模式中把本地硬盘或 Dropbox 等网盘的文件夹引入，就可以使用 MWeb 的拖拽、粘贴插入图片、图床等特色功能。文档库模式设计为用于记笔记和静态博客生成。对于有<strong>同步和协作需求</strong>的朋友，请使用外部模式！使用视图菜单或者快捷键 <code>CMD + E</code> 可以打开外部模式，<code>CMD + L</code> 可以打开文档库。</p>
<h2><a id="mweb%E5%A4%A7%E6%A6%82%E7%94%A8%E6%B3%95%E3%80%81%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%A2%84%E8%A7%88%E7%95%8C%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MWeb 大概用法、视图模式和预览界面</h2>
<p>MWeb 使用菜单、快捷键和少量按钮完成所有操作，一般常用的操作都会有快捷键。整个界面使用三栏式结构，非常简洁。左边的第一第二栏是使用<strong>右键</strong>和底部的几个按钮操作，另外就是右上角有三个按钮了（外部模式是两个），快捷键分别是：<code>CMD + 7/8/9</code>。另外就是切换视图模式的快捷键了，建议看一下 <code>标记</code> 菜单和 <code>视图</code> 菜单。</p>
<ul>
<li>快捷键：<code>CMD + 1</code> 是在仅编辑器模式和三栏模式中切换。</li>
<li>快捷键：<code>CMD + 2</code> 是在二栏模式和仅编辑器模式中切换。</li>
<li>快捷键：<code>CMD + 3</code> 是在三栏模式和仅编辑器模式中切换。</li>
<li>快捷键：<code>CMD + 4</code> 是在编辑器/预览模式和三栏模式中切换。</li>
<li>快捷键：<code>CMD + R</code> 是在编辑器和预览模式中切换。</li>
</ul>
<p><strong>特别说明</strong>：当 <code>偏好设置</code> - <code>通用设置</code> 中 <code>切换视图模式（二三栏）时，保持编辑器大小不变</code> 被勾选后，<code>CMD + 1/2/3/4</code> 的行为会发生变化，具体如何，可以尝试一下。而 <code>在新窗口中打开实时预览（CMD + R）</code> 这个选项被选中后，快捷键 <code>CMD + R</code> 会打开新的窗口来预览文档。</p>
<h2><a id="%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BA%86%E8%A7%A3mweb" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更多的了解 MWeb</h2>
<ul>
<li>MWeb 使用的是 Github Flavored Markdown 语法，请一定要打开 <code>帮助</code> - <code>Markdown 语法</code> 菜单看一下。</li>
<li>请一定要去官网首页看看，网址：<a href="http://zh.mweb.im">http://zh.mweb.im</a>。</li>
<li>请一定要看一下官网的帮助，用菜单 <code>帮助</code> - <code>帮助...</code> 即可打开，也可以用网址：<a href="http://zh.mweb.im/help.html">http://zh.mweb.im/help.html</a>。</li>
</ul>
<h2><a id="%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E6%94%B9%E8%BF%9Bmweb" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>帮助我们改进 MWeb</h2>
<p>如果你喜欢 MWeb，想让它变得更好，你可以：</p>
<ol>
<li>推荐 MWeb，让更多的人知道。</li>
<li>给我们发反馈和建议：<a href="mailto:coderforart+233@gmail.com">coderforart+233@gmail.com</a></li>
<li>在 Mac App Store 上评价 （如果是在 MAS 上购买的话）。</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941781.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>-----------------Time Warning------------<br />
Interface: <a href="http://39.106.55.108:29989/shop/table/getBillInfo">http://39.106.55.108:29989/shop/table/getBillInfo</a><br />
Time:3.18801999092102 sec</p>
<p>-----------------Time Warning------------<br />
Interface: <a href="http://39.106.55.108:29989/shop/table/lockTable">http://39.106.55.108:29989/shop/table/lockTable</a><br />
Time:3.12087106704712 sec</p>
<p>-----------------Time Warning------------<br />
Interface: <a href="http://39.106.55.108:29989/shop/preliminaryorder/print">http://39.106.55.108:29989/shop/preliminaryorder/print</a><br />
Time:2.86435294151306 sec</p>
<p>-----------------Time Warning------------<br />
Interface: <a href="http://39.106.55.108:29989/shop/pay/cash/settle">http://39.106.55.108:29989/shop/pay/cash/settle</a><br />
Time:8.01085901260376 sec</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941886.html">图片分享</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>服务端默认上传对所有人公开的图片</p>
<p>顾客可以按需购买空间存储自己的图片<br />
图片可以对外分享保存为壁纸<br />
图片可以设置水印</p>
<p>热门分享</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402941991.html">如何在UIBarButtonItem上显示数字(BadgeValue)</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>原因：项目中想要实现购物车右上角显示购物车中上品数量，但是直接用UIBarButtonItem不能实现要求</p>
</blockquote>
<p>这里是实现后的效果图：</p>
<p><img src="media/16587402941991/strip." alt="购物车动画" /></p>
<p>一开始直接创建的UIBarButtonItem，但是不能直接往上面添加想要的效果，因为</p>
<pre><code class="language-plain_text">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIBarButtonItem : UIBarItem &lt;NSCoding&gt;
</code></pre>
<p>而且</p>
<pre><code class="language-plain_text">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIBarItem : NSObject &lt;NSCoding, UIAppearance&gt;
</code></pre>
<p>退而求其次，我们知道UIBarButtonItem有一个属性</p>
<pre><code class="language-plain_text">@property(nullable, nonatomic,strong)  __kindof UIView     *customView;       // default is nil
</code></pre>
<p>这说明我们可以使用UIButton来代替UIBarButtonItem，在UIButton上面添加想要的动画效果。</p>
<pre><code class="language-plain_text">    static CGFloat const kButtonWidth = 43.0f;
    static CGFloat const kButtonHeight = 43.0f;

    UIImage *cartImage = [[UIImage imageNamed:@&quot;iconfont-cart&quot;]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];

    UIButton *cartButton = [UIButton buttonWithType:UIButtonTypeCustom];
    cartButton.frame = CGRectMake(0.0f, 0.0f, kButtonWidth, kButtonHeight);
    cartButton.backgroundColor = [UIColor clearColor];
    [cartButton setImage:cartImage forState:UIControlStateNormal];
    [cartButton setImageEdgeInsets:UIEdgeInsetsMake(0.0f,(kButtonHeight- cartImage.size.width), 0.0f, 0.0f)];
    [cartButton addTarget:self action:@selector(changeStatus:) forControlEvents:UIControlEventTouchUpInside];
    [cartButton addSubview:self.numberLabel];

    UIBarButtonItem *rightBarButtonItem = [[UIBarButtonItem alloc]initWithCustomView:cartButton];
    self.navigationItem.rightBarButtonItem = rightBarButtonItem;
</code></pre>
<p>创建Label使用懒加载：</p>
<pre><code class="language-plain_text">#pragma mark 购物车上面显示的按钮
-(UILabel *)numberLabel
{
    if (!_numberLabel) {

        static CGFloat const kNameLabelWidth = 14;
        static CGFloat const kNameLabelHeight = 14;
        static CGFloat const kNameLabelX = 40; // 父视图宽44，UI说改到这个位置
        static CGFloat const kNameLabelY = 6;

        _numberLabel = [UILabel new];
        _numberLabel.hidden = YES;
        _numberLabel.frame = CGRectMake(kNameLabelX, kNameLabelY, kNameLabelWidth, kNameLabelHeight);

        _numberLabel.backgroundColor = [UIColor redColor];
        _numberLabel.textColor = [UIColor whiteColor];
        _numberLabel.font = [UIFont systemFontOfSize:9];
        _numberLabel.textAlignment = NSTextAlignmentCenter;
        _numberLabel.layer.cornerRadius = kNameLabelHeight * 0.5;
        _numberLabel.layer.masksToBounds = YES;

    }
    return _numberLabel;
}
</code></pre>
<p>这里说下为什么设置为hidden，因为要求数量为0的时候不显示，数量不为0显示，如果删除后还要添加不如直接控制hidden。<br />
其他的就是设置Label显示的数字了，这里就不写了。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942104.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>feng<a href="media/16587402942104/1.EV-MJ%E9%93%BE%E6%8E%A5%20.txt">1.EV-MJ链接 </a>xiangtai<br />
竹林人家<br />
基础版本</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942213.html">GCD(Grand Central Dispatch)</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>由于Stack Overflow中Documentation将要关闭,所以我将部分内容转载至这里</p>
</blockquote>
<p>Grand Central Dispatch (GCD) is Apple's answer to multithreading. It is a lightweight framework for performing tasks synchronously or asynchronously in queues and handles CPU threads for you behind the scenes.</p>
<p>##Dispatch Semaphore<br />
<a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28284/dispatch-semaphore">Stack Overflow地址</a></p>
<blockquote>
<p>DispatchSemaphore provides an efficient implementation of a traditional counting semaphore, which can be used to control access to a resource across multiple execution contexts.</p>
</blockquote>
<p>A scenario for when to use a semaphore could be if you are doing some file reading/writing, if multiple tasks are trying to read and write from file at the same time, it could increase your performance to make each task wait its turn so as to not overburden the I/O controller.</p>
<pre><code class="language-plain_text">func do2TasksAtATime () {
    print(&quot;starting long running tasks (2 at a time)&quot;)
    let sem = DispatchSemaphore(value: 2)            //this semaphore only allows 2 tasks to run at the same time (the resource count)
    for i in 0...7 {                                 //launch a bunch of tasks
        DispatchQueue.global().async {               //run tasks on a background thread
            sem.wait()                               //wait here if no resources available
            sleep(2)                                 //do some long task eg file access (here we are just sleeping for a 2 seconds for demonstration purposes)
            print(&quot;long task \(i) done! \(Date())&quot;)
            sem.signal()                             //let the semaphore know this resource is now available
        }
    }
}
</code></pre>
<p>Example output: (notice the time stamps)</p>
<pre><code class="language-plain_text">starting long running tasks (2 at a time)
long task 0 done! 2017-02-16 07:11:53 +0000
long task 1 done! 2017-02-16 07:11:53 +0000
long task 2 done! 2017-02-16 07:11:55 +0000
long task 3 done! 2017-02-16 07:11:55 +0000
long task 5 done! 2017-02-16 07:11:57 +0000
long task 4 done! 2017-02-16 07:11:57 +0000
long task 6 done! 2017-02-16 07:11:59 +0000
long task 7 done! 2017-02-16 07:11:59 +0000
</code></pre>
<p>##Dispatch Group<br />
<a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28278/dispatch-group">Stack Overflow地址</a></p>
<blockquote>
<p>DispatchGroup allows for aggregate synchronization of work. You can use them to submit multiple different work items and track when they all complete, even though they might run on different queues. This behavior can be helpful when progress can’t be made until all of the specified tasks are complete.</p>
</blockquote>
<p>A Scenario when this could be useful is if you have multiple webservice calls that all need to finish before continuing. For example, you need to download multiple sets of data that needs to be processed by some function. You have to wait for all webservices to complete before calling the function to process all the received data.</p>
<p><strong>Swift 3</strong></p>
<pre><code class="language-plain_text">func doLongTasksAndWait () {
    print(&quot;starting long running tasks&quot;)
    let group = DispatchGroup()          //create a group for a bunch of tasks we are about to do
    for i in 0...3 {                     //launch a bunch of tasks (eg a bunch of webservice calls that all need to be finished before proceeding to the next ViewController)
        group.enter()                    //let the group know that something is being added
        DispatchQueue.global().async {   //run tasks on a background thread
            sleep(arc4random() % 4)      //do some long task eg webservice or database lookup (here we are just sleeping for a random amount of time for demonstration purposes)
            print(&quot;long task \(i) done!&quot;)
            group.leave()                //let group know that the task is finished
        }
    }
    group.wait()                         //will block whatever thread we are on here until all the above tasks have finished (so maybe dont use this function on your main thread)
    print(&quot;all tasks done!&quot;)
}
</code></pre>
<p>Alternatively, if you do not want to wait for the groups to finish, but instead want to run a function once all the tasks have completed, use the <code>notify</code> function in place of the <code>group.wait()</code></p>
<pre><code class="language-plain_text">group.notify(queue: DispatchQueue.main) { //the queue: parameter is which queue this block will run on, if you need to do UI updates, use the main queue
    print(&quot;all tasks done!&quot;)              //this will execute when all tasks have left the group
}
</code></pre>
<p>Example output:</p>
<pre><code class="language-plain_text">starting long running tasks
long task 0 done!
long task 3 done!
long task 1 done!
long task 2 done!
all tasks done!
</code></pre>
<p>##Serial vs Concurrent Dispatch Queues</p>
<p><a href="https://stackoverflow.com/documentation/ios/4626/gcd-grand-central-dispatch/28286/serial-vs-concurrent-dispatch-queues">Stack Overflow地址</a><br />
<strong>Serial Queue</strong></p>
<pre><code class="language-plain_text">func serialQueues () {
    let serialQueue = DispatchQueue(label: &quot;com.example.serial&quot;) //default queue type is a serial queue
    let start = Date ()
    for i in 0...3 {                                             //launch a bunch of tasks
        serialQueue.async {                                      //run tasks on a background thread, using our serial queue
            sleep(2)                                             //do some long task eg webservice or database lookup
            let timeTaken = Date().timeIntervalSince(start)
            print(&quot;serial long task \(i) done! total time taken: \(timeTaken)&quot;)
        }
    }
}
</code></pre>
<p>Example output:</p>
<pre><code class="language-plain_text">serial long task 0 done! total time taken: 2.07241100072861
serial long task 1 done! total time taken: 4.16347700357437
serial long task 2 done! total time taken: 6.23209798336029
serial long task 3 done! total time taken: 8.30682599544525
</code></pre>
<p><strong>Concurrent Queue</strong></p>
<pre><code class="language-plain_text">func concurrentQueues () {
    let concurrentQueue = DispatchQueue(label: &quot;com.example.concurrent&quot;, attributes: .concurrent) //explicitly specify the queue to be a concurrent queue
    let start = Date ()
    for i in 0...3 {            //launch a bunch of tasks
        concurrentQueue.async { //run tasks on a background thread, using our concurrent queue
            sleep(2)            //do some long task eg webservice or database lookup
            let timeTaken = Date().timeIntervalSince(start)
            print(&quot;concurrent long task \(i) done! total time taken: \(timeTaken)&quot;)
        }
    }
}
</code></pre>
<p>Example output:</p>
<pre><code class="language-plain_text">concurrent long task 3 done! total time taken: 2.07092100381851
concurrent long task 0 done! total time taken: 2.07087397575378
concurrent long task 2 done! total time taken: 2.07086700201035
concurrent long task 1 done! total time taken: 2.07089096307755
</code></pre>
<p><strong>Discussion</strong></p>
<p>As we can see from the examples above, a serial queue will complete each task in the order they are submitted to the queue. Each task will wait for the previous task to finish before executing. As for the concurrent queue, each task does not wait on the others in the queue and executes as soon as possible; the advantage is that all tasks on the queue will run at the same time on separate threads, making a concurrent queue take less time than a serial queue.</p>
<p>If order of execution of tasks is not important, always use a concurrent queue for the best efficiency.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942321.html">Flutter中的key</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>key 可以理解为key value paijianzhidui）健值对<br />
几乎所有的flutter widget都有key</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942428.html">打包后出现 Undefined symbols for architecture i386</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>出现问题:<br />
自己打framework真机与模拟器合并后在使用的时候提示 <code>Undefined symbols for architecture i386</code></p>
<p>原因: 打framework的时候使用的是<code>debug</code> 改为<code>release</code><br />
<img src="media/16587402942428/14963704118450.jpg" alt="" /></p>
<p><strong>合并命令:</strong></p>
<p><code>lipo -create 真机(或者模拟器)framework地址 模拟器(或者真机)ramework地址 -output 输出地址(一般我选择真机framework地址)</code></p>
<p><strong>查看信息:</strong></p>
<p><code>lipo -info 真机(或者模拟器)framework地址</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942545.html">Cell点击时多次Push</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="https://stackoverflow.com/questions/5687991/uitableview-didselectrowatindexpath-called-twice">stackoverflow上面的解决方案</a></p>
<pre><code class="language-plain_text">func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {

    tableView.deselectRowAtIndexPath(indexPath, animated: true)

    if let navigationController = navigationController {
        guard navigationController.topViewController == self else {
            return
        }
    }
}

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942657.html">Swift - 上周总结(12.30)</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##规范问题<br />
关于视图该不该把控件暴露出去?<br />
通常情况下不能,原因:为了<del>部落</del>封闭性.</p>
<p>我的理解,每个视图都是一个盒子,如果有需要我可以给外面提供一个update接口来更改数据.视图中的点击事件可以通过<code>Target-Action</code>实现,当然闭包&amp;代理同样可以.非常符合<code>Cocoa</code>提倡的<code>MVC</code>模式</p>
<p><img src="media/16587402942657/14834530948549.jpg" alt="" /></p>
<p>关于视图中空间是否暴露出去,默认都是<code>private</code>,我认为苹果<code>Cocoa Touch</code>中<code>UIKit</code>部分控件设计的不是很好,举个🌰:<br />
<code>UIButton</code>如果设置字体的大小,需要通过<code>titleLabel?.font</code>来设置.我认为这样是不好的,通过一个方法来设置font感觉更合适.</p>
<p>##更Swift<br />
毕竟大部分同学都是刚接触Swift,整个项目感觉有点像翻译,还是<code>OC</code>的味道,关于这个问题讨论了两点,一个是面向协议编程,一个是函数式编程<br />
###面向协议编程<br />
问题:某一个视图是其他视图所需要的一部分,现在的做法是将共有的视图抽取出来,成为一个视图,然后其他视图包含这个视图.<br />
面向协议:公共的子视图设置为一个协议,然后给一个默认的实现.像搭积木一样做视图的拼接.</p>
<p>参考资料:<a href="https://github.com/atConf/atswift-2016-resources">atswift-2016大会</a>中<code>李洁信_Pop in Swift</code>这个section可以参考.<br />
###函数式编程<br />
周欣对自己代码优化的时候发现的问题:<br />
一开始的逻辑:</p>
<pre><code class="language-plain_text">class func fetchAllDish() -&gt; [Any] {
        var mutableBigCategorys = [Any]()
        let bigCategorys = DatabaseManager.shared.fetchAllDishCategory()
        for bigCategory in bigCategorys {
            var bigCategory = bigCategory
            var mutableSubCategorys = [Any]()
            let subCategorys = DatabaseManager.shared.fetchSubCategorys(byCategroyID: bigCategory[&quot;CATEGORYID&quot;] as! String)
            for subCategory in subCategorys {
                var subCategory = subCategory
                let dishes = DatabaseManager.shared.fetchDishes(bySubCategoryID: subCategory[&quot;CLASSID&quot;] as! String)
                if dishes.count &gt; 0 {
                    subCategory[&quot;dishes&quot;] = dishes
                    mutableSubCategorys.append(subCategory)
                }
            }
            if mutableSubCategorys.count &gt; 0 {
                bigCategory[&quot;subCategorys&quot;] = mutableSubCategorys
                mutableBigCategorys.append(bigCategory)
            }
        }
        return mutableBigCategorys
    }
</code></pre>
<p>优化后的:</p>
<pre><code class="language-plain_text">class func fetchAllDish() -&gt; [Any] {
        let bigCategorys = DatabaseManager.shared.fetchAllDishCategory()
        let results = bigCategorys.map { (bigCategory) -&gt; [String: Any] in
            var bigCategory = bigCategory
            let subCategory = DatabaseManager.shared.fetchSubCategorys(byCategroyID: bigCategory[&quot;CATEGORYID&quot;] as! String)
            let subResults = subCategory.map({ (subCategory) -&gt; [String: Any] in
                var subCategory = subCategory
                let dishes = DatabaseManager.shared.fetchDishes(bySubCategoryID: subCategory[&quot;CLASSID&quot;] as! String)
                subCategory[&quot;dishes&quot;] = dishes
                return subCategory
            }).filter({ $0.count &gt; 0 })
            bigCategory[&quot;subCategorys&quot;] = subResults
            return bigCategory
        }.filter({ $0.count &gt; 0 })
        return results
    }
</code></pre>
<p>通过<code>map</code>与<code>filter</code>的灵活使用,使代码逻辑更清晰,同时也减少了不必要的临时变量.</p>
<p>###元组<br />
这个甲冠用的比较6..代码参见<code>NeoSubDishDetailView.swift</code>简单🌰:</p>
<pre><code class="language-plain_text">    func refreshInfo(data : (UIButton,DishTypeModel)){
        dishNameLabel.text = data.1.name
        moneyLabel.text = data.1.price
        numLabel.text = String(data.1.num)
        if data.1.num &lt;= 0{
            self.cutButton.isHidden = true
            self.numLabel.isHidden = true
        }else{
            self.cutButton.isHidden = false
            self.numLabel.isHidden = false
        }
    }

</code></pre>
<p>还有好多地方使用,这个文件可以好好观摩一下,很Swift...</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942771.html">Swift - 自定义tableViewCell</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>习惯 OC 刚刚接触 Swift 还是有很多地方不适应,创建自定义cell的时候出现如下情况</p>
<pre><code class="language-plain_text">    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
    }
</code></pre>
<p>OC 中,我们会用 self 来接 super 初始化来判断是否创建成功,但是 Swift 中怎样做呢?调用 <code>super.init</code>是没有返回值的,那么我们怎样判断呢?</p>
<p>从网上看<a href="http://stackoverflow.com/questions/37098742/super-init-in-swift">Super init in Swift</a>没有必要在进行<code>if(self)</code>判断了...不过,我还是找到了一种更容易理解的方法:</p>
<pre><code class="language-plain_text">    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        if !self.isEqual(nil) {
            setupInterface()
        }
    }

</code></pre>
<p>虽然感觉有点画蛇添足,不过很符合刚刚从OC 转 Swift 的理解方式</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942876.html">SSH 免密登录设置</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402942876/IMG_1E8AAA2E770B-1.jpeg" alt="IMG_1E8AAA2E770B-1" /></p>
<ol>
<li>首先进入 ssh 文件夹</li>
</ol>
<pre><code class="language-plain_text">cd ~/.ssh
</code></pre>
<ol start="2">
<li>然后生成公钥和私钥</li>
</ol>
<pre><code class="language-plain_text">ssh-keygen
</code></pre>
<p>按三次回车，这样就生成了公钥和私钥，</p>
<ol>
<li>把生成的公钥追加到服务器的授权文件的尾部</li>
</ol>
<pre><code class="language-plain_text">ssh-copy-id root@192.168.1.7 
</code></pre>
<p>这样就完成了免密登录的设置<br />
<img src="media/16587402942876/16153824552757.jpg" alt="" style="width:606px;" /></p>
<p>追加完后我们可以看下是否一致<br />
<img src="media/16587402942876/16153840301369.jpg" alt="" style="width:606px;" /><br />
我们能看到服务端授权文件追加的公钥就是我们客户端生成的公钥。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402942998.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	

		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402943108.html">使用 chisel 提高 LLDB 调试效率</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p><a href="https://github.com/facebook/chisel">https://github.com/facebook/chisel</a> 英文版使用说明</p>
</blockquote>
<p>##安装</p>
<ol>
<li>安装 <a href="http://brew.sh/index_zh-cn.html">Homebrew</a> (如果已经安装了,可以跳过这一步)</li>
</ol>
<pre><code class="language-plain_text">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<ol start="2">
<li>更新 Homebrew (如果已经最新了,可以跳过这一步)</li>
</ol>
<pre><code class="language-plain_text">brew update
</code></pre>
<ol start="3">
<li>通过 Homebrew 安装 chisel</li>
</ol>
<pre><code class="language-plain_text">brew install chisel
</code></pre>
<ol start="4">
<li>添加 chisel 命令至 ~/.lldbinit</li>
</ol>
<pre><code class="language-plain_text">touch ~/.lldbinit echo &quot;command script import /usr/local/opt/chisel/libexec/fblldb.py&quot; &gt;&gt; ~/.lldbinit
</code></pre>
<ol start="5">
<li>更新 chisel</li>
</ol>
<pre><code class="language-plain_text">brew upgrade chisel
</code></pre>
<p>##使用</p>
<ol>
<li>通过 <code>pviews</code> 命令直接查看页面层级关系</li>
</ol>
<hr />
<p>未完...</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402943222.html">UILabel边缘出现黑线</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>问题:代码实现 UILabel 时出现的边缘黑线问题<br />
原因:当 UILabel 的宽高出现浮点型数字时,在高清屏下有可能出现右侧边缘黑线问题, 解决方法是使用 <code>CGRectIntegral()</code> 方法确保 <code>frame</code> 中不存在非整形数值</p>
<pre><code class="language-plain_text">label.frame = CGRectIntegral(CGRectMake(0, 0, ceil(width),40));
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402943335.html">provider 使用</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>注意使用select<br />
<a href="https://www.jianshu.com/p/9cd4b9fb7b44">流式状态管理提供商的使用和封装</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402943445.html">1.weak</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>1&gt; OC对象</p>
<p>2.assign<br />
1&gt; 基本数据类型<br />
2&gt; OC对象</p>
<p>3.strong<br />
1&gt; OC对象</p>
<p>4.copy<br />
1&gt; NSString *<br />
2&gt; block</p>
<p>5.使用weak和assign修饰OC对象的区别<br />
1&gt; 成员变量</p>
<ol>
<li>weak生成的成员变量是用__weak修饰的，比如XMGCat * __weak _cat;</li>
<li>assign生成的成员变量是用__unsafe_unretained修饰的XMGCat * __unsafe_unretained _cat;</li>
</ol>
<p>2&gt; __weak和__unsafe_unretained</p>
<ol>
<li>都不是强指针（不是强引用），不能保住对象的命</li>
<li>__weak : 所指向的对象销毁后，会自动变成nil指针（空指针），不再指向已经销毁的对象</li>
<li>__unsafe_unretained : 所指向的对象销毁后，仍旧指向已经销毁的对象<br />
*/</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402943565.html">synchronized(object)</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>synchronized关键字代表这个方法加锁,相当于不管哪一个线 程A每次运行到这个法时,都要检查有没有其它正在用这个方法的线程B（或者C D等）,有的话要等正在使用这个方法的线程B（或者C D）运行完这个方法后再运行此线程A,没有的话,直接运行 它包括两种用法：synchronized 方法和 synchronized 块。</p>
</blockquote>
<p>##1. synchronized 方法：<br />
通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：<br />
　　<code>public synchronized void accessVal(int newVal); </code><br />
　　synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得 该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变 量的方法均被声明为 synchronized）。<br />
　　在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。<br />
　　synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized 块。<br />
　　<br />
##2. synchronized 块：<br />
通过 synchronized关键字来声明synchronized 块。语法如下：</p>
<pre><code class="language-plain_text">　　synchronized(syncObject) { 
　　//允许访问控制的代码 
　　}
</code></pre>
<p>　　<br />
　　synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高<br />
　　<br />
##对synchronized(object)的一些理解<br />
　<br />
**一、**当两个并发线程访问同一个对象object中的这个synchronized(this) 同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p>
<p>**二、**当一个线程访问object的一个synchronized(this)同步代码块时，其 他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p>
<p>**三、**然而，当一个线程访问object的一个synchronized(this)同步代码块 时，另一个线程仍然可以访问该object中的除synchronized(this)同步代码块以外的部分。</p>
<p>**四、**第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个 synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象 所有同步代码部分的访问都被暂时阻塞。</p>
<p>**五、**以上规则对其它对象锁同样适用</p>
<p>原文: <a href="http://fei263.blog.163.com/blog/static/9279372420103752814/">http://fei263.blog.163.com/blog/static/9279372420103752814/</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402943686.html">使用 Runloop 遇到的问题</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>首先: <code>swift</code> 与 <code>C</code> 兼容不如 <code>OC</code></p>
<ol>
<li>生成<code>CFRunLoopObserverContext</code>比<code>OC</code>艰难好多...</li>
</ol>
<pre><code class="language-plain_text">func addRunloopObserver() {
        autoreleasepool {
            guard let runloop = CFRunLoopGetCurrent() else {return}
            let unmanaged = Unmanaged.passRetained(self)
            let uptr = unmanaged.toOpaque()
            let vptr = UnsafeMutableRawPointer(uptr)
            var content = CFRunLoopObserverContext(version: 0, info: vptr, retain: nil, release: nil, copyDescription: nil)
            guard let obserber = CFRunLoopObserverCreate(kCFAllocatorDefault, CFRunLoopActivity.beforeWaiting.rawValue, true, Int.max - 999, observerCallbackFunc(), &amp;content) else {return}
            CFRunLoopAddObserver(runloop, obserber, CFRunLoopMode.defaultMode)
        }
    }
</code></pre>
<p>注意 content ,真是比OC复杂啊</p>
<ol start="2">
<li>强转也变了...</li>
</ol>
<pre><code class="language-plain_text">func observerCallbackFunc() -&gt; CFRunLoopObserverCallBack {
        
        return {(observer, activity, context) -&gt; Void in
            guard let context = context else {
                return
            }
            let work = Unmanaged&lt;RunLoopWorker&gt;.fromOpaque(context).takeUnretainedValue()
            
            if work.tasks.count == 0 { return }
            var result = false
            while result == false &amp;&amp; work.tasks.count &gt; 0 {
                // 取出任务
                if let unit = work.tasks.first,unit.values.count &gt; 0 {
                    result = unit.values.first!()
                    work.tasks.removeFirst()
                }
            }
        }
    }
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402943804.html">红火台"与云同行"个人总结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>今天参加了&quot;与云同行&quot;全员轮训,很高兴又回到了用友软件园,今天特意去看了下F106可惜没开门...西区的办公室没去看也挺怀念大家围着圆桌一起办公的日子...</p>
<p>&quot;大家早上好&quot;,&quot;好,很好,非常好&quot;  张林总简简单单的问好就让小伙伴们燃起来了,兴致高涨.对于我个人来说可能&quot;好,很好,非常好&quot;是我参会的重要收获.单独看很简单的六个字,但是喊起来真的很提神啊有木有?上午,张林总授课中就什么是云让大家讨论并写出自己的答案,我们组都是程序员可能会从程序员的角度考虑问题,想到了数据,资源池,云计算,云安全,还有将来我们会生活在<code>云</code>中.可能并不是正确的答案.授课中提到&quot;云&quot;将来会成为基础公共设施这个表示赞同,毕竟现在网络现在已经在我们身边,刷微博,聊微信,看知乎已经成为一种日常习惯.</p>
<p>第二个印象比较深刻的就<code>带盐</code>,我们组抽到的是为<code>畅捷支付</code>代言,我们给畅捷支付想了个口红&quot;畅捷在手,支付无忧&quot;.说实话,日常生活中并没有接触过畅捷支付,通过短片了解到这是商家端用的东东集合了各种支付方式,让商家降低接入支付方式的成本.当然了,除了分给我们的畅捷支付还有很多比如有空间,红火台等等,通过这个也让我们知道了用友现在有那么多云服务.包括:云平台,领域云,行业云,小微企业云,企业金融云,等等.领域云里面包括政务云,人力云,采购云,营销云,协同云,电子发票,云通信等.行业云里面包括:餐饮云,建筑云,汽车云,金融云,能源云,政务云等...老涂下午也来到现在,让我们知道了红火台餐饮云在用友云里面是一个特殊的存在,不仅面向企业同时也面向顾客.<br />
最后参与的是用户画像,原谅我把我们组并不完美的成果展示出来.<br />
<img src="media/16587402943804/51505701070_.pic.jpg" alt="51505701070_.pi" /><br />
我在课上也做过总结,可能当时想的不全,但是毕竟是自己组的感觉还是自己组的好<code>^_^</code> 我们组(好雨组,口号是:好雨让云落地)基于程序员本身的自画像.<strong>思维方式</strong>: 程序员面对的都是需求,要有发散思维和逆向思维.这些需求载我们这里就变成了各种思维导图,流程图,泳道图等等,方便我们思考和编写代码. <strong>工作行为</strong>: 包括Coding,fix bug,与UI,测试,产品沟通.张林总点评的时候说沟通属于协作方式,不过程序员的工作中绝大部分时间都是在和其他部门交流沟通,真正写代码的时间并不多.<strong>协作方式</strong>: 我们写了程序员日常生活中的必需品.<strong>工作边界</strong>: 我们是红火台的一块砖,哪里需要往哪搬.不管是海底捞pad重构,还是基础SaaS研发,哪里需要就去哪里.</p>
<p>以上,是今天的收获 <code>^_^ </code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402943923.html">Welcome to MWeb</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>What is MWeb? MWeb is a Pro Markdown writing, note taking and static blog generator App.</p>
<p>MWeb has two Mode, External Mode and Library Mode.<br />
In External Mode, you can edit classic text and markdown files from anywhere on your Mac. As an example, you can point MWeb to a folder on Dropbox. Shortcuts <code>CMD + E</code> or <code>View</code> - <code>Open External</code> to open External Mode.<br />
Library Mode design for note taking and static blog/website generator. Shortcuts <code>CMD + L</code> or <code>View</code> - <code>Open Library</code> to open Library Mode.<br />
External Mode's folders and Library Mode are supported <strong>Full Text Search</strong>, drag &amp; drop or paste to insert images.</p>
<h2><a id="view-mode-and-live-preview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>View Mode and Live Preview</h2>
<p>For Minimal UI, MWeb's interface only has a few buttons. The right-top corner buttons shortcuts: <code>CMD + 7/8/9</code>. <code>CMD + 7</code> is Library Mode only. For enable Typewriter Scrolling, Dark Mode and switch panes, please check the <code>View</code> menu.</p>
<ul>
<li>Shortcut: <code>CMD + 1</code> to toggle Editor Only and Three Panes.</li>
<li>Shortcut: <code>CMD + 2</code> to toggle Two Panes and Editor Only.</li>
<li>Shortcut: <code>CMD + 3</code> to toggle Three Panes and Editor Only.</li>
<li>Shortcut: <code>CMD + 4</code> to toggle Editor/Preview and Three Panes.</li>
<li>Shortcut: <code>CMD + R</code> to toggle Editor and Live Preview.</li>
</ul>
<p><strong>Note</strong>: When <code>Preferences</code> - <code>General</code> - <code>Resize window when hide pane</code> is enable, shortcuts <code>CMD + 1/2/3/4</code> behavior will be changed. You can enable this option and try it. When the <code>Live Preview (CMD + R) open new window</code> is enable, shortcut <code>CMD + R</code> will open new window for Live Preview.</p>
<h2><a id="more-about-mweb" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>More about MWeb</h2>
<ul>
<li>MWeb used Github Flavored Markdown syntax, please open <code>Help</code> - <code>Markdown syntax</code> for detail.</li>
<li>MWeb official website: <a href="http://www.mweb.im">http://www.mweb.im</a></li>
<li>MWeb documents: <code>Help</code> - <code>Help...</code> or <a href="http://www.mweb.im/help.html">http://www.mweb.im/help.html</a>.</li>
</ul>
<h2><a id="help-us-to-make-mweb-better" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Help us to make MWeb better!</h2>
<ol>
<li>Tell your friends about MWeb.</li>
<li>Send a feedback: <a href="mailto:coderforart+233@gmail.com">coderforart+233@gmail.com</a></li>
<li>Leave a review or at least a rating in Mac App Store.</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402944044.html">Android Studio 中如何查看帮助文档</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>
<p>首先下载帮助文档<br />
<img src="media/16587402944044/14693653611930.jpg" alt="" /></p>
</li>
<li>
<p>跳转到文件夹<br />
<img src="media/16587402944044/14693654229419.jpg" alt="" /></p>
</li>
<li>
<p>打开帮助文档 index.html<br />
<img src="media/16587402944044/14693655187234.jpg" alt="" /></p>
</li>
<li>
<p>例如查找Activity 生命周期可以这样走<br />
<img src="media/16587402944044/14693656858016.jpg" alt="" /><br />
然后command + f 搜索Activity选中一个高亮的选项例如:<br />
<img src="media/16587402944044/14693658027297.jpg" alt="" /><br />
由于它是继承自Activity的所以可以这样<br />
<img src="media/16587402944044/14693659242489.jpg" alt="" /><br />
然后往下翻一翻就能看到了<br />
<img src="media/16587402944044/14693659705775.jpg" alt="" /></p>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402944186.html">防止Timer 与控制器耦合导致控制器不释放</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在<code>OC</code>中可以使用<code>NSProxy</code> 的转发机制防止timer强引用<br />
具体例子可以参考<a href="https://github.com/ibireme/YYKit/blob/3869686e0e560db0b27a7140188fad771e271508/YYKit/Utility/YYWeakProxy.h">YYKit</a>中的处理方式,代码如下：</p>
<pre><code class="language-plain_text">#import &quot;YYWeakProxy.h&quot;


@implementation YYWeakProxy

- (instancetype)initWithTarget:(id)target {
    _target = target;
    return self;
}

+ (instancetype)proxyWithTarget:(id)target {
    return [[YYWeakProxy alloc] initWithTarget:target];
}

- (id)forwardingTargetForSelector:(SEL)selector {
    return _target;
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    void *null = NULL;
    [invocation setReturnValue:&amp;null];
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector {
    return [NSObject instanceMethodSignatureForSelector:@selector(init)];
}

- (BOOL)respondsToSelector:(SEL)aSelector {
    return [_target respondsToSelector:aSelector];
}

- (BOOL)isEqual:(id)object {
    return [_target isEqual:object];
}

- (NSUInteger)hash {
    return [_target hash];
}

- (Class)superclass {
    return [_target superclass];
}

- (Class)class {
    return [_target class];
}

- (BOOL)isKindOfClass:(Class)aClass {
    return [_target isKindOfClass:aClass];
}

- (BOOL)isMemberOfClass:(Class)aClass {
    return [_target isMemberOfClass:aClass];
}

- (BOOL)conformsToProtocol:(Protocol *)aProtocol {
    return [_target conformsToProtocol:aProtocol];
}

- (BOOL)isProxy {
    return YES;
}

- (NSString *)description {
    return [_target description];
}

- (NSString *)debugDescription {
    return [_target debugDescription];
}
</code></pre>
<p>在Swift中怎么处理？王巍的<a href="https://gist.github.com/onevcat/2d1ceff1c657591eebde">Gist</a>中写了一种</p>
<pre><code class="language-plain_text">private class Block&lt;T&gt; {
    let f : T
    init (_ f: T) { self.f = f }
}

extension NSTimer {
    static func xxx_scheduledTimerWithTimeInterval(ti: NSTimeInterval, block: ()-&gt;(), repeats: Bool) -&gt; NSTimer {
        return self.scheduledTimerWithTimeInterval(ti, target:
            self, selector: &quot;xxx_blcokInvoke:&quot;, userInfo: Block(block), repeats: repeats)
    }
    
    static func xxx_blcokInvoke(timer: NSTimer) {
        if let block = timer.userInfo as? Block&lt;()-&gt;()&gt; {
            block.f()
        }
    }
}
</code></pre>
<p>当然还有其他的方式比如：<a href="https://stackoverflow.com/questions/44096793/how-to-set-cadisplaylink-in-swift-with-weak-reference-between-target-and-cadispl">How to set CADisplayLink in Swift with weak reference between target and CADisplayLink instance<br />
</a> 等等。。。</p>
<p>目前公司项目中采用的方式如下：</p>
<pre><code class="language-plain_text">class WeakTimer: NSObject {
    
    private weak var target: NSObject?
    private weak var timer: Timer?
    private var selector: Selector
    
    private var userInfo: Any?
    
    init(withTimeInterval ti: TimeInterval, target aTarget: NSObject, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool) {
        self.target = aTarget
        self.selector = aSelector
        self.userInfo = userInfo
        super.init()
        timer = Timer.scheduledTimer(timeInterval: ti, target: self, selector: #selector(test), userInfo: userInfo, repeats: yesOrNo)
    }
    
    @objc private func test() {
        target?.perform(selector, with: self.userInfo, afterDelay: 0)
    }
    
    open class func scheduledTimer(timeInterval ti: TimeInterval, target aTarget: NSObject, selector aSelector: Selector, userInfo: Any?, repeats yesOrNo: Bool) -&gt; WeakTimer {
        let weakTimer = WeakTimer(withTimeInterval: ti, target: aTarget, selector: aSelector, userInfo: userInfo, repeats: yesOrNo)
        
        return weakTimer
    }
    
    open func invalidate() {
        timer?.invalidate()
    }
}
</code></pre>
<p>应用</p>
<pre><code class="language-plain_text">    @objc private func dismissSelf() {
        self.weakTimer?.invalidate()
        self.weakTimer = nil
        // HHTSwitchGlobalData.shared.waiterLoginTimeOut
        self.weakTimer = WeakTimer.scheduledTimer(timeInterval: HHTSwitchGlobalData.shared.waiterLoginTimeOut, target: self, selector: #selector(autoDismiss), userInfo: nil, repeats: true)
    }
</code></pre>
<p>第三方库 Kingfisher 中的处理办法</p>
<pre><code class="language-plain_text">    /// Proxy object for prevending a reference cycle between the CADDisplayLink and AnimatedImageView.
    class TargetProxy {
        private weak var target: AnimatedImageView?
        
        init(target: AnimatedImageView) {
            self.target = target
        }
        
        @objc func onScreenUpdate() {
            target?.updateFrame()
        }
    }
</code></pre>
<p>应用:</p>
<pre><code class="language-plain_text">private lazy var displayLink: CADisplayLink = {
        self.isDisplayLinkInitialized = true
        let displayLink = CADisplayLink(target: TargetProxy(target: self), selector: #selector(TargetProxy.onScreenUpdate))
        displayLink.add(to: .main, forMode: self.runLoopMode)
        displayLink.isPaused = true
        return displayLink
    }()
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402944321.html">C/C++ - 回调函数中比较大小为啥0不行?</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在C语言中我们判断真假经常使用非0为真,0为假.但是在回调函数中我设置返回非0与0代表真假的时候出现了问题:</p>
<pre><code class="language-plain_text">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int callBackCompare(void * pa, void * pb)
{
    return *(int *)pa &lt; *(int *)pb ? 1 : -1;
}

void selectSort(int *p, int n, int (*pf)(int a, int b))
{
    for(int i = 0; i &lt; n-1; i++)
    {
        for(int j = i+1; j&lt;n; j++)
        {
            if(pf(p[i],p[j]))
            {
                p[i] = p[i]^p[j];
                p[j] = p[i]^p[j];
                p[i] = p[i]^p[j];
            }
        }
    }
}

int main(int argc, char *argv[])
{
    int arr[10] = {1,2,3,4,5,9,8,7,6,0};

    qsort(arr,sizeof(arr)/sizeof(int),sizeof(int),callBackCompare);

    for(int i = 0; i&lt;10; i++)
    {
        printf(&quot;%d\n&quot;,arr[i]);
    }
    return 0;
}

</code></pre>
<p>callBack中这样写能够得到结果</p>
<pre><code class="language-plain_text">9
8
7
6
5
4
3
2
1
0
</code></pre>
<p>但是如果我把callback函数中的-1换成0则返回错误结果</p>
<pre><code class="language-plain_text">0
2
3
4
5
9
8
7
6
1
</code></pre>
<p>这是为什么呢?</p>
<p>---17.1.3----<br />
搞懂了,0不能代表升降...</p>
<blockquote>
<p>假设是对 int 排序的话，如果是升序， 那么就是如果 a 比 b 大返回一个正值，小则负值，相等返回 0; 假设是对 int 排序的话，如果是降序， 那么就是如果 a 比 b 大返回一个负值，小则正值，相等返回 0;</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402944461.html">Git学习</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>工作中必须使用git,但是原先一直使用svn,所以有点坑...这里简单总结下简单用法</p>
<p>##svn与git的不同<br />
一个是集中式版本管理控制,一个是分布式</p>
<p><strong>集中式版本控制:</strong><br />
<img src="media/16587402944461/14795544773647.jpg" alt="" /></p>
<p><strong>分布式版本控制:</strong><br />
<img src="media/16587402944461/14795545177377.jpg" alt="" /></p>
<p>##git简单实用</p>
<p>###git help</p>
<pre><code class="language-plain_text">$ git help
</code></pre>
<p>查看git所有命令的帮助</p>
<pre><code class="language-plain_text">$ git help 子命令
</code></pre>
<p>要退出帮助信息，按<code>&quot;q&quot;</code><br />
翻看下页，按<code>&quot;空格&quot;</code><br />
翻看上页，按<code>&quot;CTRL+B&quot;</code><br />
要搜索相关文字，按<code>&quot;/&quot;</code>然后输入<code>&quot;相关文字&quot;</code></p>
<p>###配置<br />
1&gt;  创建代码仓库</p>
<pre><code class="language-plain_text">$ git init
</code></pre>
<p>2&gt;  配置用户名和邮箱</p>
<pre><code class="language-plain_text">$ git config user.name manager
$ git config user.email manager@gmail.com
</code></pre>
<ul>
<li>以上两个命令会将用户信息保存在当前代码仓库中</li>
</ul>
<p>3&gt;  如果要一次性配置完成可以使用一下命令</p>
<pre><code class="language-plain_text">$ git config --global user.name manager
$ git config --global user.email manager@gmail.com
</code></pre>
<ul>
<li>以上两个命令会将用户信息保存在用户目录下的 <code>.gitconfig</code> 文件中</li>
</ul>
<p>4&gt;  查看当前所有配置</p>
<pre><code class="language-plain_text">$ git config -l
</code></pre>
<p>###开发中常用<br />
1&gt;  创建代码，开始开发</p>
<pre><code class="language-plain_text">$ touch main.c
$ open main.c
</code></pre>
<p>2&gt;  将代码添加到代码库</p>
<ol>
<li>查看当前代码库状态</li>
</ol>
<pre><code class="language-plain_text">$ git status
</code></pre>
<ol start="2">
<li>将文件添加到代码库</li>
</ol>
<pre><code class="language-plain_text">$ git add main.c
</code></pre>
<ol start="3">
<li>将修改提交到代码库</li>
</ol>
<pre><code class="language-plain_text">$ git commit -m &quot;添加了main.c&quot;
</code></pre>
<p>提示：</p>
<pre><code class="language-plain_text">*    在此一定要使用 -m 参数指定修改的备注信息
*    否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情
</code></pre>
<ol start="4">
<li>将当前文件夹下的所有新建或修改的文件一次性添加到代码库<br />
<code>$ git add .</code></li>
</ol>
<p>3&gt;  添加多个文件</p>
<pre><code class="language-plain_text">$ touch Person.h Person.m
$ git add .
$ git commit -m &quot;添加了Person类&quot;
$ open Person.h
$ git add .
$ git commit -m &quot;增加Person类属性&quot;
</code></pre>
<ul>
<li>注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的</li>
</ul>
<p>##git 的重要概念及工作原理<br />
工作区<br />
暂存区(staged)<br />
分支(HEAD)</p>
<p>##别名 &amp; 日志</p>
<pre><code class="language-plain_text">$ git config alias.st status
$ git config alias.ci &quot;commit -m&quot;
</code></pre>
<p>除非特殊原因，最好不要设置别名，否则换一台机器就不会用了</p>
<p>查看所有版本库日志</p>
<pre><code class="language-plain_text">$ git log
</code></pre>
<p>查看指定文件的版本库日志</p>
<pre><code class="language-plain_text">$ git log 文件名
</code></pre>
<p>配置带颜色的log别名</p>
<pre><code class="language-plain_text">git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot;
</code></pre>
<p>提示：在git中，版本号是一个由SHA1生成的哈希值</p>
<p>##版本号，让我们在任意版本之间穿梭</p>
<pre><code class="language-plain_text"># 回到当前版本，放弃所有没有提交的修改
$ git reset --hard HEAD
# 回到上一个版本
$ git reset --hard HEAD^
# 回到之前第3个修订版本
$ git reset --hard HEAD~3
# 回到指定版本号的版本
$ git reset --hard e695b67

# 查看分支引用记录
$ git reflog

</code></pre>
<p>##分支管理 - Tag</p>
<pre><code class="language-plain_text"># 查看当前标签
$ git tag
# 在本地代码库给项目打上一个标签
$ git tag -a v1.0 -m 'Version 1.0'
# 将标签添推送到远程代码库中
$ git push origin v1.0

# 使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本
# 签出v1.0标签
$ git checkout v1.0
# 从签出状态创建v1.0bugfix分支
$ git checkout -b bugfix1.0

# 查看远程分支
$ git branch -r
# 删除远程分支
$ git branch -r -d origin/bugfix1.0


一不小心把本地的临时分支push到server上去了，想要删除。
一开始用

git branch -r -d origin/branch-name

不成功，发现只是删除的本地对该远程分支的track，正确的方法应该是这样：

git push origin :branch-name

冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支。

</code></pre>
<p>删除修改返回到上次提交状态</p>
<pre><code class="language-plain_text">git checkout -f
</code></pre>
<p>查看本地分支对应的远程分支</p>
<pre><code class="language-plain_text">git branch -vv
</code></pre>
<h2><a id="%E6%9B%B4%E6%8D%A2%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更换远程服务器地址</h2>
<p>先查看remote的名字</p>
<pre><code class="language-plain_text">git branch -r
</code></pre>
<p>假设你的remote是origin，用git remote set_url 更换地址</p>
<pre><code class="language-plain_text">git remote set-url origin remote_git_address
</code></pre>
<p><code>remote_git_address</code>更换成你的新的仓库地址</p>
<pre><code class="language-plain_text">#查看远程地址
git remote -v  
</code></pre>
<h3><a id="git%E5%91%BD%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Git 命令快速查询</h3>
<h4><a id="https-github-combaiduhideviosgit-git-config-git-config" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-config"></a>git config</h4>
<pre><code class="language-source-shell">$ git config --global alias.co checkout 
$ git config --global alias.br branch 
$ git config --global alias.ci commit 
$ git config --global alias.st status
$ git config --global alias.last 'log -1 HEAD'
$ git config --global alias.unstage 'reset HEAD --'
$ git config user.name &quot;donganyuan&quot;
$ git config user.email &quot;donganyuan@baidu.com&quot;
$ git config --global core.editor &quot;atom --wait&quot;
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-commit-git-commit" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-commit"></a>git commit</h4>
<pre><code class="language-source-shell">$ git commit -a -m &quot;comment&quot; //添加并提交
$ git commit --amend //修改上次commit, do not amend your last commit if you have already pushed it

</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-merge-git-merge" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-merge"></a>git merge</h4>
<pre><code class="language-source-shell">$ git merge [branch name]

禁用fast forward merge
$ git merge --no-ff -m &quot;comment&quot; branch_name
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-log-git-log" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-log"></a>git log</h4>
<pre><code class="language-source-shell">$ git log -p -2 //查看每次提交的diff
$ git log --since=2.weeks
$ git log --author=AnYuan
$ git log --grep=keywords
$ git log --oneline --decorate // show you where the branch pointers are pointing.

//this command shows you any commits in your current branch that are not in
//the master branch on your origin remote.
$ git log origin/master..HEAD
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-remote-git-remote" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-remote"></a>git remote</h4>
<pre><code class="language-source-shell">查看远程仓库信息：
$ git remote -v
$ git remote add dev https://github.com/ddd/git
$ git remote show origin //inspecting a remote
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-stash-git-stash" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-stash"></a>git stash</h4>
<pre><code class="language-source-shell">$ git stash --保存未提交修改
$ git stash list --查看当前stash

$ git stash apply stash@{0}
$ git stash drop
等价于
$ git stash pop
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-branch-git-branch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-branch"></a>git branch</h4>
<pre><code class="language-source-shell">分支管理：

$ git checkout -b dev //-b 表示创建并切换分支
等价于
$ git branch dev
$ git checkout dev

git branch //查看当前分支 *表示当前分支

$ git branch -d dev //删除dev分支
$ git branch -D dev //强制删除未merge分支

$ git branch -vv //to see what tracking branches you have set up

禁用fast forward merge
$ git merge --no-ff -m &quot;comment&quot; branch_name

//share branch
$ git push origin branch_name
//delete remote branch
$ git push origin --delete [branchname]
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-undo-undo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#undo"></a>undo</h4>
<pre><code class="language-source-shell">1.未add 修改文件时（工作区），撤销可以：
$ git checkout -- [filename] 把文件在工作区的修改全部撤销， 把这个文件会退到最近一次commit或add状态
这个操作很危险，checkout后无法恢复了

2.add修改文件后(修改进入暂存区)，撤销可以：
$ git reset HEAD [filename]

3.commit后，撤销：
$ git reset --hard HEAD^
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-reflog-git-reflog" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-reflog"></a>git reflog</h4>
<pre><code class="language-source-shell">$ git reflog 记录每次命令
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-diff-git-diff" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-diff"></a>git diff</h4>
<pre><code class="language-source-shell">$ git diff //to see what you have changed but not yet staged
$ git diff --staged or cache // compares your staged changes to your last commit.
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-reset-git-reset" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-reset"></a>git reset</h4>
<pre><code class="language-source-shell">$ git reset --hard HEAD^ 回退到上一次commit
$ git reset --hard 3628164
//HEAD^^ 回退到上两个版本
//HEAD~100 回退到上100个版本

$ git reset --soft //update HEAD pointer
$ git reset --soft HEAD~ 等价于git commit --amend
$ git reset --mixed //default 参数，将commit的修改，放到stage区
$ git reset --hard //update working copy

//squashing
$ git reset --soft HEAD~2
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-rm-git-rm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-rm"></a>git rm</h4>
<pre><code class="language-source-shell">$ git rm [filename]

//keep the file in your working tree but remove it from your staging area.
$ git rm --cached filename
</code></pre>
<h4><a id="https-github-combaiduhideviosgit-git-tag-git-tag" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/BaiduHiDeviOS/Git#git-tag"></a>git tag</h4>
<pre><code class="language-source-shell">打标签,tag默认在本地，必须显示的push到服务器
$ git tag v1.0
$ git tag v0.9 commit-id
$ git tag -a v0.1 -m &quot;version 0.1 released&quot; commit-id
$ git push origin v1.0 //推送标签到远程服务器
$ git push origin --tags //一次性推送全部尚未推送到远程的本地标签

//删除标签
//1.删除本地
$ git tag -d v0.9
//2.推送到远程
$ git push origin :refs/tags/v0.9
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402944658.html">CocaPods 添加头文件的报错  的解决办法</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在buildsetting中的以下两个路径中添加对应的设置，重现编译即可解决，stackoverflow地址：<a href="https://stackoverflow.com/questions/45779591/failed-to-emit-precompiled-header-for-bridging-header?answertab=votes#tab-top">Failed to emit precompiled header for bridging header</a></p>
<pre><code class="language-plain_text">Solution:
1 I added $(inherited) non-recursive to Search Path -&gt; Header Search Paths
2 Then added ${PODS_ROOT} recursive to Search Path -&gt; User Header Search Paths
Both the above in my projects' target build settings.
</code></pre>
<p><img src="media/16587402944658/15374225919741.jpg" alt="" style="width:794px;" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402944819.html">== 和 equals 区别</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>== 运算符</h2>
<ol>
<li>可以使用在基本数据类型变量和引用数据类型变量中</li>
<li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（类型不一定要相同）</li>
<li>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</li>
</ol>
<h2><a id="equals%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>equals() 方法</h2>
<ol>
<li>
<p>是一个方法，而非运算符</p>
</li>
<li>
<p>只能适用于引用数据类型</p>
</li>
<li>
<p>Object类中的equals()的定义：</p>
<pre><code class="language-plain_text">public boolean equals(Object obj) {
    return (this == obj);
}

// 说明： Object类中定义的equals()和==的作用相同，都是比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体
</code></pre>
</li>
<li>
<p>像String、Date、File、包装类等都重写了equals()方法。重写后比较的不是两个引用的地址是否相同，而是比较两个对象的实体内容是否相同。</p>
</li>
</ol>
<p><img src="media/16587402944819/IMG_683329D78264-1.jpeg" alt="IMG_683329D78264-1" /></p>
<p>自动装箱中Integer内部定义了IntegerCache结构,IntegerCache中有Integer[],保存了-128到127范围内的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在-128到127中时，可以直接使用数组中的元素，不用再去new了。目的：提高效率</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402944946.html">点菜逻辑梳理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##同步逻辑(全量上传):<br />
原定: 切台\转台 全量上传<br />
现在: 轮询即上传(每次轮询信息都走这个接口),切台/轮询同样走这个接口<br />
##关于延时<br />
12.27泽祥刚跟海底捞确定逻辑和备注一致即这道菜如果半份延时了再次点这道菜不论整份半份都是延时的.<br />
##整份半份显示(如果新需求的话,可能还需要改变正在和泽祥确定中)<br />
需求:点菜点锅界面菜品包含整份与半份 购物车界面整份与半份是分开的.</p>
<p>目前的做法: 购物车等地方如果调用<code>-(NSArray *)getLocalDishArray </code>这个操作会把数据拆分成整份半份给调用者.但是在点菜点锅页面,我会调用<code>configLocalDishArray</code> 这个操作会把整份半份整合成一个菜给调用者</p>
<p>##关于估清<br />
原有逻辑就是根据数据库中获取菜品信息进行估清操作判断的,<strong>目前</strong>的逻辑是这样的,数据库返回字段和轮询回来的估清数据中只要有一个是估清就显示估清,显示需要调用<code>-(BOOL)judgeIsSellOutWithDish:(HTDishEntity *)dish</code></p>
<p>##关于已点<br />
新加菜&amp;已下单数据只要一个地方有该菜品都显示已点<code>-(BOOL)haveOrderThisDish:(NSString *)dishid </code></p>
<p>##匹配菜品中整份半份数量<br />
<code>-(nonnull HTDishEntity *)configNumberOfDish:(nonnull HTDishEntity *)dish </code><br />
会计算未下单数据中所有整份半份数量</p>
<p>##延时倍增拆分等操作<br />
这里需要的菜品都是通过<code>getLocalDishArray</code>来获取否则有问题,详细逻辑大伟比较清楚</p>
<p>##目前问题<br />
如果某一道菜设置延时了,将来这道菜每次进行数量的加减时都要同步到服务器,这个操作会不会导致网络请求发送比较频繁<br />
点锅后,使用最新的同步接口延时太久.吃饭前同步的数据,中午午休后发现数据回来了...点菜的数据同步很快..这个是接口用错了还是后台接口需要调整?</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402945082.html">为项目添加podspec</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>全文来自:<a href="http://www.jianshu.com/p/d7d1942dd3f1">iOS开发-- 创建podspec文件，为自己的项目添加pod支持</a> 只是在文章中添加了原文没有说明的东西&amp;步骤</p>
</blockquote>
<p>##1.clone项目源码<br />
项目如果没有在github仓库中,先上传到github仓库,然后clone到本地,已经存在就直接clone到本地</p>
<pre><code class="language-plain_text">// cd 到 想要存放项目的文件夹中执行
git clone https://github.com/Mekor/MKScanner.git
</code></pre>
<p><code>https://github.com/Mekor/MKScanner.git</code>这个是我自己的仓库,这个仓库地址可以在这里找到<br />
<img src="media/16587402945082/Snip20160705_4.png" alt="Snip20160705_4" /><br />
##2. 创建项目的podspec文件</p>
<p>•	用终端命令cd到本地项目目录并执行如下命令:</p>
<pre><code class="language-plain_text">$ pod spec create MKScanner
</code></pre>
<p>MKScanner替换为自己的项目名称,这时在本地就会生成一个MKScanner.podspec</p>
<p>•	用编辑器打开.podspec文件 (我自己用Sublime Text)<br />
删除不必要的注释(这里只简单介绍基本用法，所以只用到一部分必须得字段 更多字段请移步<a href="http://guides.cocoapods.org/syntax/podspec.html">http://guides.cocoapods.org/syntax/podspec.html</a></p>
<pre><code class="language-plain_text">Pod::Spec.new do |s|

  s.name                 = &quot;MKScanner&quot;
  s.version              = &quot;0.0.1&quot;
  s.summary              = &quot;QRCode Scanner&quot;
  s.homepage             = &quot;https://github.com/Mekor/MKScanner&quot;
  s.license              = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; }
  s.author             = { &quot;Mekor&quot; =&gt; &quot;mekor@live.cn&quot; }
  s.social_media_url   = &quot;http://weibo.com/gliii&quot;
  s.platform             = :ios, &quot;7.0&quot;
  s.source               = { :git =&gt; &quot;https://github.com/Mekor/MKScanner.git&quot;, :tag =&gt; s.version }
  s.source_files          = &quot;MKScanner/**/*.{h,m}&quot;
  #s.resources          = &quot;MKScanner/**/*.png&quot;
  s.requires_arc         = true

end
</code></pre>
<p>•	验证podspec文件</p>
<p>编辑完podspec文件后需要验证一下这个文件是否可用podspec文件不允许有任何的Warning或者Error<br />
执行命令</p>
<pre><code class="language-plain_text">$ pod lib lint
</code></pre>
<p>如果出现</p>
<pre><code class="language-plain_text">-&gt; MKScanner (0.0.1)
MKScanner passed validation.
</code></pre>
<p>则说明验证通过， 否则， 根据提示修改podspec文件再次验证直到验证通过<br />
附带说一下，Xcode允许警告存在，所以可以通过命令屏蔽警告</p>
<pre><code class="language-plain_text">$ pod lib lint --allow-warnings
</code></pre>
<p>如果出现Error但是提示信息不足，可以添加--verbose 以获取更多错误信息</p>
<pre><code class="language-plain_text">$ pod lib lint --verbose
</code></pre>
<p>##3. 打tag 上传podspec</p>
<p>podspec文件中需要指定的tag， 完成上述操作后给项目打tag</p>
<pre><code class="language-plain_text">$ git tag -m&quot;first release MKScanner with podspec&quot; &quot;0.0.1&quot;
$ git push --tags

</code></pre>
<p>最后使用pod trunk命令，把podspec文件推送到CocoaPod官方库<br />
pod trunk 需要注册,参见:<a href="https://guides.cocoapods.org/making/getting-setup-with-trunk.html">https://guides.cocoapods.org/making/getting-setup-with-trunk.html</a><br />
其实很简单:</p>
<pre><code class="language-plain_text">pod trunk register Mekor@live.cn &quot;Mekor&quot;
</code></pre>
<p>指明你的邮箱地址（spec文件中的）和名称<br />
CocoaPods 会给你填写的邮箱发送验证邮件，点击邮件中的链接就可通过验证。<br />
pod trunk 设置完毕后执行命令</p>
<pre><code class="language-plain_text">$ pod trunk push MKScanner.podspec
</code></pre>
<p>这个过程可能会比较耗时，原因你懂的<br />
##4. 最后<br />
如果一切顺利</p>
<pre><code class="language-plain_text">pod search MKScanner
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402945208.html">Flutter 中 listView 嵌套 listView</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402945208/Simulator%20Screen%20Shot%20-%20iPhone%2012%20-%202021-07-20%20at%2016.18.53.png" alt="Simulator Screen Shot - iPhone 12 - 2021-07-20 at 16.18.53" /></p>
<p>实现上述嵌套效果只需要在里面的listView中使用</p>
<pre><code class="language-plain_text">      shrinkWrap: true,
      physics: NeverScrollableScrollPhysics(),
</code></pre>
<p><img src="media/16587402945208/16267694115272.jpg" alt="" style="width:498px;" /><br />
被嵌套的listView<br />
<img src="media/16587402945208/16267694690429.jpg" alt="" style="width:637px;" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402945339.html">iOS10 遇到问题总结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>iOS10 用户权限设置新增，在info.plist文件中，新增字段：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>相册权限</td>
<td>Privacy - Photo Library Usage Description</td>
<td>string类型的文字说明</td>
</tr>
<tr>
<td>相机权限</td>
<td>NSCameraUsageDescription</td>
<td>string类型的文字说明</td>
</tr>
<tr>
<td>麦克风权限</td>
<td>NSMicrophoneUsageDescription</td>
<td>string类型的文字说明</td>
</tr>
<tr>
<td>定位权限</td>
<td>NSLocationWhenInUseUsageDescription</td>
<td>string类型的文字说明</td>
</tr>
</tbody>
</table>
<p>iOS10 新用户下载app，使用以上前3种权限，如果不添加授权描述，会导致程序崩溃</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402945459.html">后台代码阅读</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>目前柑橘不合理的地方</p>
<p><img src="media/16587402945459/15428690706690.jpg" alt="" style="width:1120px;" /><br />
如果参数为<code>tableBillId</code>的时候不应该判空两次，我认为应该加else</p>
<p>数组 和 List 的区别，数组是不能新增不能删除的，List 可以<br />
Arrays.saList 是特殊的List 不能新增不能删除</p>
<p>下面圈起来的代码，判断不成立<br />
<img src="media/16587402945459/1661542867380_.pic_hd.jpg" alt="1661542867380_.pic_hd" /></p>
<p>下面代码只写if会导致有重复的菜品的话会记录重复的dishID, 然后会查多次数据库<br />
<img src="media/16587402945459/15428862968945.jpg" alt="" style="width:1058px;" /></p>
<p>数据库写法不统一<br />
<img src="media/16587402945459/15429575575922.jpg" alt="" style="width:1220px;" /></p>
<p>模块不清晰，模型都堆积在一起，不容易区分（C2B，Shop。。。）都混在一起。如果按模块区分会便于阅读</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402945590.html">解决UILabel 末尾的空格被忽略</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>看到这篇文章<a href="https://www.lidaren.com/archives/1333">UILabel取消自动Trim空格和换行等空白字符</a></p>
<pre><code class="language-plain_text">UILabel会自动清除的空白字符（UNICODE）
\u0009 CHARACTER TABULATION
\u000A LINE FEED
\u000D CARRIAGE RETURN
\u0020 SPACE
\u0085 NEXT LINE
\u00A0 NBSP
\u1680 OGHAM SPACE MARK
\u180E MONGOLIAN VOWEL SEPARATOR
\u2000 EN QUAD
\u200A HAIR SPACE
\u200B ZERO WIDTH SPACE
\u2028 LINE SEPARATOR
\u2029 PARAGRAPH SEPARATOR
\u202F NARROW NO-BREAK SPACE
\u205F MEDIUM MATHEMATICAL SPACE
\u3000 IDEOGRAPHIC SPACE
</code></pre>
<p>解决方案</p>
<pre><code class="language-plain_text">    let paragraphStyle = NSMutableParagraphStyle()
    paragraphStyle.alignment = .right
    paragraphStyle.tailIndent = -10
    let myMutableString = NSMutableAttributedString(
        string: text,
        attributes: [
            NSAttributedStringKey.font: UIFont.systemFont(ofSize: 16),
            NSAttributedStringKey.paragraphStyle: paragraphStyle
        ]
    )
    label.attributedText = myMutableString
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402945839.html">字符串frame相关</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>开发中常用到计算字符串的size或者rect</p>
<p>经常见到如下接口:</p>
<pre><code class="language-plain_text">- (CGSize)sizeWithAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs NS_AVAILABLE(10_0, 7_0);

- (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context NS_AVAILABLE(10_11, 7_0);
</code></pre>
<p>项目中使用的例子:</p>
<pre><code class="language-plain_text">    // shopNameLabel frame
    {
        CGSize stringSize = [self.shopNameLabel.text sizeWithAttributes:@{NSFontAttributeName: self.shopNameLabel.font}];
        self.shopNameLabel.frame = CGRectMake(margin, margin, ceil(stringSize.width), ceil(stringSize.height));
    }
</code></pre>
<pre><code class="language-plain_text">    // addressLabel frame
    {
        CGFloat lwidth = width - imageWH - 3*margin;
        
        CGSize stringSize = [self.addressLabel.text boundingRectWithSize:CGSizeMake(lwidth, self.addressLabel.font.lineHeight *self.addressLabel.numberOfLines) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName: self.addressLabel.font} context:nil].size;
        self.addressLabel.frame = CGRectMake(margin, ceil(CGRectGetMaxY(self.juliLabel.frame) + margin), stringSize.width, stringSize.height);
    }

</code></pre>
<p>由于经常使用,所以我把这些都抽取成代码块,方便调用.</p>
<p>其中由于需要预估字符串的高度,<code>boundingRectWithSize</code>,由于iOS所提供的默认字体是可能变化的,所以这里我们不能凭借经验10号字体默认高度就是10,这是不准确的.使用<code>self.addressLabel.font.lineHeight</code>应该使用行高来计算.并且显示的行数也不要写死,需要写成 <code>self.addressLabel.numberOfLines</code>.这样做才能得到想要的效果.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402945965.html">Swift - 春节前问题总结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>
<p><code>#selector集中起来管理</code><br />
参考<a href="http://weibo.com/3321824014/ErQJDdL4L?type=repost#_rnd1486189248963">微博</a>中第二点<br />
<img src="media/16587402945965/14861893764185.jpg" alt="" /></p>
</li>
<li>
<p>关于Xib的使用问题<br />
老生常谈的问题了,看个人喜好,不过尽量让其他人看懂,遵守xib规范.<br />
备注:<br />
1. <a href="http://nshipster.cn/ibinspectable-ibdesignable/">IBInspectable / IBDesignable</a><br />
2. <a href="http://tips.producter.io/you-ya-di-zi-ding-yi-xibview/">优雅地自定义XibView</a></p>
</li>
<li>
<p>关于什么时候提取出方法<br />
一个函数如果行数过长不便于阅读,可以按照步骤抽取出字方法<br />
如果一个功能有2个以上地方用到需要抽取为一个方法</p>
</li>
<li>
<p>多种样式Cell如何配置</p>
</li>
</ol>
<p>撕逼未完....</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402946094.html">如何获取手机上安装的所有App</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-plain_text">#include &lt;objc/runtime.h&gt; 

Class LSApplicationWorkspace_class = objc_getClass(&quot;LSApplicationWorkspace&quot;);
NSObject* workspace = [LSApplicationWorkspace_class performSelector:@selector(defaultWorkspace)];
NSLog(@&quot;apps: %@&quot;, [workspace performSelector:@selector(allApplications)]);
</code></pre>
<p>模拟器打印结果:</p>
<pre><code class="language-plain_text">apps: (
    &quot;&lt;LSApplicationProxy: 0x7fbd34603da0&gt; com.apple.appleaccount.AACredentialRecoveryDialog file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/AACredentialRecoveryDialog.app &lt;com.apple.appleaccount.AACredentialRecoveryDialog &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd383073a0&gt; com.apple.AccountAuthenticationDialog file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/AccountAuthenticationDialog.app &lt;com.apple.AccountAuthenticationDialog &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd38308a00&gt; com.apple.AdSheetPhone file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/AdSheet.app &lt;com.apple.AdSheetPhone &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd38308df0&gt; com.apple.Bridge file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Bridge.app &lt;com.apple.Bridge &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd38308fe0&gt; com.apple.camera file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Camera.app &lt;com.apple.camera &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34503d80&gt; com.apple.MobileAddressBook file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Contacts.app &lt;com.apple.MobileAddressBook &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34605980&gt; com.apple.CoreAuthUI file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/CoreAuthUI.app &lt;com.apple.CoreAuthUI &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd346062f0&gt; com.apple.DataActivation file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/DataActivation.app &lt;com.apple.DataActivation &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34606730&gt; com.apple.datadetectors.DDActionsService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/DDActionsService.app &lt;com.apple.datadetectors.DDActionsService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34606f60&gt; com.apple.FacebookAccountMigrationDialog file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/FacebookAccountMigrationDialog.app &lt;com.apple.FacebookAccountMigrationDialog &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd346074c0&gt; com.apple.gamecenter.GameCenterUIService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/GameCenterUIService.app &lt;com.apple.gamecenter.GameCenterUIService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34607b10&gt; com.apple.siri.parsec.HashtagImagesApp file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/HashtagImages.app &lt;com.apple.siri.parsec.HashtagImagesApp &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34608040&gt; com.apple.Health file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Health.app &lt;com.apple.Health &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd346085d0&gt; com.apple.HealthPrivacyService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/HealthPrivacyService.app &lt;com.apple.HealthPrivacyService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34608f70&gt; com.apple.Home.HomeUIService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/HomeUIService.app &lt;com.apple.Home.HomeUIService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd346093c0&gt; com.apple.iad.iAdOptOut file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/iAdOptOut.app &lt;com.apple.iad.iAdOptOut &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd346095b0&gt; com.apple.CloudKit.ShareBear file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/iCloud.app &lt;com.apple.CloudKit.ShareBear &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460a060&gt; com.apple.iCloudDriveApp file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/iCloudDriveApp.app &lt;com.apple.iCloudDriveApp &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460a4b0&gt; com.apple.LoginUI file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/LoginUI.app &lt;com.apple.LoginUI &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460a9f0&gt; com.apple.MailCompositionService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/MailCompositionService.app &lt;com.apple.MailCompositionService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460ae80&gt; com.apple.Maps file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Maps.app &lt;com.apple.Maps &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460b3e0&gt; com.apple.mobilesms.compose file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/MessagesViewService.app &lt;com.apple.mobilesms.compose &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460bb00&gt; com.apple.mobilecal file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/MobileCal.app &lt;com.apple.mobilecal &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460bf50&gt; com.apple.mobilesafari file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/MobileSafari.app &lt;com.apple.mobilesafari &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460c4e0&gt; com.apple.mobileslideshow file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/MobileSlideShow.app &lt;com.apple.mobileslideshow &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460c8d0&gt; com.apple.MobileSMS file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/MobileSMS.app &lt;com.apple.MobileSMS &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460cac0&gt; com.apple.MusicUIService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/MusicUIService.app &lt;com.apple.MusicUIService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460d520&gt; com.apple.news file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/News.app &lt;com.apple.news &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460dc70&gt; com.apple.Passbook file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Passbook.app &lt;com.apple.Passbook &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460e0c0&gt; com.apple.PassbookUIService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/PassbookUIService.app &lt;com.apple.PassbookUIService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460e510&gt; com.apple.PhotosViewService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/PhotosViewService.app &lt;com.apple.PhotosViewService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460eaf0&gt; com.apple.Preferences file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Preferences.app &lt;com.apple.Preferences &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460ece0&gt; com.apple.PrintKit.Print-Center file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Print%20Center.app &lt;com.apple.PrintKit.Print-Center &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460abe0&gt; com.apple.reminders file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Reminders.app &lt;com.apple.reminders &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460f790&gt; com.apple.SafariViewService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/SafariViewService.app &lt;com.apple.SafariViewService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd3460ffc0&gt; com.apple.ServerDocuments file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/ServerDocuments.app &lt;com.apple.ServerDocuments &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34610580&gt; com.apple.SharedWebCredentialViewService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/SharedWebCredentialViewService.app &lt;com.apple.SharedWebCredentialViewService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34610ab0&gt; com.apple.SharingViewService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/SharingViewService.app &lt;com.apple.SharingViewService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34610ca0&gt; com.apple.SiriViewService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/SiriViewService.app &lt;com.apple.SiriViewService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34610e90&gt; com.apple.social.SLGoogleAuth file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/SLGoogleAuth.app &lt;com.apple.social.SLGoogleAuth &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd345016b0&gt; com.apple.social.SLYahooAuth file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/SLYahooAuth.app &lt;com.apple.social.SLYahooAuth &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34501370&gt; com.apple.share file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/SocialUIService.app &lt;com.apple.share &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34507a80&gt; com.apple.ios.StoreKitUIService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/StoreKitUIService.app &lt;com.apple.ios.StoreKitUIService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34507c70&gt; com.apple.TencentWeiboAccountMigrationDialog file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/TencentWeiboAccountMigrationDialog.app &lt;com.apple.TencentWeiboAccountMigrationDialog &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34507e60&gt; com.apple.TrustMe file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/TrustMe.app &lt;com.apple.TrustMe &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd346123f0&gt; com.apple.VSViewService file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/VideoSubscriberAccountViewService.app &lt;com.apple.VSViewService &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34612c30&gt; com.apple.webapp file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/Web.app &lt;com.apple.webapp &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd346133b0&gt; com.apple.webapp1 file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/WebApp1.app &lt;com.apple.webapp1 &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34613fa0&gt; com.apple.WebContentFilter.remoteUI.WebContentAnalysisUI file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/WebContentAnalysisUI.app &lt;com.apple.WebContentFilter.remoteUI.WebContentAnalysisUI &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd34614930&gt; com.apple.WebSheet file:///Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/Applications/WebSheet.app &lt;com.apple.WebSheet &lt;installed &gt;&gt;&quot;,
    &quot;&lt;LSApplicationProxy: 0x7fbd346151b0&gt; cn.citynight.----- file:///Users/mekor/Library/Developer/CoreSimulator/Devices/F9CC59DD-6467-40E5-B0AE-F7EDDD22C612/data/Containers/Bundle/Application/0F126D14-F359-4D63-AEE7-B569519AC04F/%E5%85%91%E6%8D%A2%E5%88%B8%E6%B5%8B%E8%AF%95.app &lt;cn.citynight.----- &lt;installed &gt;&gt;&quot;
)

</code></pre>
<p>动态调用加上简单的混淆应该就可以了<br />
上架要自己拼接字符串绕过审查</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402946228.html">Texture  中ASButtonNode设置图片崩溃</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>解决方案：<img src="media/16587402946228/WX20190523-110605@2x.png" alt="WX20190523-110605@2x" /></p>
<p>Assets中的图片Slicing 设置<code>Center</code>为<code>Stretches</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402946396.html">节流防抖</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>节流和防抖演示网站： <a href="http://demo.nimius.net/debounce_throttle/">http://demo.nimius.net/debounce_throttle/</a></p>
<p><strong>防抖 Debounce</strong></p>
<p>防抖的情况，有点像一个极度珍惜 执行机会的人，只要时间段内，有任务来，就再等一会。<br />
等到最后一次，超过一定时间，确定没有新任务了，才去做执行。<br />
1. 列表刷新，为避免短时间内反复 reload，可以多次合并为一次<br />
2. TCP 流量控制</p>
<p><strong>节流 Throttle</strong></p>
<p>节流比较好理解，在一定时间段内，丢弃掉其它触发，就做一次执行<br />
1. 防止多次点击<br />
2. 重复发多个网络请求</p>
<pre><code class="language-plain_text">import Foundation

/// 防抖
public class Debouncer {
    public let label: String
    public let interval: DispatchTimeInterval
    private let queue: DispatchQueue
    private let semaphore: DispatchSemaphoreWrapper
    private var workItem: DispatchWorkItem?
    
    
    public init(label: String, interval: Float, qos: DispatchQoS = .userInteractive) {
        self.interval         = .milliseconds(Int(interval * 1000))
        self.label         = label
        self.queue = DispatchQueue(label: &quot;cn.citynight.debouncer.internalqueue.\(label)&quot;, qos: qos)
        self.semaphore = DispatchSemaphoreWrapper(withValue: 1)
    }
    
    
    public func call(_ callback: @escaping (() -&gt; ())) {
        
        self.semaphore.sync  { () -&gt; () in
            
            
            self.workItem?.cancel()
            
            self.workItem = DispatchWorkItem {
                callback()
            }
            
            if let workItem = self.workItem {
                
                self.queue.asyncAfter(deadline: .now() + self.interval, execute: workItem)
            }
        }
    }
    
}
 

/// 节流
public class Throttler {
    
    private let queue: DispatchQueue = DispatchQueue.global(qos: .background)
    
    private var job: DispatchWorkItem = DispatchWorkItem(block: {})
    private var previousRun: Date = Date.distantPast
    private var maxInterval: Int
    private let semaphore: DispatchSemaphoreWrapper
    
    init(seconds: Int) {
        self.maxInterval = seconds
        self.semaphore = DispatchSemaphoreWrapper(withValue: 1)
    }
    
    
    func throttle(block: @escaping () -&gt; ()) {
        
        self.semaphore.sync  { () -&gt; () in
            job.cancel()
            job = DispatchWorkItem(){ [weak self] in
                self?.previousRun = Date()
                block()
            }
            let delay = Date.second(from: previousRun) &gt; maxInterval ? 0 : maxInterval
            queue.asyncAfter(deadline: .now() + Double(delay), execute: job)
        }
        
    }
}
 

/// DispatchSemaphore保证线程安全
public struct DispatchSemaphoreWrapper {
    
    private let semaphore: DispatchSemaphore
    
    public init(withValue value: Int) {
        
        self.semaphore = DispatchSemaphore(value: value)
    }
    
    public func sync&lt;R&gt;(execute: () throws -&gt; R) rethrows -&gt; R {
        
        _ = semaphore.wait(timeout: DispatchTime.distantFuture)
        defer { semaphore.signal() }
        return try execute()
    }
}

private extension Date {
    static func second(from referenceDate: Date) -&gt; Int {
        return Int(Date().timeIntervalSince(referenceDate).rounded())
    }
}

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402946533.html">**问题锅底的排查方案**</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><strong>目前的缺少的信息:</strong>  不清楚是PAD端可能存在未知业务逻辑错误,还是 PAD 内存调用异常.</p>
<p>##排查需要的资料:</p>
<ol>
<li>错误复现时所用的数据库, 因为锅型是从数据库读取的</li>
<li>需要对应的后台请求日志, 查看错误锅底下单的数据.查找错误信息</li>
<li>需要了解错误锅底对应的口味,备注是否正确</li>
</ol>
<p>##pad端需要做的:</p>
<p>###如果是操作出现的问题(埋点):<br />
记录所有的用户操作步骤,写入本地, 需要写入的有操作时间,根据时间可以找到有问题的步骤操作<br />
如果出现锅底异常把pad日志发送到总部服务器</p>
<p>###如果是内存出现的问题:<br />
这个的可能性很大,检测数据内容变化</p>
<p>##排查重点:</p>
<ol>
<li>在做好操作步骤记录的情况下,主要检测在构建锅底下单信息的时候有没有更改锅底数据,那些操作会导致更改锅底数据</li>
<li>千人千味页面和锅底下单页面之间锅底数据传递</li>
</ol>
<p>日志格式:  日期 - 控制器 - 函数名 - 行号 - 当前的锅型 - 操作的底料 - 备注</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402946695.html">怎样让内存缓存变稳定</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>项目中如果显示图片比较多,会遇到内存涨的比较厉害,项目中用到 SDWebImage, 所以可以很简单的让内存缓存变稳定:</p>
<pre><code class="language-plain_text">-(void)scrollViewDidScroll:(UIScrollView *)scrollView {
    [[SDImageCache sharedImageCache] clearMemory];
}
</code></pre>
<p>原理:</p>
<pre><code class="language-plain_text">- (void)clearMemory {
    [self.memCache removeAllObjects];
}
</code></pre>
<p>_memCache 是 NSCache 类型的,</p>
<p>没有做任何操作的时候大概是这个样子的<br />
<img src="media/16587402946695/14752174866625.jpg" alt="" /></p>
<p>添加clearMemory后:<br />
<img src="media/16587402946695/14752177858503.jpg" alt="" /></p>
<p>这也是为什么滚动后屏幕上还显示图片的原因.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402946851.html">Swift - 函数</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##函数的几种情况</p>
<pre><code class="language-plain_text">// 正常
func sum(x:Int, y:Int) -&gt; Int {
    return x+y
}
print(sum(x: 10, y: 20))

// 去掉形参
func sum(_ x:Int,_ y:Int) -&gt; Int {
    return x+y
}
print(sum(10, 20))

// 外部参数
func sum(num1 x:Int,num2 y:Int) -&gt; Int {
    return x+y
}
print(sum(num1: 10, num2: 20))

// 函数带默认值
func sum(x:Int = 1, y:Int = 2) -&gt; Int {
    return x+y
}
print(sum())
</code></pre>
<p>##闭包</p>
<blockquote>
<p>闭包类似于OC中的block,但应用更广. 与OC对比, OC中block是特殊的函数,在Swift中函数是特殊的闭包</p>
</blockquote>
<pre><code class="language-plain_text">// 最简单的闭包
// 定义
let foo = {
    print(&quot;最简单的闭包&quot;)
}
// 调用
foo()

// 带参数无返回值
let foo = { (x:Int) -&gt; () in
    print(x)
}
foo(100)

// 带参数有返回值
let foo = { (x:Int) -&gt; Int in
    return x+1
}
foo(10)
</code></pre>
<p>block常用在异步执行,回调...Swift中异步跟OC稍微有些区别.<br />
###模拟异步加载</p>
<pre><code class="language-plain_text">    /// 加载数据
    func loadData(completion:@escaping (_ result: [String])-&gt;()) {
        
        DispatchQueue.global().async {
            print(&quot;耗时操作\(Thread.current)&quot;)
            
            DispatchQueue.main.async {
                print(&quot;主线程更新\(Thread.current)&quot;)
                let json = [&quot;头条&quot;,&quot;八卦&quot;,&quot;出大事了&quot;]
                completion(json)
            }
        }
    }
</code></pre>
<p>注:关于**@escaping**参见 Swifter 中<code>@escaping</code></p>
<p>###尾随闭包</p>
<pre><code class="language-plain_text">        // 如果函数的最后一个参数是闭包,函数参数可以提前结束,最后一个参数直接使用{}包装闭包的代码
        loadData { (JSON) in
            print(JSON)
        }

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402946984.html">@Slf4j注解实现日志输出</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>最近看到B站上有人写代码没有定义log(<code>private final Logger log = LoggerFactory.getLogger(XXX.class);</code>)就能直接用<code>log</code></p>
<p>查了下可能的方案:</p>
<ol>
<li>pom引入 <code>lombok</code></li>
</ol>
<pre><code class="language-plain_text">            &lt;dependency&gt;
                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
                &lt;artifactId&gt;lombok&lt;/artifactId&gt;
                &lt;version&gt;${lombok.version}&lt;/version&gt;
                &lt;optional&gt;true&lt;/optional&gt;
            &lt;/dependency&gt;
</code></pre>
<ol>
<li>在目标类上添加<code>@Slf4j</code>注解</li>
<li>然后直接在方法中使用<code>log.info(&quot;*****插入结果：&quot;+result);</code></li>
<li>如果使用的时候没有找到变量<code>log</code>,IDEA需要安装lombok插件</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402947119.html">flutter 多环境设置</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Flutter开发中我们需要切换不同的环境进行数据处理</p>
<h2><a id="%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原理</h2>
<p>根据Dart-Define进行参数控制</p>
<p>具体接收参数的实现在 env_config.dart 文件中</p>
<p>代码如下：<img src="media/16587402947119/image2021-6-25%2019_15_8.png" alt="image2021-6-25 19_15_8" /></p>
<h2><a id="%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传递参数</h2>
<p>我们可以直接输入命令行进行运行，可以使用shell进行脚本封装，也可以使用开发工具进行设置。</p>
<h3><a id="shell%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shell脚本启动方式</h3>
<p>已经写好了简单的执行脚本位置如下：</p>
<p><img src="media/16587402947119/image-20210625182202555.png" alt="image-20210625182202555" /></p>
<p><strong>使用方式</strong></p>
<ol>
<li>
<p>先赋予脚本读、执行权限 <code>chmod 755 ./scripts/run.sh</code></p>
</li>
<li>
<p>执行对应的脚本</p>
<pre><code class="language-shell"># 开发环境
./script/run.sh dev
# 测试环境
./script/run.sh test
# 发布环境
./script/run.sh release
</code></pre>
<p>当然也可以直接在命令行中直接输入运行。</p>
<h3><a id="%E4%BD%BF%E7%94%A8android-studio%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用Android Studio 进行设置</h3>
</li>
<li>
<p>编辑配置信息<img src="media/16587402947119/image-20210625171212841.png" alt="image-20210625171212841" /></p>
</li>
<li>
<p>设置参数<img src="media/16587402947119/image-20210625171413373.png" alt="image-20210625171413373" /></p>
</li>
<li>
<p>设置其他环境的参数<img src="media/16587402947119/image-20210625181701520.png" alt="image-20210625181701520" /></p>
</li>
<li>
<p>配置完成<img src="media/16587402947119/image-20210625181827464.png" alt="image-20210625181827464" /></p>
</li>
<li>
<p>开发中选择对应的环境执行<br />
<img src="media/16587402947119/image-20210625182807269.png" alt="image-20210625182807269" /></p>
</li>
</ol>
<h3><a id="vscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>VSCode环境配置</h3>
<p><img src="media/16587402947119/image-20210625184614465.png" alt="image-20210625184614465" /></p>
<p>执行的时候选择对应的环境进行执行</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402947544.html">控制器透明，WebView透明</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>设置控制器透明</p>
<pre><code class="language-plain_text">let vc = AfterOrderPotADViewController()
self.definesPresentationContext = true
vc.modalPresentationStyle = .overCurrentContext
vc.view.backgroundColor = UIColor(red: 0, green: 0, blue: 0, alpha: 0.3)
self.present(vc, animated: false, completion: nil)
</code></pre>
<p>webView 设置透明</p>
<pre><code class="language-plain_text">webView.backgroundColor = UIColor.clear
webView.isOpaque = false
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402947694.html">AFN3.0 如何实现operation.responseString</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>我在AFNetworking issues中的回答<a href="https://github.com/AFNetworking/AFNetworking/issues/3551">how to get response body in failure block?</a>还有<br />
<a href="https://github.com/AFNetworking/AFNetworking/issues/3534">How can i get responseString which at AFNetworking 3.0</a></p>
<p>发现还有好多朋友还不清楚如何实现,其实很简单</p>
<pre><code class="language-plain_text">NSError *underError = error.userInfo[@&quot;NSUnderlyingError&quot;];
NSData *responseData = underError.userInfo[@&quot;com.alamofire.serialization.response.error.data&quot;];
</code></pre>
<p>有小伙伴问我<code>com.alamofire.serialization.response.error.data</code>是怎么来的,原来都是AFJSONResponseSerializer解析修改成<code>manager.responseSerializer = [AFHTTPResponseSerializer serializer];</code>这样报错的时候就会看到控制台打印的信息里面有<code>com.alamofire.serialization.response.error.data</code>后面输出responseData...然后才有了上面的解决办法</p>
<p><strong>-----16.6.7更-----</strong><br />
作者回复中已经添加了相关操作<br />
在<code>AFURLResponseSerialization</code><br />
可以在 failure block 中添加下面代码获取responseString</p>
<pre><code class="language-plain_text">NSData *data = error.userInfo[AFNetworkingOperationFailingURLResponseDataErrorKey];
</code></pre>
<p>具体代码:</p>
<pre><code class="language-plain_text">/**
 ## User info dictionary keys

 These keys may exist in the user info dictionary, in addition to those defined for NSError.

 - `NSString * const AFNetworkingOperationFailingURLResponseErrorKey`
 - `NSString * const AFNetworkingOperationFailingURLResponseDataErrorKey`

 ### Constants

 `AFNetworkingOperationFailingURLResponseErrorKey`
 The corresponding value is an `NSURLResponse` containing the response of the operation associated with an error. This key is only present in the `AFURLResponseSerializationErrorDomain`.

 `AFNetworkingOperationFailingURLResponseDataErrorKey`
 The corresponding value is an `NSData` containing the original data of the operation associated with an error. This key is only present in the `AFURLResponseSerializationErrorDomain`.
 */
FOUNDATION_EXPORT NSString * const AFNetworkingOperationFailingURLResponseErrorKey;

FOUNDATION_EXPORT NSString * const AFNetworkingOperationFailingURLResponseDataErrorKey;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402947865.html">数据存储</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>UserDefaut     存储简单的数据结构<br />
FileManager    存储复杂量级较大的文件<br />
Sqilte         依赖 libsqlite3.dylib<br />
CoreData       数据变更管理、对象存储、对象读取</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402948145.html">项目优化记录</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>首页显示</h2>
<p>重点: 数据处理放在获取数据的时候,尽管这样数据不会实时更新,但是保证了数据显示的速度.<br />
关于Cache, 目前使用数据库.关于异步访问要用 <code>safeAsync</code></p>
<pre><code class="language-plain_text">extension DispatchQueue {
    // This method will dispatch the `block` to self.
    // If `self` is the main queue, and current thread is main thread, the block
    // will be invoked immediately instead of being dispatched.
    func safeAsync(_ block: @escaping ()-&gt;()) {
        if self === DispatchQueue.main &amp;&amp; Thread.isMainThread {
            block()
        } else {
            async { block() }
        }
    }
}
</code></pre>
<h2><a id="topbar%E7%A7%BB%E9%99%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Topbar 移除</h2>
<p>这个原有的导航对项目入侵太深,已经忍无可忍了...这周终于下决心移除它用原生的导航栏和自定义视图代替她..进展非常顺利.写了一天自定义控件,然后让大家各自把自己的控制过滤一遍.总耗时,我自己一天,其他同事不到1个小时.还是非常顺利的.用比较少的时间完成了项目中的毒瘤.</p>
<h2><a id="%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%B0%81%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>下拉刷新封装</h2>
<p>老版本使用的是<code>MJRefresh</code> 但是需要定制, 在老项目中我是通过继承完成的功能修改,这样做的原因是老项目是OC和Swift混编的,而且都是把第三方库源文件拖到项目中的方式进行的. 在重构的时候我把第三方库放到了公司的git上,然后更改源码.再打包成成库调用.</p>
<h2><a id="%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于时间比较</h2>
<p>新项目中存在一个功能比如 <code>10:00:00</code> 到 <code>11:59:59</code> 算早市,需要判断当前时间是否是早市. 一种更方便的处理方式:</p>
<p>时间格式 <code>HH:mm:ss</code> 一共6位数字,我们可以去掉中间的<code>:</code>,这样时间就是一个整数了,然后三个整数之间进行比较比 先比小时再比分钟最后比秒数要方便很多.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402948321.html">联系方式</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>手机：15633396400</li>
<li>Email：<a href="mailto:hiccer@126.com">hiccer@126.com</a></li>
</ul>
<h1><a id="%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>个人信息</h1>
<ul>
<li>李小争/男/1990</li>
<li>本科/软件工程</li>
<li>工作年限：6 年 iOS开发 1年 C#开发</li>
<li>技术博客：<a href="http://lxzzzzzz.github.io/Blog">http://lxzzzzzz.github.io/Blog</a></li>
<li>Github：<a href="http://github.com/lxzzzzzz">http://github.com/lxzzzzzz</a></li>
</ul>
<h1><a id="%E5%B7%A5%E4%BD%9C%E7%BB%8F%E5%8E%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作经历</h1>
<h2><a id="%E7%BA%A2%E7%81%AB%E5%8F%B0%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80%E5%85%AC%E5%8F%B8%E7%94%A8%E5%8F%8B%E9%A4%90%E9%A5%AE%E4%BA%91%EF%BC%882016%E5%B9%B4-11%E6%9C%88%E4%BB%8A%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>红火台网络科技公司 (用友餐饮云) （ 2016 年 11 月 ~ 今 ）</h2>
<h3><a id="%E6%B5%B7%E5%BA%95%E6%8D%9Eipad%E7%82%B9%E9%A4%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>海底捞 iPad 点餐</h3>
<p>项目初期负责主体框架搭建，负责点菜列表，点锅页面，菜品下单，鉴权等操作.后期所有功能的开发和维护。项目特点如下:</p>
<ol>
<li>
<p>为混编项目，视频监控等功能是 C&amp;C++的三方库，通过 Objective-C 和 Swift 桥接起来.</p>
</li>
<li>
<p>项目点菜列表页显示大量图片&amp;标签，需要支持 iPad 2 等比较老的设备.菜品列表滚动优化</p>
</li>
<li>
<p>权限控制，页面跳转控制，屏保设置，国际化等</p>
</li>
<li>
<p>数据加密压缩传输</p>
</li>
<li>
<p>多服务支持，iPad端同时支持天子星后台和红火台后台</p>
</li>
<li>
<p>锅底页面大量使用手势操作锅底 (万柳店DIY功能)</p>
<p>总结: 点菜列表页经过优化，滑动效果在 iPad 2 上优于淘宝京东等 App。视频监控可以做到兼容海康威视 &amp; 宇视两家视频监控厂商的各型号设备，支持 NVR 模式 &amp; IP 直连。</p>
</li>
</ol>
<h3><a id="%E7%BA%A2%E7%81%AB%E5%8F%B0app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>红火台 App</h3>
<p>红火台点餐分为用户版&amp;商户版。项目有园区版本和对外版本，该项目主要是预约点餐&amp;堂食。预约点餐是手机端点菜下单类似于美团点菜。堂食分为主扫和被扫。主扫是通过扫描二维码支付，被扫是生成付款码 (餐补，部门卡，活动卡，临时卡等) 扫码枪扫二维码支付。项目特点如下:</p>
<ol>
<li>显示信息由后台配置，移动端根据配置显示对应数据</li>
<li>食堂的信号不是很好所以支付信息等通过 WebSocket 进行状态传递用定时轮询做补充</li>
<li>订单待支付状态显示，代付款的订单需要显示倒计时，优化列表中多个倒计时显示效果</li>
</ol>
<h3><a id="%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他项目</h3>
<p>负责的项目还有</p>
<ol>
<li>催单 App: 主要是推送服务，根据推送跳转不同的功能页面</li>
<li>智能供应链: 登录后根据角色显示不同的页面&amp;功能，页面主要功能点是订单的展示和修改。</li>
<li>红火台 iPad 点餐: 基本原理同海底捞点餐。不同点是默认进入吧台模式，适合门店 iPad 较少的情况。</li>
<li>Hi捞送: 海底捞自己的配送App，支持取餐和配送。主要使用高德地图展示路径规划，和UIControl 模拟iOS4的侧滑接单通过<code>beginTracking</code> <code>continueTracking</code> <code>endTracking</code> 判断滑动位置和状态修改。</li>
</ol>
<h2><a id="%E5%BE%AE%E6%8C%87%EF%BC%88%E4%B8%8A%E6%B5%B7%EF%BC%89%E4%BF%A1%E6%81%AF%E7%A7%91%E6%8A%80%E8%82%A1%E4%BB%BD%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8%EF%BC%882014%E5%B9%B4-10%E6%9C%88-2016%E5%B9%B4-11%E6%9C%88%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>微指（上海）信息科技股份有限公司 （ 2014 年 10 月 ~ 2016 年 11 月 ）</h2>
<h3><a id="%E5%BE%AE%E6%8C%87%E7%94%A8%E6%88%B7%E7%89%88%E5%95%86%E6%88%B7%E7%89%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>微指用户版&amp;商户版</h3>
<p>主要负责项目架构，使用 Objective-C 编写。LBS 类 App，负责功能有:首页附近商户，聊天 (Socket) 等功能。根据地理位置展示附近商户。主要功能点:</p>
<ol>
<li>
<p>定位，采集端使用百度地图，用户端使用高德地址，通过火星坐标转换显示对应的位置</p>
</li>
<li>
<p>聊天，使用 Socket 进行通讯，内容包括文字图片等信息。</p>
</li>
<li>
<p>商户详情页面，Hybrid(原生&amp;H5 混合开发) 形式展示内容</p>
</li>
</ol>
<h1><a id="%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开源贡献</h1>
<h2><a id="%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开源项目</h2>
<ul>
<li><a href="https://Github.com/line/line-sdk-ios-swift">line-sdk-ios-swift</a>：学习 LineSDK 的时候参与修改部分代码</li>
<li><a href="https://Github.com/ChenYilong/iOS9AdaptationTips">iOS9AdaptationTips</a>：提交 Issues，奉献一些自己遇到并解决的问题</li>
</ul>
<h1><a id="%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>技能清单</h1>
<p>以下均为我熟练使用的技能</p>
<ul>
<li>
<p>编程语言: Swift/Objective-C</p>
</li>
<li>
<p>框架：Kingfisher/Moya/PromiseKit</p>
</li>
<li>
<p>数据库相关：MySQL/SQLite</p>
</li>
<li>
<p>版本管理：SVN/Git</p>
</li>
<li>
<p>了解RunLoop、Runtime、GCD等</p>
</li>
</ul>
<p>以下为了解能写简单功能的技能:</p>
<ul>
<li>
<p>编程语言: Java/HTML+JavaScript</p>
</li>
<li>
<p>框架: Vue/ElementUI</p>
<p>​</p>
</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402948460.html">iOS 开发环境配置</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>
<p>安装Xcode(Version 12.4)</p>
<p>不要去App Store下载安装，因为App Store会自动更新，为了确保Xcode版本一致需要去开发者网站下载 <a href="https://developer.apple.com/download/more/">Apple Developer</a></p>
</li>
<li>
<p>安装brew</p>
<ol>
<li>
<p>由于访问外网太慢，建议从gitee安装</p>
<pre><code class="language-shell">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;
</code></pre>
</li>
<li>
<p>可以选择科大的源也可以选择清华的源，我一般用清华的源</p>
</li>
</ol>
</li>
<li>
<p>安装rbenv</p>
<ol>
<li>
<p>rbenv是 Ruby 环境管理工具 <code>brew install rbenv</code></p>
</li>
<li>
<p>更新配置文件</p>
<pre><code class="language-sh">export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot; 
eval &quot;$(rbenv init -)&quot;
</code></pre>
</li>
<li>
<p>我现在用的Ruby环境是2.7.1</p>
<pre><code class="language-shell">$ cd $(PROJECT_DIR)
$ rbenv install 2.7.1
$ rbenv local 2.7.1
</code></pre>
</li>
</ol>
</li>
<li>
<p>安装Bundler</p>
<ol>
<li>
<p>执行<code>gem install bundler</code>命令进行，之后，再执行<code>bundle init</code>就可以生成一个 Gemfile 文件</p>
</li>
<li>
<p>添加CocoaPods 和 fastlane 等依赖包</p>
<pre><code class="language-shell">source &quot;https://rubygems.org&quot;

gem &quot;cocoapods&quot;, &quot;1.10.1&quot;
gem &quot;fastlane&quot;,&quot;2.180.1&quot;
</code></pre>
</li>
</ol>
</li>
<li>
<p>使用脚本确认环境</p>
<pre><code class="language-shell"># Install ruby using rbenv

ruby_version=`cat .ruby-version`
if [[ ! -d &quot;$HOME/.rbenv/versions/$ruby_version&quot; ]]; then
  rbenv install $ruby_version;
fi
# Install bunlder
gem install bundler
# Install all gems
bundle install
# Install all pods
bundle exec pod install

</code></pre>
<p>​	脚本主要做了四件事情，第一步是在 rbenv 下安装特定版本的 Ruby 开发环境，然后通过 RubyGems 安装 Bunlder，接着使用 Bundler 安装 CocoaPods 和 fastlane 等依赖包，最后安装各个 Pod。这样，一个统一的项目环境就搭建完成了，接下来开发者就可以打开 <strong>项目名.xcworkspace</strong>进行开发了.</p>
</li>
<li>
<p>项目添加gitignore</p>
<p>可以去gitignore.io 输入Xcode，Swift等关键字生成.gitignore文件</p>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402948600.html">关于开台代码建议</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="tablechoosecontroller-swift" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TableChooseController.swift</h2>
<ol>
<li>
<p>viewDidLoad()中存在大量数据代码,可以写个方法调用</p>
</li>
<li>
<p>viewWillAppear 没有用到,这个可以去掉</p>
</li>
<li>
<p>视图是否可以设置为Private</p>
<pre><code class="language-lazy" data-meta="var backgroundView: UIView = {">    let view = UIView()
    view.backgroundColor = UIColor.black.withAlphaComponent(0.95)
    return view
}()

lazy var tableChooseView: TableChooseView = {
    let view = TableChooseView()
    view.delegate = self
    view.tableList = [TableModel]()
    return view
}() 
</code></pre>
</li>
<li>
<p>建议: 所有的 Action 能否写在一个extension中</p>
</li>
<li>
<p>点击事件 selector 最好都设置为私有 例如 didPressHomeButton</p>
</li>
<li>
<p>presentToAddTableController 应该设置为私有</p>
</li>
<li>
<p>网络请求到底使用类方法还是对象方法</p>
</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402948741.html">酒水处理方案</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>HTDishEntity 处理方案:</p>
<p><strong>没有备注</strong><br />
如果酒水没有备注,当做菜来处理,按照整份处理,目前就没有问题</p>
<p><strong>有备注:</strong><br />
模型中添加一个属性(暂定cookEntityArray),这里面存放的是一个模型(暂定CookEntity,这个模型有但是需要修改并且其他逻辑也需要修改不符合现在的逻辑)</p>
<p>注:需要添加id,延时属性等.</p>
<p>处理方式:<br />
同步回来的数据对酒水做特殊判断, 1. 数组中每一个模型确定唯一(即只有一个冰镇的,一个加热..)<br />
2. 把网络数据转成模型存储在酒水模型中.(把同一酒水id的菜品组合成一个菜,这些同步回来的菜品存在形式变为这个菜cookEntityArray中的一个模型..同时,需要对数据进行过滤保证第一点模型唯一)<br />
3. 给购物车显示数据的时候需要把酒水中的每一个单独提取出来显示(每次更改都要更改这个菜cookEntityArray中对应的模型)<br />
4. 给服务器传递数据的时候需要把这个菜cookEntityArray中的一个模型转换成一个服务器需要的字典传递过去.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402948887.html">KVO内部实现原理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li>KVO是基于runtime机制实现的</li>
<li>当某个类的对象第一次被观察时,系统就会在运行期动态地创建该类的一个派生类,在这个派生类中重写基类中任何被观察属性的setter方法.派生类在被重写的setter方法实现真正的通知机制.</li>
</ol>
<p>添加监听前:<br />
<img src="media/16587402948887/14726530320712.jpg" alt="" /></p>
<p>添加监听后:(派生出:NSKVONotifying_Person)<br />
<img src="media/16587402948887/14726532061641.jpg" alt="" /></p>
<p>把前后两份代码全部转换成cpp文件,这时我们查找两个文件不同的地方.</p>
<p><img src="media/16587402948887/14726564797185.jpg" alt="" /></p>
<p>经过简单整理的两份代码:<br />
<img src="media/16587402948887/14726568603743.jpg" alt="" /></p>
<p>可以看出mi_0 &amp; mi_1之间就是Person &amp; NSKVONotifying_Person之间的关系.</p>
<p>-------------------2018.1.20更新(读&lt;编写高质量代码&gt;)--------------------<br />
KVC 通过实现名为NSKeyValueCoding的非正式协议,使开发者可以通过键直接设置和获取对象属性,而不需要调用对象的存取方法(Cocoa为该协议提供了默认的实现).键通常和被访问对象中的实例变量或存取方法的名称相对应.</p>
<p>KVC主要利用一种使用字符串标识符,简介访问属性的机制,他是很多技术的基础.主要有<code>setValue: forKey</code>,<code>valueForKey</code>和<code>setValue: forKeyPath</code>,<code>valueForKeyPath</code></p>
<p>key 与keyPath 基本一样,只是keyPath的值是一个路径,路径之间用<code>.</code>分割,比如数据成员就是对象自己,寻值过程就会向下深入下去.<img src="media/16587402948887/WechatIMG26.png" alt="WechatIMG26" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402949044.html">iOS开发-KVO的奥秘</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>来源：<a href="http://www.jianshu.com/p/742b4b248da9">Sindri的小巢</a></p>
</blockquote>
<p><strong>前言</strong></p>
<p>在iOS开发中，苹果提供了许多机制给我们进行回调。KVO(key-value-observing)是一种十分有趣的回调机制，在某个对象注册监听者后，在被监听的对象发生改变时，对象会发送一个通知给监听者，以便监听者执行回调操作。最常见的KVO运用是监听scrollView的contentOffset属性，来完成用户滚动时动态改变某些控件的属性实现效果，包括渐变导航栏、下拉刷新控件等效果。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/foPACGrddJ2RICbWq0ibOxfFDmygDGicuRRjLKzYTqMibXMxTiaNXIdeRT6s0aalp1ibbib7BxAYqUyPhHd1iahRY45uQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="" /></p>
<p>渐变导航栏</p>
<p><strong>使用</strong></p>
<p>KVO的使用非常简单，使用KVO的要求是对象必须能支持kvc机制——所有NSObject的子类都支持这个机制。拿上面的渐变导航栏做??，我们为tableView添加了一个监听者controller，在我们滑动列表的时候，会计算当前列表的滚动偏移量，然后改变导航栏的背景色透明度。</p>
<pre><code class="language-plain_text">//添加监听者
[self.tableView addObserver: self forKeyPath: @&quot;contentOffset&quot; options: NSKeyValueObservingOptionNew context: nil];
/**
 * 监听属性值发生改变时回调
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    CGFloat offset = self.tableView.contentOffset.y;
    CGFloat delta = offset / 64.f + 1.f;
    delta = MAX(0, delta);
    [self alphaNavController].barAlpha = MIN(1, delta);
}
</code></pre>
<p>毫无疑问，kvo是一种非常便捷的回调方式，但是编译器是怎么完成监听这个任务的呢？先来看看苹果文档对于KVO的实现描述</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling... When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ..</p>
</blockquote>
<p>简要的来说，在我们对某个对象完成监听的注册后，编译器会修改监听对象（上文中的tableView）的isa指针，让这个指针指向一个新生成的中间类。从某个意义上来说，这是一场骗局。</p>
<pre><code class="language-plain_text">typedef struct objc_class *Class;
typedef struct objc_object {
    Class isa;
} *id;
</code></pre>
<p>这里要说明的是isa这个指针，isa是一个Class类型的指针，用来指向类的类型，我们可以通过object_getClass方法来获取这个值(正常来说，class方法内部的实现就是获取这个isa指针，但是在kvo中苹果对监听对象的这个方法进行了重写。之前这里描述有误，说成是指向父类，多谢<a href="http://www.jianshu.com/users/1498e495a4b1/timeline">夏都</a>为我纠正)。</p>
<p>在oc中，规定了只要拥有isa指针的变量，通通都属于对象。上面的objc_object表示的是NSObject这个类的结构体表示，因此oc不允许出现非NSObject子类的对象（block是一个特殊的例外）</p>
<p>当然了，苹果并不想讲述更多的实现细节，但是我们可以通过运行时机制来完成一些有趣的调试。</p>
<p><strong>苹果的黑魔法</strong></p>
<p>根据苹果的说法，在对象完成监听注册后，修改了被监听对象的某些属性，并且改变了isa指针，那么我们可以在监听前后输出被监听对象的相关属性来进一步探索kvo的原理。为了保证能够得到对象的真实类型，我使用了object_getClass方法（class方法本质上是调用这个函数），这个方法在runtime.h头文件中</p>
<pre><code class="language-plain_text">NSLog(@&quot;address: %p&quot;, self.tableView);
NSLog(@&quot;class method: %@&quot;, self.tableView.class);
NSLog(@&quot;description method: %@&quot;, self.tableView);
NSLog(@&quot;use runtime to get class: %@&quot;, object_getClass(self.tableView));
[self.tableView addObserver: self forKeyPath: @&quot;contentOffset&quot; options: NSKeyValueObservingOptionNew context: nil];
NSLog(@&quot;===================================================&quot;);
NSLog(@&quot;address: %p&quot;, self.tableView);
NSLog(@&quot;class method: %@&quot;, self.tableView.class);
NSLog(@&quot;description method: %@&quot;, self.tableView);
NSLog(@&quot;use runtime to get class %@&quot;, object_getClass(self.tableView));
</code></pre>
<p>在看官们运行这段代码之前，可以先思考一下上面的代码会输出什么。</p>
<pre><code class="language-plain_text">2015-12-12 23:02:33.216 LXDAlphaNavigationController[1487:63171] address: 0x7f927a81d200
2015-12-12 23:02:33.216 LXDAlphaNavigationController[1487:63171] class method: UITableView
2015-12-12 23:02:33.217 LXDAlphaNavigationController[1487:63171] description method: 2015-12-12 23:02:33.217 LXDAlphaNavigationController[1487:63171] use runtime to get class: UITableView
2015-12-12 23:02:33.217 LXDAlphaNavigationController[1487:63171] ===================================================
2015-12-12 23:02:33.218 LXDAlphaNavigationController[1487:63171] address: 0x7f927a81d200
2015-12-12 23:02:33.218 LXDAlphaNavigationController[1487:63171] class method: UITableView
2015-12-12 23:02:33.218 LXDAlphaNavigationController[1487:63171] description method: 2015-12-12 23:02:33.230 LXDAlphaNavigationController[1487:63171] use runtime to get class NSKVONotifying_UITableView
</code></pre>
<p>除了通过object_getClass获取的类型之外，其他的输出没有任何变化。class方法跟description方法可以重写实现上面的效果，但是为什么连地址都是一样的。</p>
<p>这里可以通过一句小代码来说明一下：</p>
<pre><code class="language-plain_text">NSLog(@&quot;%@, %@&quot;, self.class, super.class);
</code></pre>
<p>上面这段代码不管你怎么输出，两个结果都是一样的。这是由于super本质上指向的是父类内存。这话说起来有点绕口，但是我们可以通过对象内存图来表示：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz/foPACGrddJ2RICbWq0ibOxfFDmygDGicuRn1E06HjV4SicWpj23ss5lIoibBxfyEKHxnx22HmZdMItVZa4ViaSlAU5A/640?wx_fmt=png" alt="" /></p>
<p>类的内存</p>
<p>每一个对象占用的内存中，一部分是父类属性占用的；在父类占用的内存中，又有一部分是父类的父类占用的。前文已经说过isa指针指向的是父类，因此在这个图中，Son的地址从Father开始，Father的地址从NSObject开始，这三个对象内存的地址都是一样的。通过这个，我们可以猜到苹果文档中所提及的中间类就是被监听对象的子类。并且为了隐藏实现，苹果还重写了这个子类的class方法跟description方法来掩人耳目。另外，我们还看到了新类相对于父类添加了一个NSKVONotifying_前缀，添加这个前缀是为了避免多次创建监听子类，节省资源</p>
<p><strong>怎么实现类似效果</strong></p>
<p>既然知道了苹果的实现过程，那么我们可以自己动手通过运行时机制来实现KVO。runtime允许我们在程序运行时动态的创建新类、拓展方法、method-swizzling、绑定属性等等这些有趣的事情。</p>
<p>在创建新类之前，我们应该学习苹果的做法，判断当前是否存在这个类，如果不存在我们再进行创建，并且重新实现这个新类的class方法来掩盖具体实现。基于这些原则，我们用下面的方法来获取新类</p>
<pre><code class="language-plain_text">- (Class)createKVOClassWithOriginalClassName: (NSString *)className
{
    NSString * kvoClassName = [kLXDkvoClassPrefix stringByAppendingString: className];
    Class observedClass = NSClassFromString(kvoClassName);
    if (observedClass) { return observedClass; }
    //创建新类，并且添加LXDObserver_为类名新前缀
    Class originalClass = object_getClass(self);
    Class kvoClass = objc_allocateClassPair(originalClass, kvoClassName.UTF8String, 0);
    //获取监听对象的class方法实现代码，然后替换新建类的class实现
    Method classMethod = class_getInstanceMethod(originalClass, @selector(class));
    const char * types = method_getTypeEncoding(classMethod);
    class_addMethod(kvoClass, @selector(class), (IMP)kvo_Class, types);
    objc_registerClassPair(kvoClass);
    return kvoClass;
}
</code></pre>
<p>另外，在判断是否需要中间类来完成监听的注册前，我们还要判断监听的属性的有效性。通过获取变量的setter方法名（将首字母大写并加上前缀set），以此来获取setter实现，如果不存在实现代码，则抛出异常使程序崩溃。</p>
<pre><code class="language-plain_text">SEL setterSelector = NSSelectorFromString(setterForGetter(key));
Method setterMethod = class_getInstanceMethod([self class], setterSelector);
if (!setterMethod) {
    @throw [NSException exceptionWithName: NSInvalidArgumentException reason: [NSString stringWithFormat: @&quot;unrecognized selector sent to instance %p&quot;, self] userInfo: nil];
    return;
}
Class observedClass = object_getClass(self);
NSString * className = NSStringFromClass(observedClass);
//如果被监听者没有LXDObserver_，那么判断是否需要创建新类
if (![className hasPrefix: kLXDkvoClassPrefix]) {
    observedClass = [self createKVOClassWithOriginalClassName: className];
    object_setClass(self, observedClass);
}
//重新实现setter方法，使其完成
const char * types = method_getTypeEncoding(setterMethod);
class_addMethod(observedClass, setterSelector, (IMP)KVO_setter, types);


</code></pre>
<p>在重新实现setter方法的时候，有两个重要的方法：willChangeValueForKey和didChangeValueForKey，分别在赋值前后进行调用。此外，还要遍历所有的回调监听者，然后通知这些监听者：</p>
<pre><code class="language-plain_text">static void KVO_setter(id self, SEL _cmd, id newValue)
{
    NSString * setterName = NSStringFromSelector(_cmd);
    NSString * getterName = getterForSetter(setterName);
    if (!getterName) {
        @throw [NSException exceptionWithName: NSInvalidArgumentException reason: [NSString stringWithFormat: @&quot;unrecognized selector sent to instance %p&quot;, self] userInfo: nil];
        return;
    }
    id oldValue = [self valueForKey: getterName];
    struct objc_super superClass = {
        .receiver = self,
        .super_class = class_getSuperclass(object_getClass(self))
    };
    [self willChangeValueForKey: getterName];
    void (*objc_msgSendSuperKVO)(void *, SEL, id) = (void *)objc_msgSendSuper;
    objc_msgSendSuperKVO(&amp;superClass, _cmd, newValue);
    [self didChangeValueForKey: getterName];
    //获取所有监听回调对象进行回调
    NSMutableArray * observers = objc_getAssociatedObject(self, (__bridge const void *)kLXDkvoAssiociateObserver);
    for (LXD_ObserverInfo * info in observers) {
        if ([info.key isEqualToString: getterName]) {
            dispatch_async(dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                info.handler(self, getterName, oldValue, newValue);
            });
        }
    }
}
</code></pre>
<p>所有的监听者通过动态绑定的方式将其存储起来，但这样也会产生强引用，所以我们还需要提供释放监听的方法：</p>
<pre><code class="language-plain_text">- (void)LXD_removeObserver:(NSObject *)object forKey:(NSString *)key
{
    NSMutableArray * observers = objc_getAssociatedObject(self, (__bridge void *)kLXDkvoAssiociateObserver);
    LXD_ObserverInfo * observerRemoved = nil;
    for (LXD_ObserverInfo * observerInfo in observers) {
        if (observerInfo.observer == object &amp;&amp; [observerInfo.key isEqualToString: key]) {
            observerRemoved = observerInfo;
            break;
        }
    }
    [observers removeObject: observerRemoved];
}
</code></pre>
<p>虽然上面已经粗略的实现了kvo，并且我们还能自定义回调方式。使用target-action或者block的方式进行回调会比单一的系统回调要全面的多。但kvo真正的实现并没有这么简单，上述代码目前只能实现对象类型的监听，基本类型无法监听，况且还有keyPath可以监听对象的成员对象的属性这种更强大的功能。</p>
<p><strong>尾言</strong></p>
<p>对于基本类型的监听，苹果可能是通过void *类型对对象进行桥接转换，然后直接获取内存，通过type encoding我们可以获取所有setter对象的具体类型，虽然实现比较麻烦，但是确实能够达成类似的效果。</p>
<p>钻研kvo的实现可以让我们对苹果的代码实现有更深层次的了解，这些知识涉及到了更深层次的技术，探究它们对我们的开发视野有着很重要的作用。同时，对比其他的回调方式，KVO的实现在创建子类、重写方法等等方面的内存消耗是很巨大的，因此博主更加推荐使用delegate、block等回调方式，甚至直接使用method-swizzling来替换这种重写setter方式也是可行的。</p>
<p>文章代码：<a href="https://github.com/JustKeepRunning/LXD_KeyValueObserveDemo">自实现KVO</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402949189.html">as快捷键</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>包装widget 使用<code>opt+enter</code></p>
<p>删除一行 <code>cmd+y</code></p>
<p>查看定义<code>cmd+b</code></p>
<p>as自带<br />
搜文件 双击shift 搜索</p>
<p>全局搜索 <code>cmd+shift+f</code><br />
重命名<code>shift+f6</code><br />
切换自负大小写，选中 <code>cmd+shift+u</code></p>
<p>复制一行 <code>cmd+d</code><br />
多行光标 <code>opt+向下拖拽</code>会出现多行一起操作</p>
<p>调换顺序 <code>opt+shift+上下箭头</code></p>
<p>光标移动到上次位置 <code>cmd+opt+⬅️</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402949333.html">iOS Tips</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><strong>对象销毁</strong><br />
对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
<pre><code class="language-plain_text">NSArray *tmp = self.array;
self.array = nil;
dispatch_async(queue, ^{
    [tmp class];
});
</code></pre>
<blockquote>
<p>来自:<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p>
</blockquote>
<p><strong>拖拽收起键盘</strong><br />
UIScrollView有个keyboardDismissMode属性，设置成UIScrollViewKeyboardDismissModeOnDrag就可以在拖拽ScrollView的时候自动缩起键盘</p>
<pre><code class="language-plain_text">@property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode NS_AVAILABLE_IOS(7_0); // default is UIScrollViewKeyboardDismissModeNone
</code></pre>
<p><strong>让view的一部分响应手势点击</strong><br />
让view的一部分响应手势点击，其余部分实现手势透传给下方的view的方法</p>
<p>在View中重写:</p>
<pre><code class="language-plain_text">-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    NSLog(@&quot;%@-------------&gt;&gt;&gt;&gt;&gt;&gt;&gt;point = %@&quot;,NSStringFromSelector(_cmd),NSStringFromCGPoint(point));
    
    // 设置能够点击的区域
    CGRect rect = CGRectMake(100, 100, 200, 200);
    if (CGRectContainsPoint(rect, point)) {
        // 如果点击在该区域,则让View 成为响应链中的一个view,接受手势事件
        // 此时可通过touchBegan:方法监听到手势
        return self;
    }
    return nil;
}

</code></pre>
<p>控制按钮的点击范围可以参见:<a href="https://github.com/Mekor/MKExtension">MKExtension</a>中的<code>UIButton+TapScope</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402949481.html">647. Palindromic Substrings</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>题目地址:<a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a><br />
Given a string, your task is to count how many palindromic substrings in this string.</p>
<p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p>
<ul>
<li><strong>Example 1:</strong></li>
</ul>
<pre><code class="language-plain_text">Input: &quot;abc&quot;
Output: 3
Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.
</code></pre>
<ul>
<li><strong>Example 2:</strong></li>
</ul>
<pre><code class="language-plain_text">Input: &quot;aaa&quot;
Output: 6
Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.
</code></pre>
<p><strong>Note:</strong><br />
The input string length won't exceed 1000.</p>
<p>解题思路：</p>
<p>使用中心扩展方法,每个字符都是一个中心，或者两个相邻一样的字符是一个中心，然后向左右分别递进判断能否形成回文</p>
<p>举个🌰</p>
<pre><code class="language-plain_text">  比如字符串是   a   b   a
  遍历字符串   &lt;-⬆-&gt;             回文子串 a  左边没有数据所以只有这一个
                 &lt;-⬆-&gt;          回文子串 b  一个指针向左走一个指针向右走 判断是否还有对应的子串（aba）， 左边 a 右边 a 能形成字串，再走没有数据
                     &lt;-⬆-&gt;     回文字串 a 右边没有数据所以结束
  根据上面的流程 最终的字串为  a，b, aba, a 共4个
 
  当然还有两个字符一样的情况
  比如字符串是   a   b   b   a
  这样就需要      &lt;-⬆  ⬆-&gt;      从中间两个向外判断是否能形成回文子串  
</code></pre>
<p>参考代码：</p>
<pre><code class="language-Java">class Solution {
    // 回文字串数量
    int count = 0;
    public int countSubstrings(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        for (int i = 0; i &lt; s.length(); i++) {
            // aba -&gt; i 为 b位置
            helper(s,i,i);
            // abba -&gt; i 为第一个b位置
            helper(s,i,i+1);
        }
        return count;
    }

    private void helper(String s, int left, int right) {
        while (left &gt;= 0 &amp;&amp; right &lt;= s.length() - 1 &amp;&amp; s.charAt(left) == s.charAt(right)) {
            count++;
            left--;
            right++;
        }
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402949631.html">copy strong weak assign</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##weak &amp; strong<br />
<strong>weak</strong><br />
你买了个iPhone7，你朋友觉得不错，由于手头紧，没买，于是你们公用一台iPhone7，你新装了QQ音乐，你朋友用的时候也会有QQ音乐<br />
然后你的手机丢了 你朋友也没有 不能用了</p>
<p><strong>stong</strong><br />
你买了个iPhone7 你朋友也买了个iPhone7  他觉得你的app stroe账号里有好多软件 然后他就用你的app stroe账号 == 他stong了你的账号，你俩就公用了一个账号。<br />
你下载软件 他也有了 然后你手机账号没了丢了 但他的手机还在账号还能用。</p>
<p>##strong &amp; copy (深拷贝&amp;浅拷贝)<br />
copy是用来保护数据的,copy一个数据之后,更改源数据不会导致copy的数据更改<br />
strong是对一个数据的引用,更改源数据会导致strong的数据更改</p>
<p>##assign<br />
基本数据类型</p>
<blockquote>
<p><a href="https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/CopyFunctions.html">苹果文档中关于浅拷贝&amp;深拷贝</a></p>
</blockquote>
<p><img src="media/16587402949631/Snip20160817_3.png" alt="Snip20160817_3" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402949783.html">避免和WillPopScope与iOS手势冲突</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>开发中有一个需求，表单填写中点击返回按钮需要提示。这个需求可以使用WillPopScope处理</p>
<pre><code class="language-dart">bool _locked = false;
...
return Scaffold(
	appBar: AppBar(title:&quot;Detail Page&quot;),
	body: WillPopScope(
		onWillPop: () async {
			print(&quot;这里处理退出前的逻辑处理&quot;);
			if(_locked) {
				return false; // 锁住的时候不允许返回
			} else {
				reutrn true; // 没有锁的时候直接返回
			}
		},	
		child: Center(
			child: TextButton(
				child:Icon_locked ? Icons.lock : Icons.lock_open, size: 200),
				onPressed: () =&gt; setState(()=&gt;_locked = !_locked),
			),
		),
	),
);
</code></pre>
<p>使用WillPopScope 使用的时候就没有了iOS平台的侧滑返回了。</p>
<h2><a id="%E4%B8%8D%E8%83%BD%E4%BE%A7%E6%BB%91%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不能侧滑返回的原因是什么？</h2>
<p>在<code>route.dart</code>文件中能看到有一个私有方法<code>_isPopGestureEnabled</code>。这个方法会判断当前是否是第一个是否是全屏Dialog等。其中有一种情况就是<code>hasScopedWillPopCallback</code></p>
<h2><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案</h2>
<ol>
<li>不使用WillPopScope组件，而是手动添加或者移出WillPopCallback</li>
</ol>
<pre><code class="language-dart">bool _locked = false;
...
return Scaffold(
	appBar: AppBar(title:&quot;Detail Page&quot;),
	body:
		Center(
			child: TextButton(
				child:Icon_locked ? Icons.lock : Icons.lock_open, size: 200),
				onPressed: (){ 
					setState(()=&gt;_locked = !_locked);
					if(_locked) {
						ModalRoute.of(context)!.addScopedWillPopCallback(preventExit);
					} else {
						ModalRoute.of(context)!.removeScopedWillPopCallback(prevenExit);
					}

				},
			),
		);
);

...

Future&lt;bool&gt; preventExit() async =&gt; false;
</code></pre>
<ol start="2">
<li>还是在onWillPopScope组件中进行处理</li>
</ol>
<pre><code class="language-dart">bool _locked = false;
...
return Scaffold(
	appBar: AppBar(title:&quot;Detail Page&quot;),
	body: WillPopScope(
		onWillPop: _locked ? () async =&gt; false : null,
		child: Center(
			child: TextButton(
				child:Icon_locked ? Icons.lock : Icons.lock_open, size: 200),
				onPressed: () =&gt; setState(()=&gt;_locked = !_locked),
			),
		),
	),
);
</code></pre>
<p>这样处理的原因是<code>will_pop_scope.dart</code> 中，在133行 <code>didUpdateWidget</code>中会对是否有<code>onWillPop</code>进行判断，如果为<code>onWillPop</code>是null的时候不会添加。</p>
<h2><a id="%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%98%E6%9C%89%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%B0%B1%E6%98%AF%E8%87%AA%E5%AE%9A%E4%B9%89appbar%E7%9A%84leading" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目中还有一种方式就是自定义AppBar的leading</h2>
<pre><code class="language-plain_text">appBar: AppBar(
  leading: IconButton(
    icon: Icon(Icons.arrow_back, color: Colors.black),
    onPressed: () =&gt; Navigator.of(context).pop(),
  ), 
  title: Text(&quot;Sample&quot;),
  centerTitle: true,
),
</code></pre>
<p>这种方式对iOS侧滑返回和Android实体键返回没有效果。<br />
如果将上述返回修改为</p>
<pre><code class="language-plain_text">Navigator.of(context).maybePop();
</code></pre>
<p>这样就会调用包裹body的<code>WillPopScope</code>.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402949958.html">Swift - 字典中的增删改,遍历与合并</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>增删改</p>
<pre><code class="language-plain_text">var dict:[String:Any] = [&quot;name&quot; : &quot;小明&quot;, &quot;age&quot; : 18, &quot;sex&quot;:&quot;man&quot;]

// 新增
dict[&quot;title&quot;] = &quot;老大&quot;
print(dict)

// 修改
dict[&quot;name&quot;] = &quot;赵四&quot;
print(dict)

// 删除
dict.removeValue(forKey: &quot;age&quot;)
print(dict)

</code></pre>
<p>遍历,合并</p>
<pre><code class="language-plain_text">// 遍历
for e in dict {
    print(e)
}

for (k,v) in dict {
    print(&quot;key:\(k)  value:\(v)&quot;)
}
// 合并
var dict1:[String:Any] = [&quot;name&quot; : &quot;李明&quot;, &quot;age&quot; : 18, &quot;sex&quot;:&quot;m&quot;]
var dict2:[String:Any] = [&quot;name&quot; : &quot;韩梅梅&quot;, &quot;age&quot; : 16, &quot;sex&quot;:&quot;w&quot;]
// 如果把 dict2 合并到 dict1
for e in dict2 {
    dict1[e.key] = e.value   //dict2[e.key]
}
print(&quot;----------\n\(dict1)&quot;)

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402950107.html">商户版App更新</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>默认登录新环境,如果登录新环境成功就显示新UI.<br />
如果新环境登录失败,尝试登录旧环境.旧环境登录成功展示新UI(管理页面新增模式切换,可以切换到旧版UI)</p>
<p><img src="media/16587402950107/15825258260603.jpg" alt="" style="width:464px;" /><br />
旧版UI可以再我的-&gt;设置-&gt;切换模式  中切回新版本UI</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402950258.html">捐款流程</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:34+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1-9%E7%82%B955%E6%8D%90%E6%AC%BE%E7%BE%A4%E6%B8%85%E5%9C%BA%EF%BC%8C%E7%AD%89%E6%8D%90%E6%AC%BE%E9%93%BE%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 9点55捐款群清场，等捐款链接</h2>
<p>捐款链接和发起人如下：<br />
<img src="media/16587402950258/16310110434344.jpg" alt="" /></p>
<p>认准这个头像和链接</p>
<h2><a id="2%E7%82%B9%E5%87%BB%E3%80%90%E6%8D%90%E6%AC%BE%E3%80%91%E6%8C%89%E9%92%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 点击【捐款】按钮</h2>
<p>界面如下：<br />
<img src="media/16587402950258/16310110720257.jpg" alt="" /></p>
<h2><a id="3%E6%8D%90%E6%AC%BE%E7%A1%AE%E8%AE%A4%E9%A1%B5%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 捐款确认页面</h2>
<p><img src="media/16587402950258/16310111902373.jpg" alt="" /><br />
<img src="media/16587402950258/16310112102602.jpg" alt="" /><br />
【注意】<strong>10点前提前操作的</strong>需要在输入密码确认页面等时间跳转到<strong>10：00</strong>时把密码输完确认。<br />
<img src="media/16587402950258/16310120538275.jpg" alt="" /></p>
<h2><a id="4%E7%A1%AE%E5%AE%9A%E5%90%8E%E6%A0%B9%E6%8D%AE%E4%B8%AA%E4%BA%BA%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%94%AF%E4%BB%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 确定后根据个人支付方式进行支付</h2>
<p>支付成功后，<strong>关闭页面再次从头开始</strong>。<br />
【重复捐款操作】<br />
（举例：我今天收到通知要捐款4000元分4次捐出，这样我需要从【<strong>1</strong>】开始执行，每次输入1000元捐款。执行这个流程4次）</p>
<h3><a id="%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>特殊情况处理</h3>
<p>10点整捐款的时候由于人数太多可能会出现异常，界面如下：<br />
<img src="media/16587402950258/Pasted%20Graphic%202.jpg" alt="温馨提示" /><br />
<strong>不要慌，钱没有捐出去</strong>，点击确认后再次付款就可以了，直到成功为止。</p>
<h1><a id="%E5%88%86%E4%BA%AB%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分享流程</h1>
<p>上面捐款流程结束后，开始分享流程</p>
<h2><a id="1%E8%BF%9B%E5%85%A5%E5%BE%AE%E4%BF%A1%E3%80%90%E6%88%91%E3%80%91%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%90%E6%94%AF%E4%BB%98%E3%80%91%E6%8C%89%E9%92%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 进入微信【我】的页面，点击【支付】按钮</h2>
<p>当前操作图如下：<br />
<img src="media/16587402950258/%E6%9D%8E%E5%B0%8F%E4%BA%89.jpg" alt="李小争" /></p>
<h2><a id="2%E8%BF%9B%E5%85%A5%E6%94%AF%E4%BB%98%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%90%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A%E3%80%91%E7%AE%AD%E5%A4%B4%E6%8C%87%E5%90%91%E7%9A%84%E5%BF%83%E5%BD%A2%E6%8C%89%E9%92%AE%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 进入支付页面，点击【腾讯公益】箭头指向的心形按钮。</h2>
<p><img src="media/16587402950258/%E9%BA%A6%E4%BB%98.jpg" alt="麦付" /></p>
<h2><a id="3%E8%BF%9B%E5%85%A5%E3%80%90%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A%E3%80%91%EF%BC%8C%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92%E4%BA%BA%E5%BD%A2%E5%9B%BE%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 进入【腾讯公益】，点击右上角人形图标</h2>
<p>如下图箭头所指<br />
<img src="media/16587402950258/%E4%B8%80%E5%9D%97%E5%81%9A%E5%A5%BD%E4%BA%8B.jpg" alt="一块做好事" /></p>
<h2><a id="4%E8%BF%9B%E5%85%A5%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A%E4%B8%AA%E4%BA%BA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%90-99%E5%85%AC%E7%9B%8A%E6%97%A5%E3%80%91%E6%A0%8F%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 进入腾讯公益个人页面，点击【99公益日】栏目</h2>
<p>具体点击位置如下图：<br />
<img src="media/16587402950258/Lifes%20a%20struggle%20%C2%AE.png" alt="Lifes a struggle ®" /></p>
<h2><a id="5%E8%BF%9B%E5%85%A5%E4%B8%80%E5%9D%97%E5%81%9A%E5%A5%BD%E4%BA%8B%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92%E3%80%90%E3%80%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. 进入一块做好事页面，点击右上角【...】</h2>
<p>具体位置如下图<br />
<img src="media/16587402950258/%E2%80%A2399%E5%85%AC%E7%9B%8A%E6%97%A5.jpg" alt="•399公益日" /><br />
分享到小红花群，后续操作如下：<br />
<img src="media/16587402950258/%E4%B8%8B%E5%8D%88546.jpg" alt="下午546" /><br />
<img src="media/16587402950258/%E4%B8%8B%E5%B9%B4546.jpg" alt="下年546" /></p>
<p><strong>分享结束，下面进入小红花群开始小红花群操作</strong></p>
<p>当大家分享完毕时，小红花群里已经有其他人分享的链接了，这时大家打开其他人的链接【群里任何人分享的链接都可以】<br />
<strong>先送小红花，先送小红花，先送小红花</strong>，</p>
<blockquote>
<p>只点击小红花，送完后关闭点击下一个链接还是送小红花，直到手机没有花为止。<br />
如果手里小红花比较多就【9朵】一次捐，这样得到的配捐额度是最合适的。</p>
</blockquote>
<p>手里的小红花捐完了，再进行其他操作</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402935895.html">海底捞点餐Pad 优化</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1-cell%E6%98%BE%E7%A4%BA%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. cell 显示优化</h2>
<p>海底捞的每个菜品都有很多标签，比如清真，推荐，麻辣等等<br />
这些标签是有规律的，最多显示6个。没有优化前采用的是存在就创建，这样在iPad Air上面滑动感觉不出卡顿但是在一些老pad 比如 iPad mini 上就会出现卡顿现象。<br />
解决方案：<br />
提前创建好6个标签，然后根据数据设置显示内容并控制显隐</p>
<p>这样做能有效的提高老pad的显示效果。</p>
<h2><a id="2%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 数据处理优化</h2>
<p>数据源同步问题，问题描述： pad可以更新数据，定时器拉取数据，推送过来的数据</p>
<p><img src="media/16587402935895/15653335091232.jpg" alt="" style="width:500px;" /></p>
<p>解决方案一： 并发访问数据拷贝<br />
主线程和子线程都操作数据源的时候，可以把数据源给子线程拷贝一份让子线程操作，当子线程操作完返回给主线程的时候把主线程操作的过程在数据源中再次执行一次然后更新数据显示。<br />
主要的技术点是记录主线程操作步骤</p>
<p>解决方案二： 串行访问<br />
操作访问的都是同一数据源，能够保证操作数据不出错。但是有一个问题就是如果子线程正在操作数据这个时候主线程有一个修改操作会导致主线程等待，用户会有卡的感觉。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402935962.html">Swift - KVC 和 运行时获取属性列表</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##Swift中如何使用KVC</p>
<pre><code class="language-plain_text">import UIKit

class Person: NSObject {
    var name:String?
    var age: Int = 0
    var title:String?
    
    init(dict:[String:Any]) {
        super.init()
        setValuesForKeys(dict)
    }
    
    
    override func setValue(_ value: Any?, forUndefinedKey key: String) {
        
    }
}
</code></pre>
<p>注意:基本数据类型一开始要设置默认值.</p>
<p>##Swift中运行时获取属性列表</p>
<pre><code class="language-plain_text">class Person: NSObject {
    var name:String?
    var age: Int = 0
    var title:String?
    
    init(dict:[String:Any]) {
        super.init()
        setValuesForKeys(dict)
    }
    
    
    override func setValue(_ value: Any?, forUndefinedKey key: String) {
        
    }
    
    class func propertyList() -&gt; [String] {
        var count:UInt32 = 0
        
        let list = class_copyPropertyList(self,&amp;count)
        
        var array:[String] = [];
        
        for i in 0..&lt;Int(count) {
            
            // 获取属性
            let pty = list?[i]
            
            // 获取属性名称
            let cName = property_getName(pty)
            let name = String(utf8String: cName!)
            array.append(name!)
        }
        free(list)
        return array
    }
}

</code></pre>
<p>上面是OC写法,可以改进的更Swift一点:</p>
<pre><code class="language-plain_text">    class func propertyList() -&gt; [String] {
        var count:UInt32 = 0
        
        let list = class_copyPropertyList(self,&amp;count)
        
        var array:[String] = [];
        
        for i in 0..&lt;Int(count) {
            
            guard let pty = list?[i],
                let cName = property_getName(pty),
                let name = String(utf8String: cName)
                else {
                    // 继续遍历下一个
                    continue
            }
            array.append(name)
        }
        free(list)
        return array
    }
</code></pre>
<p>通过运行时可以发现:</p>
<ol>
<li>基本数据类型如果设置成可选类型则运行时获取不到(在OC中没有可选)....  这就说明了上面的注意点,否则使用<code>KVC</code>会崩溃</li>
<li>如果属性为<code>private</code>同样获取不到属性(可以获取到ivar),同样会让<code>KVC</code>崩溃</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936028.html">显示中划线,下划线</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3><a id="oc%E4%B8%AD%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>OC中显示</h3>
<h5><a id="%E6%B7%BB%E5%8A%A0%E4%B8%AD%E5%88%92%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加中划线:</h5>
<pre><code class="language-plain_text">  UILabel * strikeLabel = [[UILabel alloc] initWithFrame:(CGRectMake(10, 10, 50, 30))];
  NSString *textStr = [NSString stringWithFormat:@&quot;%@元&quot;, primeCost];

  //中划线
  NSDictionary *attribtDic = @{NSStrikethroughStyleAttributeName: [NSNumber numberWithInteger:NSUnderlineStyleSingle]};
  NSMutableAttributedString *attribtStr = [[NSMutableAttributedString alloc]initWithString:textStr attributes:attribtDic];

  // 赋值
  strikeLabel.attributedText = attribtStr;

  [self.view addSubview:strikeLabel];
</code></pre>
<h5><a id="%E6%B7%BB%E5%8A%A0%E4%B8%8B%E5%88%92%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加下划线:</h5>
<pre><code class="language-plain_text">  UILabel *underlineLabel = [[UILabel alloc] initWithFrame:(CGRectMake(10, 10, 50, 30))];
  NSString *textStr = [NSString stringWithFormat:@&quot;%@元&quot;, primeCost];

  // 下划线
  NSDictionary *attribtDic = @{NSUnderlineStyleAttributeName: [NSNumber numberWithInteger:NSUnderlineStyleSingle]};
  NSMutableAttributedString *attribtStr = [[NSMutableAttributedString alloc]initWithString:textStr attributes:attribtDic];

  //赋值
  underlineLabel.attributedText = attribtStr;

  [self.view addSubview:underlineLabel];
</code></pre>
<h3><a id="swift%E4%B8%AD%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Swift中显示</h3>
<pre><code class="language-plain_text">let myAttributes: [NSAttributedStringKey : Any] = [NSAttributedStringKey.strikethroughStyle: NSUnderlineStyle.styleSingle.rawValue]
            
let attributedText = NSAttributedString(string: &quot;被划线文字&quot;, attributes: myAttributes)
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936088.html">不合理的项目</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol start="11">
<li>天子星结账接口: 主要功能时时(60s,时候后台可配)查询天子星是否结账,如果结账跳转到开台界面</li>
<li>点菜不合理的地方: 单位&amp;备注混用,  必须显示我认为做成标签比较合适,数据库给我需要显示的标签,不要让前端判断用单位还是用备注.(价格随标签一起给)\</li>
<li>查询已下单估清(这个轮询的时候也在使用),上传延时菜品还在使用同一个接口</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936150.html">懒加载的另一种写法</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>原先我一直这样写：</p>
<pre><code class="language-plain_text">    private lazy var imageView: UIImageView = {
        let imageView = UIImageView(image: UIImage(named: &quot;placeholder&quot;))
        imageView.contentMode = .center
        return imageView
    }()

</code></pre>
<p>今天看到了另一种比较简洁的写法</p>
<pre><code class="language-plain_text">private lazy var imageView: UIImageView = {
        $0.contentMode = .center
        return $0
    }(UIImageView())

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936211.html">AR 模型格式转换和导入</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>需要软件：Reality Converter 去 <a href="https://developer.apple.com/download/">https://developer.apple.com/download/</a> 下载<br />
<img src="media/16587402936211/16158208366495.jpg" alt="" style="width:1086px;" /></p>
<p>AR创作中使用USD格式，然后使用Reality Converter 转换成 USDZ格式</p>
<p>模型来源，除了自己制作外还可以通过网上其他人分享的模型来用，比如在 <a href="https://sketchfab.com/">https://sketchfab.com/</a> 中可以搜索自己喜欢的模型。</p>
<p>比如这个模型是gltf格式的，可以下载后把解压后的文件夹拖拽到 Reality Converter 中<br />
<img src="media/16587402936211/16158221517356.jpg" alt="" style="width:900px;" /><br />
然后选择文件-&gt; 导出  这时就导出了usdz格式的模型。</p>
<p><img src="media/16587402936211/16158224521993.jpg" alt="" style="width:448px;" /><br />
打开后选择文件-&gt; 新建</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936280.html">Swift - 关于信号量</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>信号量的使用</p>
<p><img src="media/16587402936280/%E4%BF%A1%E5%8F%B7%E9%87%8F.gif" alt="信号量" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936345.html">关于更换主题</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>今天刷Github，看到一个开源App <a href="https://github.com/weiran/Hackers">Hackers</a>源码里面关于更换主题写的挺好的。</p>
<p>原先我的想法就是切换语言和更新主题发送个通知就好了，然后每个页面都监听下这个通知。<br />
但是这个项目里面采用的是每个控制器都注册下，然后当更换主题时把所有注册的控制器都更新下主题<br />
可以看下<a href="https://github.com/weiran/Hackers/tree/master/Client/Themes">这部分代码</a><br />
在<code>Theming.swift</code>文件中定义了<code>ThemeProvider</code> 和 <code>Themed</code>协议</p>
<pre><code class="language-plain_text">/// Describes a type that holds a current `Theme` and allows
/// an object to be notified when the theme is changed.
protocol ThemeProvider {
    /// Placeholder for the theme type that the app will use
    associatedtype Theme
    
    /// The current theme that is active
    var currentTheme: Theme { get }
    
    /// Subscribe to be notified when the theme changes. Handler will be
    /// remove from subscription when `object` is deallocated.
    func subscribeToChanges(_ object: AnyObject, handler: @escaping (Theme) -&gt; Void)
}

/// Describes a type that can have a theme applied to it
protocol Themed {
    /// A Themed type needs to know about what concrete type the
    /// ThemeProvider is. So we don't clash with the protocol,
    /// let's call this associated type _ThemeProvider
    associatedtype _ThemeProvider: ThemeProvider
    
    /// Return the current app-wide theme provider
    var themeProvider: _ThemeProvider { get }
    
    /// This will be called whenever the current theme changes
    func applyTheme(_ theme: _ThemeProvider.Theme)
}

extension Themed where Self: AnyObject {
    /// This is to be called once when Self wants to start listening for
    /// theme changes. This immediately triggers `applyTheme()` with the
    /// current theme.
    func setupTheming() {
        applyTheme(themeProvider.currentTheme)
        themeProvider.subscribeToChanges(self) { [weak self] newTheme in
            self?.applyTheme(newTheme)
        }
    }
}
</code></pre>
<p>根据协议可以如下操作：</p>
<pre><code class="language-plain_text">final class AppThemeProvider: ThemeProvider {
    static let shared: AppThemeProvider = .init()
    
    private var theme: SubscribableValue&lt;AppTheme&gt;
    private var availableThemes: [AppTheme] = [.light, .dark]
    
    var currentTheme: AppTheme {
        get {
            return theme.value
        }
        set {
            setNewTheme(newValue)
        }
    }
    
    init() {
        theme = SubscribableValue&lt;AppTheme&gt;(value: .light)
    }
    
    private func setNewTheme(_ newTheme: AppTheme) {
        let window = UIApplication.shared.delegate!.window!!
        UIView.transition(
            with: window,
            duration: 0.3,
            options: [UIView.AnimationOptions.transitionCrossDissolve],
            animations: {
                self.theme.value = newTheme
        },
            completion: nil
        )
    }
    
    func subscribeToChanges(_ object: AnyObject, handler: @escaping (AppTheme) -&gt; Void) {
        theme.subscribe(object, using: handler)
    }
    
    func nextTheme() {
        guard let nextTheme = availableThemes.rotate() else {
            return
        }
        currentTheme = nextTheme
    }
}

extension Themed where Self: AnyObject {
    var themeProvider: AppThemeProvider {
        return AppThemeProvider.shared
    }
}
</code></pre>
<p>具体主题的颜色见<code>Theme.swift</code></p>
<p>由上面的实例我们知道所有页面都是被暂存的，暂存操作为</p>
<pre><code class="language-plain_text">private var theme: SubscribableValue&lt;AppTheme&gt;
</code></pre>
<p>SubscribableValue的具体实现见<code>SubscribableValue.swift</code>，这个结构是一个结构体,如下：</p>
<pre><code class="language-plain_text">/// Stores a value of type T, and allows objects to subscribe to
/// be notified with this value is changed.
struct SubscribableValue&lt;T&gt; {
	private typealias Subscription = (object: Weak&lt;AnyObject&gt;, handler: (T) -&gt; Void)

	private var subscriptions: [Subscription] = []

	var value: T {
		didSet {
			for (object, handler) in subscriptions where object.value != nil {
				handler(value)
			}
		}
	}

	init(value: T) {
		self.value = value
	}

	mutating func subscribe(_ object: AnyObject, using handler: @escaping (T) -&gt; Void) {
		subscriptions.append((Weak(value: object), handler))
		cleanupSubscriptions()
	}

	/// Removes any subscriptions where the object has been deallocated
	/// and no longer exists
	private mutating func cleanupSubscriptions() {
		subscriptions = subscriptions.filter({ entry in
			return entry.object.value != nil
		})
	}
}
</code></pre>
<p>上面的weak的实现为</p>
<pre><code class="language-plain_text">/// A box that allows us to weakly hold on to an object
struct Weak&lt;Object: AnyObject&gt; {
	weak var value: Object?
}
</code></pre>
<p>每个需要更换主题的控制器或者视图都会注册一下，<br />
<img src="media/16587402936345/15394143263288.jpg" alt="" style="width:1680px;" /></p>
<p><img src="media/16587402936345/15394143483076.jpg" alt="" style="width:1680px;" /></p>
<p><img src="media/16587402936345/15394143927777.jpg" alt="" style="width:1680px;" /></p>
<p>这个就是协议的默认实现，然后会把当前对象注册一下。<br />
每次赋值的时候都会更新一下所有注册的视图。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936429.html">Mac 下面Python 自动补全</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>网上有很多tab自动补全的脚本,但是在Mac上面都不能正常的运行,在<a href="http://stackoverflow.com/questions/7116038/python-tab-completion-mac-osx-10-7-lion">stackoverflow</a>找到一个能用的.</p>
<pre><code class="language-plain_text">import readline
import rlcompleter
if 'libedit' in readline.__doc__:
    readline.parse_and_bind(&quot;bind ^I rl_complete&quot;)
else:
    readline.parse_and_bind(&quot;tab: complete&quot;)

</code></pre>
<p>进入Python后直接import tab 就可以了</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936512.html"># 深入理解 iOS 事件机制</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>原文来自<a href="https://juejin.im/post/5d396ef7518825453b605afa">掘金</a></p>
</blockquote>
<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>这篇文章始于一个需求：我们在 SDK 提供的某个 View 的 Subview 中实现了单击双击等多个 Gesture Recognizer，而客户希望自己在这个 View 上的单击手势不会冲突，同时没有延迟。</p>
<p>借此机会，我们来重温下 iOS 的事件机制和手势冲突，重点介绍下 UIGestureRecognizer 之间以及与原生触摸事件的相互关系。</p>
<h2><a id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>事件的生命周期</h2>
<p>当指尖触碰屏幕时，一个触摸事件就在系统中生成了。经过 IPC 进程间通信，事件最终被传递到了合适的应用。在应用内历经峰回路转的奇幻之旅后，最终被释放。大致经过如下图：</p>
<p><img src="media/16587402936512/15654060901311.jpg" alt="" /></p>
<h3><a id="%E7%B3%BB%E7%BB%9F%E5%93%8D%E5%BA%94%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>系统响应阶段</h3>
<ol>
<li>
<p>手指触碰屏幕，屏幕感应到触碰后，将事件交由 IOKit 处理。</p>
</li>
<li>
<p>IOKit 将触摸事件封装成一个 IOHIDEvent 对象，并通过 mach port 传递给 SpringBoard 进程。</p>
</li>
</ol>
<blockquote>
<p>mach port 进程端口，各进程之间通过它进行通信。</p>
<p>SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。</p>
</blockquote>
<ol>
<li>SpringBoard 进程因接收到触摸事件，触发了主线程 runloop 的 source1 事件源的回调。此时 SpringBoard 会根据当前桌面的状态，判断应该由谁处理此次触摸事件。因为事件发生时，你可能正在桌面上翻页，也可能正在刷微博。若是前者（即前台无 APP 运行），则触发 SpringBoard 本身主线程 runloop 的 source0 事件源的回调，将事件交由桌面系统去消耗；若是后者（即有 APP 正在前台运行），则将触摸事件通过 IPC 传递给前台 APP 进程，接下来的事情便是 APP 内部对于触摸事件的响应了。</li>
</ol>
<h3><a id="app%E5%93%8D%E5%BA%94%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>APP响应阶段</h3>
<ol>
<li>
<p>APP 进程的 mach port 接受到 SpringBoard 进程传递来的触摸事件，主线程的 runloop 被唤醒，触发了 source1 回调。</p>
</li>
<li>
<p>source1 回调又触发了一个 source0 回调，将接收到的 IOHIDEvent 对象封装成 UIEvent 对象，此时 APP 将正式开始对于触摸事件的响应。</p>
</li>
<li>
<p>source0 回调内部将触摸事件添加到 UIApplication 对象的事件队列中。事件出队后，UIApplication 开始一个寻找最佳响应者的过程，这个过程又称 Hit-Testing，细节将在下一节阐述。另外，此处开始便是与我们平时开发相关的工作了。</p>
</li>
<li>
<p>寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。事实上，事件除了被响应者消耗，还能被手势识别器或是 Target-Action 模式捕捉并消耗掉。其中涉及对触摸事件的响应优先级。</p>
</li>
<li>
<p>触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么至死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop 若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。</p>
</li>
</ol>
<h2><a id="%E6%8E%A2%E6%B5%8B%E9%93%BE%E4%B8%8E%E5%93%8D%E5%BA%94%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>探测链与响应链</h2>
<h3><a id="hit-testing" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hit-Testing</h3>
<p>从逻辑上来说，探测链是最先发生的机制，当触摸事件发生后，iOS 系统根据 Hit-Testing 来确定触摸事件发生在哪个视图对象上。其中主要用到了两个 UIView 中的方法：</p>
<pre><code class="language-plain_text">// recursively calls -pointInside:withEvent:. point is in the receiver's coordinate system
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

// default returns YES if point is in bounds
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;
复制代码
</code></pre>
<p>前者会通过递归调用后者来返回一个适合响应触摸事件的视图，下面这张图描述了这个过程：</p>
<p><img src="media/16587402936512/15654061281073.jpg" alt="" /></p>
<h3><a id="responder-chain" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Responder Chain</h3>
<p>Hit-Testing 找到的视图拥有最先对触摸事件进行处理的机会，如果该视图无法处理这个事件，那么事件对象就会沿着响应器的视图链向上传递，直到找到可以处理该事件的对象为止。下面这张图描述了这个过程：</p>
<p><img src="media/16587402936512/15654061526891.jpg" alt="" /></p>
<h3><a id="demo%E9%AA%8C%E8%AF%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Demo 验证</h3>
<p>接下来我们通过官方文档的 Demo 以代码的方式来进行验证：</p>
<p><img src="media/16587402936512/15654061728509.jpg" alt="" /></p>
<p>对于每个 View，我们重载父类的方法：</p>
<pre><code class="language-plain_text">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    NSLog(@&quot;进入A_View---hitTest withEvent ---&quot;);
    UIView * view = [super hitTest:point withEvent:event];
    NSLog(@&quot;离开A_View--- hitTest withEvent ---hitTestView:%@&quot;,view);
    return view;
}

- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_view--- pointInside withEvent ---&quot;);
    BOOL isInside = [super pointInside:point withEvent:event];
    NSLog(@&quot;A_view--- pointInside withEvent --- isInside:%d&quot;,isInside);
    return isInside;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;A_touchesBegan&quot;);
    [super touchesBegan:touches withEvent:event];
}

- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_touchesMoved&quot;);
    [super touchesMoved:touches withEvent:event];
}

- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    NSLog(@&quot;A_touchesEnded&quot;);
    [super touchesEnded:touches withEvent:event];
}

-(void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;A_touchesCancelled&quot;);
    [super touchesCancelled:touches withEvent:event];
}
复制代码
</code></pre>
<p>点击 View D，log 显示如下，这与探测链与响应链的机制的描述相同。</p>
<pre><code class="language-plain_text">进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x12dd11e50; frame = (0 37; 240 61); autoresize = RM+BM; layer = &lt;CALayer: 0x283f87b40&gt;&gt;
D_touchesBegan
C_touchesBegan
A_touchesBegan
D_touchesEnded
C_touchesEnded
A_touchesEnded
复制代码
</code></pre>
<p>（这里其实 Hit-Testing 进行了两次，关于这个问题，苹果官方有相应的回复）</p>
<blockquote>
<p>Yes, it’s normal. The system may tweak the point being hit tested between the calls. Since hitTest should be a pure function with no side-effects, this should be fine.</p>
</blockquote>
<h3><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h3>
<p><strong>1. 系统通过 <code>hitTest:withEvent:</code> 方法沿视图层级树从底向上（从根视图开始）从后向前（从逻辑上更靠近屏幕的视图开始）进行遍历，最终返回一个适合响应触摸事件的 View。</strong></p>
<p><strong>2. 原生触摸事件从 Hit-Testing 返回的 View 开始，沿着响应链从上向下进行传递。</strong></p>
<p>探测链与响应链的机制总体比较清晰，不再赘述，但熟悉这两个机制并不能帮我们解决任何问题，接下来我们继续深入探究下手势识别器。</p>
<h2><a id="%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手势识别器</h2>
<p>我们首先思考一个问题，对于官方文档里的 Demo，我们在每个 View 上添加一个 UITapGestureRecognizer，当点击 View D 时，UITapGestureRecognizer 之间的响应顺序是什么样的，哪个 View 上的 UITapGestureRecognizer 又会最终响应这个事件？</p>
<h3><a id="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>官方文档</h3>
<p>我们先来看看官方文档是怎么说的：</p>
<blockquote>
<p>When a view has multiple gesture recognizers attached to it, you may want to alter how the competing gesture recognizers receive and analyze touch events. By default, there is no set order for which gesture recognizers receive a touch first, and for this reason touches can be passed to gesture recognizers in a different order each time. You can override this default behavior to:</p>
<ul>
<li>
<p>Specify that one gesture recognizer should analyze a touch before another gesture recognizer.</p>
</li>
<li>
<p>Allow two gesture recognizers to operate simultaneously.</p>
</li>
<li>
<p>Prevent a gesture recognizer from analyzing a touch.</p>
</li>
</ul>
<p>Use the UIGestureRecognizer class methods, delegate methods, and methods overridden by subclasses to effect these behaviors.</p>
</blockquote>
<p>根据文档的说法，当触摸事件发生时，哪个 UIGestureRecognizer 先收到这个事件并没有固定的顺序，并且文档建议我们使用 UIGestureRecognizer 提供的方法来控制它们之间的顺序和相互关系。</p>
<h3><a id="uigesturerecognizer-methods" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UIGestureRecognizer Methods</h3>
<p>所以我们依次看下系统的 UIGestureRecognizer 都提供了哪些与它们之间相互关系有关的方法：</p>
<pre><code class="language-plain_text">// create a relationship with another gesture recognizer that will prevent this gesture's actions from being called until otherGestureRecognizer transitions to UIGestureRecognizerStateFailed
// if otherGestureRecognizer transitions to UIGestureRecognizerStateRecognized or UIGestureRecognizerStateBegan then this recognizer will instead transition to UIGestureRecognizerStateFailed
// example usage: a single tap may require a double tap to fail
- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer;

// called once per attempt to recognize, so failure requirements can be determined lazily and may be set up between recognizers across view hierarchies
// return YES to set up a dynamic failure requirement between gestureRecognizer and otherGestureRecognizer
//
// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture's counterpart delegate or subclass methods may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
复制代码
</code></pre>
<p>这三个方法比较常用，它们可以指定 UIGestureRecognizer 之间的依赖关系，区别在于第一个一般适用于在同一个 View 中创建的多个 UIGestureRecognizer 的场景，当 View 层级比较复杂或者 UIGestureRecognizer 处于 Framework 内部时可以用后两个方法动态指定。</p>
<pre><code class="language-plain_text">// called when the recognition of one of gestureRecognizer or otherGestureRecognizer would be blocked by the other
// return YES to allow both to recognize simultaneously. the default implementation returns NO (by default no two gestures can be recognized simultaneously)
//
// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture's delegate may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;
复制代码
</code></pre>
<p>这个方法可以控制两个 UIGestureRecognizer 之间是否可以同时异步进行，需要注意的是，假设存在两个可能会互相 block 的 UIGestureRecognizer，系统会分别对它们的 delegate 调用这个方法，只要有一个返回 YES，那么这两个 UIGestureRecognizer 就可以同时进行识别，这与 <code>shouldRequireFailureOfGestureRecognizer</code> 是类似的。</p>
<pre><code class="language-plain_text">// called before touchesBegan:withEvent: is called on the gesture recognizer for a new touch. return NO to prevent the gesture recognizer from seeing this touch
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;

// called when a gesture recognizer attempts to transition out of UIGestureRecognizerStatePossible. returning NO causes it to transition to UIGestureRecognizerStateFailed
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;
复制代码
</code></pre>
<p>这两个方法都是用来禁止 UIGestureRecognizer 响应触摸事件的，区别在于，当触摸事件发生时，使用第一个方法可以立即控制 UIGestureRecognizer 是否对其处理，且不会修改 UIGestureRecognizer 的状态机（因为在调用自身的 <code>touchesBegan:withEvent:</code> 之前，详见下），而第二个方法会等待一段时间，在 UIGestureRecognizer 识别手势转换状态时调用，返回 NO 会改变其状态机，使其 state 变为 <code>UIGestureRecognizerStateFailed</code>。</p>
<p>我们看下官方文档对这两个方法的说明：</p>
<blockquote>
<p>When a touch begins, if you can immediately determine whether or not your gesture recognizer should consider that touch, use thegestureRecognizer:shouldReceiveTouch: method. This method is called every time there is a new touch. Returning NO prevents the gesture recognizer from being notified that a touch occurred. The default value is YES. This method does not alter the state of the gesture recognizer.</p>
<p>If you need to wait as long as possible before deciding whether or not a gesture recognizer should analyze a touch, use thegestureRecognizerShouldBegin: delegate method. Generally, you use this method if you have a UIView or UIControl subclass with custom touch-event handling that competes with a gesture recognizer. Returning NO causes the gesture recognizer to immediately fail, which allows the other touch handling to proceed. This method is called when a gesture recognizer attempts to transition out of the Possible state, if the gesture recognition would prevent a view or control from receiving a touch.</p>
<p>You can use the gestureRecognizerShouldBegin:UIView method if your view or view controller cannot be the gesture recognizer’s delegate. The method signature and implementation is the same.</p>
</blockquote>
<p>第二段介绍了通常情况下，当我们的子类 UIView 或 UIControl 有和 UIGestureRecognizer 冲突的自定义触摸事件时，可以使用 <code>gestureRecognizerShouldBegin:</code> 方法让 UIGestureRecognizer 失效来使自定义的触摸事件进行响应。第三段说明了当我们的 View 不是 UIGestureRecognizer 的 delegate 时，可以使用 UIView 中的 <code>gestureRecognizerShouldBegin:</code> 方法。关于这两段的意思我们会在后两节去详细解释。</p>
<pre><code class="language-plain_text">// mirror of the touch-delivery methods on UIResponder
// UIGestureRecognizers aren't in the responder chain, but observe touches hit-tested to their view and their view's subviews
// UIGestureRecognizers receive touches before the view to which the touch was hit-tested
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);
复制代码
</code></pre>
<p>与 UIResponder 中的触摸事件相关的方法相同，UIGestureRecognizer 有一套自己的触摸事件的方法，区别在于，UIGestureRecognizer 并不在响应链中，这些方法一般是写用来对特定的手势进行判断和识别的逻辑，例如我们可以在子类中重写这些方法来创建自己的 UIGestureRecognizer。使用 <code>gestureRecognizer:shouldReceiveTouch:</code> 可以让这些方法不被调用。</p>
<p>至此，UIGestureRecognizer 已经为我们提供了足够多的方法来控制它们之间的相互关系了，我们接下来在 Demo 中试试看。</p>
<h3><a id="demo%E9%AA%8C%E8%AF%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Demo 验证</h3>
<p>对于官方文档中的 Demo 的每个 View，我们增加一个继承自 UITapGestureRecognizer 的 ZTTapGestureRecognizer 并实现相应的回调：</p>
<pre><code class="language-plain_text">- (void)singleTapGesture
{
    NSLog(@&quot;A_singleTapGesture&quot;);
}

- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
    NSLog(@&quot;A_view--- gestureRecognizerShouldBegin: %@ ---&quot;, gestureRecognizer.name);
    return YES;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch
{
    NSLog(@&quot;A_view--- gestureRecognizer shouldReceiveTouch: %@ ---&quot;, gestureRecognizer.name);
    return YES;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    NSLog(@&quot;A_view--- gestureRecognizer: %@ otherGestureRecognizer: %@ ---&quot;, gestureRecognizer.name, otherGestureRecognizer.name);
    return YES;
}

- (instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;A_view_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];
    }

    return self;
}
复制代码
</code></pre>
<p>在我们子类 ZTTapGestureRecognizer 中重写父类关于触摸事件的方法：</p>
<pre><code class="language-plain_text">@implementation ZTTapGestureRecognizer

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;%@_touchesBegan&quot;, self.name);
    [super touchesBegan:touches withEvent:event];
}

- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    NSLog(@&quot;%@_touchesMoved&quot;, self.name);
    [super touchesMoved:touches withEvent:event];
}

// NSLog 要写在 super 后面来读取 state
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    [super touchesEnded:touches withEvent:event];
    NSLog(@&quot;%@_touchesEndedWithState: %d&quot;, self.name, (int)self.state);
}

// NSLog 要写在 super 后面来读取 state
-(void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    [super touchesCancelled:touches withEvent:event];
    NSLog(@&quot;%@_touchesCancelledWithState: %d&quot;, self.name, (int)self.state);
}

@end
复制代码
</code></pre>
<p>点击 View D，log 显示如下：</p>
<pre><code class="language-plain_text">进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
进入A_View---hitTest withEvent ---
A_view--- pointInside withEvent ---
A_view--- pointInside withEvent --- isInside:1
进入C_View---hitTest withEvent ---
C_view---pointInside withEvent ---
C_view---pointInside withEvent --- isInside:1
进入E_View---hitTest withEvent ---
E_view---pointInside withEvent ---
E_view---pointInside withEvent --- isInside:0
离开E_View---hitTest withEvent ---hitTestView:(null)
进入D_View---hitTest withEvent ---
D_view---pointInside withEvent ---
D_view---pointInside withEvent --- isInside:1
离开D_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开C_View---hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
离开A_View--- hitTest withEvent ---hitTestView:&lt;DView: 0x104d31050; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x281b77fc0&gt;; layer = &lt;CALayer: 0x2815e6ca0&gt;&gt;
D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
D_touchesBegan
C_touchesBegan
A_touchesBegan
D_view--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesEndedWithState: 3
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: (null) ---
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer: A_view_tapGestureRecognizer otherGestureRecognizer: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: A_view_tapGestureRecognizer ---
C_view--- gestureRecognizer: C_view_tapGestureRecognizer otherGestureRecognizer: D_view_tapGestureRecognizer ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: A_view_tapGestureRecognizer ---
D_view--- gestureRecognizer: D_view_tapGestureRecognizer otherGestureRecognizer: C_view_tapGestureRecognizer ---
A_singleTapGesture
D_touchesCancelled
C_touchesCancelled
A_touchesCancelled
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>
<p>信息量有点大，我们一点一点来分析（<strong>先忽略 View 响应链里 UIResponder 相关的触摸事件方法，这些会在下一节进行探讨</strong>），首先系统通过 Hit-Testing 机制找到了适合响应的 View D，接下来调用了方法：</p>
<pre><code class="language-plain_text">D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
复制代码
</code></pre>
<p>上文已经对 <code>gestureRecognizer:shouldReceiveTouch:</code> 解释过，先调用它是没有问题的，但是在多次实验中，一直都是 D C A 的顺序，而 UIGestureRecognizer 其他的 Delegate Method 却有可能是不同的顺序，这是为什么呢？</p>
<p>我们来看下 View D 这个方法的调用栈：</p>
<p><img src="media/16587402936512/15654062505074.jpg" alt="" /></p>
<p>可以看到，UITouchesEvent 遍历了一个 View 数组，系统通过 Hit-Testing 过程得到了适合响应触摸事件的 View D，随后会根据这个 View 的层级关系得到一个响应链 View 数组 [D_view, C_view, A_view, ..., ZTWindow] 然后遍历这个数组去依次判断每个 View 上的 UIGestureRecognizer 是否要接收触摸事件，没有绑定到这个响应链 View 数组上的 UIGestureRecognizer 不再有机会去处理触摸事件，关于原因后面会解释。</p>
<p>接下来调用了方法：</p>
<pre><code class="language-plain_text">D_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan

D_view--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer ---
D_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer ---
A_view_tapGestureRecognizer_touchesEndedWithState: 3
D_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesEndedWithState: 3
复制代码
</code></pre>
<p>View A 中 <code>gestureRecognizerShouldBegin:</code> 方法的调用栈：</p>
<p><img src="media/16587402936512/15654062776619.jpg" alt="" /></p>
<p>由于我们的 <code>gestureRecognizer:shouldReceiveTouch:</code> 都返回了 YES，3个 View 上的 UIGestureRecognizer 分别收到了 <code>touchesBegan</code> 和 <code>touchesEnd</code> 等触摸事件相关的 方法并开始对触摸手势进行识别。从调用栈中可以看出，在 <code>touchesEnd</code> 方法中手势识别完成之后即将进行状态转换之前调用了 <code>gestureRecognizerShouldBegin:</code> 方法判断是否应该进行手势识别成功的状态转换，由于我们的方法都返回了 YES，可以看到在 <code>touchesEnd</code> 方法完成之后3个 UIGestureRecognizer 都成功识别了手势并且自身的 state 都变成了 <code>UIGestureRecognizerStateEnded</code>，这些与我们上一小节的描述是相符的。</p>
<p>需要注意的是，对于 A_view_tapGestureRecognizer 和 C_view_tapGestureRecognizer 来说，除了它们各自的 delegate，最上层的 View D 也收到了他们的 <code>gestureRecognizerShouldBegin:</code> 回调，这是为什么呢？回顾上一小节关于这个方法官方文档的解释，UIView 自身也有一个 <code>gestureRecognizerShouldBegin:</code> 方法，当 View 不是 UIGestureRecognizer 的 delegate 时，我们可以使用这个方法来使 UIGestureRecognizer 失效。对于所有绑定到父 View 上的 UIGestureRecognizer，除了它们本身的 delegate 之外，Hit-Testing 返回的 View 也会收到这个方法的调用，关于原因我们会在下一节进行解释。</p>
<p>接下来的 log 是 UIGestureRecognizer 是否可以同时处理触摸事件的回调方法，其中的 null 是系统的手势 UIScreenEdgePanGestureRecognizer，由于 Demo 使用了 UINavigationController 系统会首先判断这个手势法是否能同时响应。可以看到，由于这3个 View 上一共存在3个 UIGestureRecognizer，系统一共调用了6次回调方法才可以确定它们之间的关系，这和我们上文对该方法的描述相符。</p>
<p>需要注意的是，UIGestureRecognizer 触摸事件相关的方法 <code>touchesBegan</code> 等和 <code>gestureRecognizerShouldBegin:</code> 对于 View A C D 来说每次运行顺序是不一样的（<code>gestureRecognizer:shouldReceiveTouch:</code> 每次都是 D C A），但最终 UIGestureRecognizer 的 Action Method 的顺序却一定是 A C D：</p>
<pre><code class="language-plain_text">A_singleTapGesture
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>
<p>同时，当 <code>shouldRecognizeSimultaneouslyWithGestureRecognizer</code> 都返回 NO 时，View D 上的 UIGestureRecognizer 可以响应成功。这又是什么原因呢？</p>
<p>我们在上一步 UITouchesEvent 遍历响应链 View 数组的过程中得到了一个 UIGestureRecognizer 数组 [D_view_tapGestureRecognizer, C_view_tapGestureRecognizer, A_view_tapGestureRecognizer] 随后系统遍历了这个数组来进行处理，这里猜测它们的 <code>touchesBegan</code> 等方法的顺序应该与具体的实现有关（个人猜测可能与 UIGestureEnvironment 里保存的 UIGestureRecognizer 的数据结构实际上不是数组而是图有关系），而 Action Method 的顺序以及最后确保 View D 上的 UIGestureRecognizer 能够响应成功应该也是目前官方未说明的某种机制。</p>
<p>还有一点需要注意的是，<code>gestureRecognizer:shouldReceiveTouch:</code> 与其他的方法不属于相同的调用栈，我们来看下其他方法的调用栈：</p>
<p><img src="media/16587402936512/15654062975213.jpg" alt="" /></p>
<p><img src="media/16587402936512/15654063204292.jpg" alt="" /></p>
<p>可以看到，最先由 UIApplication 通过 <code>sendEvent:</code> 发送了 UIEvent 事件，然后被 UIWindow 转发给了 UIGestureEnvironment，而 UIGestureEnvironment 通过遍历一个 UIGestureRecognizer 数组来调起相关的 UIGestureRecognizer 方法。</p>
<p>到此为止，整个过程仍然有很多疑点，我们重新进行下梳理。</p>
<h3><a id="uievent%E4%B8%8E-uigestureenvironment" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UIEvent 与 UIGestureEnvironment</h3>
<p>实际上，系统最先通过 Hit-Testing 机制来对 UIEvent 进行了包装，我们先看下 UIEvent 这个类：</p>
<pre><code class="language-plain_text">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIEvent : NSObject

@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);

@property(nonatomic,readonly) NSTimeInterval  timestamp;

#if UIKIT_DEFINE_AS_PROPERTIES
@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;
#else
- (nullable NSSet &lt;UITouch *&gt; *)allTouches;
#endif
- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;
- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;
- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture NS_AVAILABLE_IOS(3_2);

@end
复制代码
</code></pre>
<p>可以看到 UIEvent 所有的属性都是只读以防止被修改，在 View A 的 <code>hitTest:withEvent:</code> 方法中，实际传递的是它的子类 UITouchesEvent：</p>
<p><img src="media/16587402936512/15654063416976.jpg" alt="" /></p>
<p>在 Hit-Testing 阶段，UIEvent 只包含了一个时间戳信息，我们在 View A 的 <code>hitTest:withEvent:</code>方法中打断点来查看下 UITouchesEvent 的内容：</p>
<p><img src="media/16587402936512/15654063597676.jpg" alt="" /></p>
<p>接下来，我们继承 UIWindow 来截获 <code>sendEvent:</code> 事件，并打断点来查看此时 UIEvent 的信息，此时 UIEvent 中多了 UITouch：</p>
<p><img src="media/16587402936512/15654063714528.jpg" alt="" /></p>
<pre><code class="language-plain_text">Printing description of event:
&lt;UITouchesEvent: 0x2819a8120&gt; timestamp: 875742 touches: {(
    &lt;UITouch: 0x11bd35960&gt; phase: Began tap count: 1 force: 0.000 window: &lt;UIWindow: 0x11bd1c610; frame = (0 0; 414 736); gestureRecognizers = &lt;NSArray: 0x2825c94d0&gt;; layer = &lt;UIWindowLayer: 0x282bb5900&gt;&gt; view: &lt;DView: 0x11be2faa0; frame = (0 37; 240 61); autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x2825f2a60&gt;; layer = &lt;CALayer: 0x282b894a0&gt;&gt; location in window: {234.66665649414062, 482.66665649414062} previous location in window: {234.66665649414062, 482.66665649414062} location in view: {147.66665649414062, 35.666656494140625} previous location in view: {147.66665649414062, 35.666656494140625}
)}
复制代码
</code></pre>
<p>根据 UIEvent 和 UITouchesEvent 的 API 和以上信息，我们可以推断，系统通过 Hit-Testing 记录了适合响应触摸事件的 View 与 Window 等信息，在 Hit-Testing 完成之后，创建了 UITouch 并将其保存在 UIEvent 中进行发送。UIApplication 能够通过 <code>sendEvent:</code> 方法发送事件给正确的 UIWindow 正是由于在 Hit-Testing 过程中系统记录了能够响应触摸事件的 Window。</p>
<p>而 UITouch 中的 UIGestureRecognizer 数组正是通过前面提到的 <code>gestureRecognizer:shouldReceiveTouch:</code> 来生成的，我们来看下在 Hit-Testing 完成之后，<code>sendEvent:</code> 调用之前，View D 的 <code>gestureRecognizer:shouldReceiveTouch:</code> 方法中的 UITouch：</p>
<p><img src="media/16587402936512/15654063890469.jpg" alt="" /></p>
<p>此时，Window 和 DView 已经通过 Hit-Testing 找到，但是 <code>_gestureRecognizers</code> 仍然为空，而在该方法返回 YES 之后，我们在 View C 的 <code>gestureRecognizer:shouldReceiveTouch:</code> 方法中可以看到：</p>
<p><img src="media/16587402936512/15654064024881.jpg" alt="" /></p>
<p>此时 D_view_tapGestureRecognizer 已经被添加到了数组中，同样的，在 View A 的方法中，C_view_tapGestureRecognizer 被添加到了数组中，在最终的 UIEvent 中的 UITouch 里，3个 UIGestureRecognizer 都被保存了起来，所以 UIApplication 才知道如何向正确的 UIGestureRecognizer 发送触摸事件。</p>
<p>接下来说下 UIGestureEnvironment，我们可以认为它是管理所有手势的上下文环境，当调用 <code>addGestureRecognizer:</code> 方法时会将 UIGestureRecognizer 加入到其中。下面是 UIGestureEnvironment 的结构：</p>
<pre><code class="language-plain_text">@interface UIApplication : UIResponder  {
    UIGestureEnvironment * __gestureEnvironment;
    }
@end

@interface UIGestureRecognizer : NSObject {
    UIGestureEnvironment * _gestureEnvironment;
    }
@end

@interface UIGestureEnvironment : NSObject {

	CFRunLoopObserverRef _gestureEnvironmentUpdateObserver;
	NSMutableSet* _gestureRecognizersNeedingUpdate;
	NSMutableSet* _gestureRecognizersNeedingReset;
	NSMutableSet* _gestureRecognizersNeedingRemoval;
	NSMutableArray* _dirtyGestureRecognizers;
	NSMutableArray* _delayedTouches;
	NSMutableArray* _delayedTouchesToSend;
	NSMutableArray* _delayedPresses;
	NSMutableArray* _delayedPressesToSend;
	NSMutableArray* _preUpdateActions;
	bool _dirtyGestureRecognizersUnsorted;
	bool _updateExclusivity;
	UIGestureGraph* _dependencyGraph;
	NSMapTable* _nodesByGestureRecognizer;

}

-(void)addGestureRecognizer:(id)arg1 ;
-(void)removeGestureRecognizer:(id)arg1 ;
-(void)_cancelGestureRecognizers:(id)arg1 ;
-(void)_updateGesturesForEvent:(id)arg1 window:(id)arg2 ;
（省略了很多 API）
-(void)_cancelTouches:(id)arg1 event:(id)arg2 ;
-(void)_cancelPresses:(id)arg1 event:(id)arg2 ;
@end
复制代码
</code></pre>
<p>UIApplication 和 UIGestureRecognizer 中保存了同一个 UIGestureEnvironment 对象，根据上面 UIGestureRecognizer 的 Action Method 的调用栈，我们可以看到，UIWindow 通过 <code>sendEvent:</code>发送事件之后，UIGestureEnvironment 接收了这个事件并且最终通过方法：</p>
<pre><code class="language-plain_text">-[UIGestureEnvironment _updateForEvent:window:] ()
-[UIGestureEnvironment _deliverEvent:toGestureRecognizers:usingBlock:] ()
复制代码
</code></pre>
<p>来对 UIGestureRecognizer 相关方法进行调用：</p>
<ol>
<li>对能够处理事件的 UIGestureRecognizer 发送 <code>touchesBegan:withEvent:</code> 等触摸事件的方法</li>
<li>通过 <code>gestureRecognizerShouldBegin</code> 方法判断是否应该进行状态转换</li>
<li>询问 UIGestureRecognizer 的 delegate 是否应该失效或者是否能够同时处理事件<code>gestureRecognizer:shouldRequireFailureOfGestureRecognizer:``gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:</code></li>
<li>UIGestureRecognizer 识别事件之后最终调用了 Action Method</li>
</ol>
<h3><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h3>
<p><strong>1. 系统在探测阶段结束后创建了 UITouch，并封装了 UIEvent 将其传递。</strong></p>
<p><strong>2. 手势上下文 UIGestureEnvironment 最先收到 UIEvent，并负责通知给相关的 UIGestureRecognizer。</strong></p>
<p><strong>3. UIGestureEnvironment 根据 UIGestureRecognizer 的 delegate 方法来判断其是否能够对触摸事件进行响应。</strong></p>
<p>至此，UIGestureRecognizer 对事件的处理以及它们之间的相互关系告一段落。需要注意的是，建议最好使用官方文档推荐的方法对 UIGestureRecognizer 进行控制，而不要依赖上文中没有存在于文档中的具体实现细节和结论，苹果没有对外暴露这些，有可能会在接下来的版本中修改具体实现。</p>
<h2><a id="%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%E5%99%A8%E4%B8%8E%E5%8E%9F%E7%94%9F%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手势识别器与原生触摸事件</h2>
<p>接下来我们终于可以对上一节中 UIResponder 相关的系统原生触摸事件方法进行探讨了，我们去掉 Hit-Testing 与 UIGestureRecognizer 的 delegate 等相关方法，重新运行 Demo，点击 View D，log 显示如下：</p>
<pre><code class="language-plain_text">A_view_tapGestureRecognizer_touchesBegan
D_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
D_touchesBegan
C_touchesBegan
A_touchesBegan
A_singleTapGesture
D_touchesCancelled
C_touchesCancelled
A_touchesCancelled
C_singleTapGesture
D_singleTapGesture
复制代码
</code></pre>
<h3><a id="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>官方文档</h3>
<p>按照惯例，我们先来看下官方文档是怎么说的：</p>
<blockquote>
<p>There may be times when you want a view to receive a touch before a gesture recognizer. But, before you can alter the delivery path of touches to views, you need to understand the default behavior. In the simple case, when a touch occurs, the touch object is passed from the UIApplication object to the UIWindow object. Then, the window first sends touches to any gesture recognizers attached the view where the touches occurred (or to that view’s superviews), before it passes the touch to the view object itself.</p>
<p>Gesture Recognizers Get the First Opportunity to Recognize a Touch</p>
<p>A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence.</p>
</blockquote>
<p><img src="media/16587402936512/15654064332119.jpg" alt="" /></p>
<p>文档实际上说的比较清楚：UIWindow 会先将触摸事件发送给 Hit-Testing 返回的 View 和它的父 View 上的 UIGestureRecognizer，然后才会发送给这个 View 本身，如果 UIGestureRecognizer 成功识别了这个手势，之后 UIWindow 不会再向 View 发送触摸事件，并且会取消之前发送的触摸事件。</p>
<p>下面让我们回到 Demo 来进行验证。</p>
<h3><a id="demo%E9%AA%8C%E8%AF%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Demo 验证</h3>
<p>从 log 上看，现象与官方文档的说法吻合，我们用几个调用栈来对其进行进一步证明：</p>
<p>ZTTapGestureRecognizer 的 <code>touchesBegan:withEvent:</code> 的调用栈:</p>
<p><img src="media/16587402936512/15654064509943.jpg" alt="" /></p>
<p>View D 的 <code>touchesBegan:withEvent:</code> 的调用栈：</p>
<p><img src="media/16587402936512/15654064661803.jpg" alt="" /></p>
<p>View D 的 <code>touchesCancelled:withEvent:</code> 的调用栈：</p>
<p><img src="media/16587402936512/15654064771703.jpg" alt="" /></p>
<p>可以看到，UIWindow 首先通过 <code>sendEvent:</code> 方法经过 UIGestureEnvironment 发送触摸事件给了 ZTTapGestureRecognizer，随后通过 <code>sendTouchesForEvent:</code> 方法发送触摸事件给 View D 并沿着响应链传递，而当 A_view_tapGestureRecognizer 第一个成功识别手势之后，UIGestureEnvironment 发起响应链的 cancel 并经过 UIApplication 发送给 View D 并沿着响应链取消。</p>
<h3><a id="uigesturerecognizer-properties" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UIGestureRecognizer Properties</h3>
<p>UIGestureRecognizer 有一些与响应链触摸事件相关的属性，这里简单说明一下：</p>
<pre><code class="language-plain_text">// default is YES. causes touchesCancelled:withEvent: or pressesCancelled:withEvent: to be sent to the view for all touches or presses recognized as part of this gesture immediately before the action method is called.
@property(nonatomic) BOOL cancelsTouchesInView;
复制代码
</code></pre>
<p>这个属性可以控制当 UIGestureRecognizer 成功识别手势之后是否要取消响应链对触摸事件的响应，默认为 YES，设置为 NO 之后，即使 UIGestureRecognizer 识别了手势，UIGestureEnvironment 也不会发起对响应链的 cancel。</p>
<pre><code class="language-plain_text">// default is NO.  causes all touch or press events to be delivered to the target view only after this gesture has failed recognition. set to YES to prevent views from processing any touches or presses that may be recognized as part of this gesture
@property(nonatomic) BOOL delaysTouchesBegan;
复制代码
</code></pre>
<p>设置为 YES 时，这个属性可以控制在 UIGestureRecognizer 识别手势期间截断事件，识别失败后响应链才能收到触摸事件。</p>
<pre><code class="language-plain_text">// default is YES. causes touchesEnded or pressesEnded events to be delivered to the target view only after this gesture has failed recognition. this ensures that a touch or press that is part of the gesture can be cancelled if the gesture is recognized
@property(nonatomic) BOOL delaysTouchesEnded;
复制代码
</code></pre>
<p>默认为 YES，当手势识别失败时，若此时触摸事件已经结束，会延迟一小段时间（0.15s）再调用响应者的 <code>touchesEnded:withEvent:</code>，若设置成NO，则在手势识别失败时会立即通知 UIApplication 发送状态为 end 的 触摸事件给 Hit-Testing 返回的 View 以调用 <code>touchesEnded:withEvent:</code> 结束事件响应。</p>
<h3><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h3>
<p><strong>1. UIGestureRecognizer 首先收到触摸事件，Hit-Testing 返回的 View 延迟收到，两者的调起方法不同。</strong></p>
<p><strong>2. 第一个 UIGestureRecognizer 识别成功后，UIGestureEnvironment 会发起响应链的 cancel。</strong></p>
<p><strong>3. 可以通过设置 UIGestureRecognizer 的 Properties 来控制对响应链的影响。</strong></p>
<h2><a id="uicontrol%E7%89%B9%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UIControl 特例</h2>
<p>我们现在给 Demo 中的 View D 上加一个 UIButton：</p>
<p><img src="media/16587402936512/15654064977862.jpg" alt="" /></p>
<pre><code class="language-plain_text">- (void)buttonTapped
{
    NSLog(@&quot;D_buttonTapped&quot;);
}

- (instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;D_view_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];

        FButton *button = [[FButton alloc] initWithFrame:CGRectMake(80, 10, 100, 40)];
        button.backgroundColor = [UIColor blueColor];
        [button addTarget:self action:@selector(buttonTapped) forControlEvents:UIControlEventTouchUpInside];
        [self addSubview:button];
    }

    return self;
}
复制代码
</code></pre>
<p>点击 Button，log 显示如下：</p>
<pre><code class="language-plain_text">D_view--- gestureRecognizer shouldReceiveTouch: D_view_tapGestureRecognizer ---
C_view--- gestureRecognizer shouldReceiveTouch: C_view_tapGestureRecognizer ---
A_view--- gestureRecognizer shouldReceiveTouch: A_view_tapGestureRecognizer ---
C_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan
D_view_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesEndedWithState: 5
A_view_tapGestureRecognizer_touchesEndedWithState: 5
D_view_tapGestureRecognizer_touchesEndedWithState: 5
D_buttonTapped
复制代码
</code></pre>
<p>这与我们想象的完全不同：</p>
<ol>
<li>UIGestureRecognizer 没有响应触摸事件且除了 <code>shouldReceiveTouch</code> 之外的回调没有被调用。</li>
<li>触摸事件没有沿着响应链进行传递。</li>
<li>UIButton 成功的响应了触摸事件。</li>
</ol>
<p>这又是什么原因导致的呢？</p>
<h3><a id="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>官方文档</h3>
<p>惯例，先看官方文档：</p>
<blockquote>
<p>Interacting with Other User Interface Controls</p>
<p>In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes:</p>
<ul>
<li>
<p>A single finger single tap on a UIButton, UISwitch, UIStepper, UISegmentedControl, and UIPageControl.</p>
</li>
<li>
<p>A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.</p>
</li>
<li>
<p>A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch.</p>
</li>
</ul>
<p>If you have a custom subclass of one of these controls and you want to change the default action, attach a gesture recognizer directly to the control instead of to the parent view. Then, the gesture recognizer receives the touch event first. As always, be sure to read the iOS Human Interface Guidelines to ensure that your app offers an intuitive user experience, especially when overriding the default behavior of a standard control.</p>
</blockquote>
<p>这次文档解释清楚了所有的原因：对于 <strong>部分 UIControl</strong> 来说（自己实现的不行），为了防止 UIControl 默认的手势与其父 View 上的 UIGestureRecognizer 的冲突，UIControl 最后会响应触摸事件，如果想要 UIGestureRecognizer 处理触摸事件，则需要将其直接与 UIControl 进行绑定。</p>
<p>原因清楚了，但是我们还是回到 Demo 之中来看看系统具体是怎么做的。</p>
<h3><a id="demo%E9%AA%8C%E8%AF%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Demo 验证</h3>
<p>我们去掉 View A C D 中的 log，实现一个 UIButton 的子类 FButton，对 FButton 添加一个 ZTTapGestureRecognizer，并且实现方法 <code>gestureRecognizerShouldBegin：</code>：</p>
<pre><code class="language-plain_text">@implementation FButton

- (void)singleTapGesture
{
    NSLog(@&quot;F_singleTapGesture&quot;);
}

- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
    if ([super gestureRecognizerShouldBegin:gestureRecognizer])
    {
        NSLog(@&quot;F_Button--- gestureRecognizerShouldBegin: %@ YES ---&quot;, gestureRecognizer.name);
    }
    else
    {
        NSLog(@&quot;F_Button--- gestureRecognizerShouldBegin: %@ NO ---&quot;, gestureRecognizer.name);
    }

    return [super gestureRecognizerShouldBegin:gestureRecognizer];
}

- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];

    if (self)
    {
        ZTTapGestureRecognizer *tapGestureRecognizer = [[ZTTapGestureRecognizer alloc] initWithTarget:self action:@selector(singleTapGesture)];
        tapGestureRecognizer.name = @&quot;F_Button_tapGestureRecognizer&quot;;
        tapGestureRecognizer.delegate = self;
        [self addGestureRecognizer:tapGestureRecognizer];
    }

    return self;
}

@end
复制代码
</code></pre>
<p>运行 Demo，点击 Button，log 如下所示：</p>
<pre><code class="language-plain_text">D_view_tapGestureRecognizer_touchesBegan
F_Button_tapGestureRecognizer_touchesBegan
C_view_tapGestureRecognizer_touchesBegan
A_view_tapGestureRecognizer_touchesBegan

F_Button--- gestureRecognizerShouldBegin: D_view_tapGestureRecognizer NO ---
D_view_tapGestureRecognizer_touchesEndedWithState: 5
F_Button--- gestureRecognizerShouldBegin: F_Button_tapGestureRecognizer YES ---
F_Button_tapGestureRecognizer_touchesEndedWithState: 3
F_Button--- gestureRecognizerShouldBegin: C_view_tapGestureRecognizer NO ---
C_view_tapGestureRecognizer_touchesEndedWithState: 5
F_Button--- gestureRecognizerShouldBegin: A_view_tapGestureRecognizer NO ---
A_view_tapGestureRecognizer_touchesEndedWithState: 5

F_singleTapGesture
复制代码
</code></pre>
<p>可以看到 View A C D 和 Button F 上的 ZTTapGestureRecognizer 都收到了 <code>touchesBegan</code> 方法，但是最后只有 F_Button_tapGestureRecognizer 最终成功进行了状态转换，其原因就在于方法 <code>gestureRecognizerShouldBegin:</code>。</p>
<p>还记得前两节我们对于 <code>gestureRecognizerShouldBegin:</code> 的探讨吗，我们终于能够进一步对其进行解释了，这个机会还是留给官方文档：</p>
<blockquote>
<p>Subclasses may override this method and use it to prevent the recognition of particular gestures. For example, the UISlider class uses this method to prevent swipes parallel to the slider’s travel direction and that start in the thumb.</p>
<p>At the time this method is called, the gesture recognizer is in the UIGestureRecognizerStatePossible state and thinks it has the events needed to move to the UIGestureRecognizerStateBegan state.</p>
<p>The default implementation of this method returns YES.</p>
</blockquote>
<p>所以，上文提到的部分 UIControl 重写了该方法，虽然 UIGestureRecognizer 会首先受到触摸事件，但是在状态转换之前，调用了 Hit-Testing 返回的 View 也就是 UIControl 的 <code>gestureRecognizerShouldBegin:</code> 方法，UIControl 会使父 View 上的 UIGestureRecognizer 失效，而自己的 UIGestureRecognizer 却不会失效，这就是系统实现这个机制的方法。</p>
<p>还有一个问题，为什么触摸没有沿着响应链进行传递呢？惯例，先看文档：</p>
<blockquote>
<p>Controls communicate directly with their associated target object using action messages. When the user interacts with a control, the control sends an action message to its target object. Action messages are not events, but they may still take advantage of the responder chain. When the target object of a control is nil, UIKit starts from the target object and traverses the responder chain until it finds an object that implements the appropriate action method. For example, the UIKit editing menu uses this behavior to search for responder objects that implement methods with names like cut:, copy:, or paste:.</p>
</blockquote>
<p>然后我们看下 FButton 的响应方法的调用栈（去掉 FButton 上的 UIGestureRecognizer）：</p>
<p><img src="media/16587402936512/15654065324630.jpg" alt="" /></p>
<p>这里文档没有说全，实际上，FButton 重写了 <code>touchesBegan:withEvent:</code> 方法，在收到触摸事件后将其截断不再沿响应链进行传递；在响应触摸事件时，FButton 使用 Target-Action 机制通过 <code>sendAction:to:forEvent:</code> 方法通知 UIApplication，UIApplication 在通过 <code>sendAction:to:from:forEvent:</code> 方法向 target 发送 action，而当 target 为 nil 时就会沿着响应链进行寻找，知道找到了实现了相应方法的对象。</p>
<h3><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h3>
<p><strong>1. UIGestureRecognizer 仍然会先于 UIControl 接收到触摸事件。</strong></p>
<p><strong>2. UIButton 等部分 UIControl 会拦截其父 View 上的 UIGestureRecognizer，但不会拦截自己和子 View 上的 UIGestureRecognizer。</strong></p>
<p><strong>3. UIButton 会截断响应链的事件传递，也可以利用响应链来寻找 Action Method。</strong></p>
<h2><a id="uitableview%E4%B8%8E-uiscrollview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UITableView 与 UIScrollView</h2>
<p>当场景中存在 UITableView 和 UIScrollView 时，又会有不一样的情况，感兴趣的读者可以试着自己研究一下。</p>
<h2><a id="%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题解决</h2>
<p>现在，我们回过头看看最初的问题，解决起来应该就比较简单了。</p>
<p>首先在我们对外的 View 上添加一个 UITapGestureRecognizer，通过回调使其能与内部的 UIGestureRecognizer 同时处理触摸事件，并且与内部双击手势不会冲突：</p>
<pre><code class="language-plain_text">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    if (gestureRecognizer == self.tapGestureRecognizer)
    {
        return YES;
    }

    return NO;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    if (gestureRecognizer == self.tapGestureRecognizer &amp;&amp; [otherGestureRecognizer isKindOfClass:[UITapGestureRecognizer class]] &amp;&amp; ((UITapGestureRecognizer *)otherGestureRecognizer).numberOfTapsRequired == 2)
    {
        return YES;
    }

    return NO;
}
复制代码
</code></pre>
<p>由于单击手势要在双击手势判断失败后才能触发，所以会有一定的延迟，这里最好的办法是在内部自定义一个 UIGestureRecognizer 来实现双击手势以缩短等待时间：</p>
<pre><code class="language-plain_text">#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;

#define UISHORT_TAP_MAX_DELAY 0.2
@interface UIShortTapGestureRecognizer : UITapGestureRecognizer

@end

@implementation UIShortTapGestureRecognizer

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    [super touchesBegan:touches withEvent:event];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(UISHORT_TAP_MAX_DELAY * NSEC_PER_SEC)), dispatch_get_main_queue(), ^
    {
        // Enough time has passed and the gesture was not recognized -&gt; It has failed.
        if  (self.state != UIGestureRecognizerStateRecognized)
        {
            self.state = UIGestureRecognizerStateFailed;
        }
    });
}
@end
复制代码
</code></pre>
<p>我们可以通过修改 <code>UISHORT_TAP_MAX_DELAY</code> 参数来控制等待的时间。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p><strong>1. 触摸事件发生后，IOKit 会通过 mach port 传递给 SpringBoad 进程，并最终传递给了 UIApplication。</strong></p>
<p><strong>2. UIApplication 通过 Hit-Testing 寻找到了最佳响应者，遍历得到所有的 UIGestureRecognizer，然后根据最佳响应者、UIGestureRecognizer、Window 创建 UITouch 并将其保存在 UIEvent 中。</strong></p>
<p><strong>3. UIApplication 将 UIEvent 发送给 UIWindow，UIWindow 首先发送事件给 UIGestureRecognizer，然后发送给最佳响应者，事件沿响应链传递。</strong></p>
<p><strong>4. UIGestureRecognizer 根据 Delegate 以及最佳响应者来判断是否能够成功进行状态转换并取消响应链的触摸事件。</strong></p>
<p><strong>5. 系统实现的部分 UIControl 会截断响应链，并使父 View 上的 UIGestureRecognizer 失效。</strong></p>
<h2><a id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考资料</h2>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FBladeTail%2FEvent-Handling-Guide-for-iOS%2Fblob%2Fmaster%2FEvent%2520Handling%2520Guide%2520for%2520iOS.pdf">Event Handling Guide for iOS</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd8512dff2b3e">iOS 事件响应链中 Hit-Test View 的应用</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fc294d1bd963d">iOS 触摸事件全家桶</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F53e03e558cbd">iOS 点击事件和手势冲突</a></p>
<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fzhoon.github.io%2Fios%2F2015%2F04%2F12%2Fios-event.html">深入浅出iOS事件机制</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936654.html">使用Qt创建桌面应用程序</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>如果Xcode8下无法正常使用Qt,解决办法参见:<a href="http://www.citynight.cn/Blog/14761943627170.html">http://www.citynight.cn/Blog/14761943627170.html</a></p>
</blockquote>
<p>最终实现的效果:<br />
<img src="media/16587402936654/14771178501064.jpg" alt="" /></p>
<p><img src="media/16587402936654/14771179340151.jpg" alt="" /></p>
<p>选择桌面应用程序<br />
<img src="media/16587402936654/14771179611437.jpg" alt="" /></p>
<p><img src="media/16587402936654/14771180181773.jpg" alt="" /></p>
<p>OK,现在项目创建好了....接下来就是写代码了...</p>
<p><img src="media/16587402936654/14771173227361.jpg" alt="" /></p>
<p>然后在<code>mainwindow.cpp</code>文件中编写代码:<br />
引入需要的头文件</p>
<pre><code class="language-plain_text">#include &lt;QPainter&gt;
#include &lt;QPen&gt;
#include &lt;math.h&gt;
</code></pre>
<p>在<code>MainWindow</code>中设置窗口位置</p>
<pre><code class="language-plain_text">    // 设置在桌面上显示的位置&amp;大小
    this-&gt;setGeometry(600,300,600,300);
</code></pre>
<pre><code class="language-plain_text">void MainWindow::paintEvent(QPaintEvent *e){
        // 定义画笔
        QPainter painter(this);

        // 定义画坐标笔的,宽度,颜色
        QPen pen;
        pen.setWidth(2);
        pen.setColor(Qt::black);

        // 设置属性生效
        painter.setPen(pen);

        // 画坐标
        painter.drawLine(0,150,600,150);
        painter.drawLine(100,0,100,300);

        //将绘画的坐标原点,转移到(100,150)的位置
        painter.translate(100,150);



        //重新设置画正弦颜色和样式

        pen.setColor(Qt::red);

        pen.setStyle(Qt::SolidLine);

        //使设置生效
        painter.setPen(pen);

        //采集 360 个点用于绘图
        QVector&lt;QPointF&gt;pVector;

        for(int i=0; i&lt;360; i++)
        {
            pVector.push_back(QPointF(i,-sin(3.14/180*i)*70));//y 轴坐标,相反

        }

        // 画多点线条
        painter.drawPolyline(pVector);
}
</code></pre>
<p>开心的run下吧..</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936758.html"></a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>###1. 建议平台功能做成微服务，各个业务可插拔</p>
<h3><a id="2%E5%BB%BA%E8%AE%AE%E5%AF%B9%E4%BA%8E%E4%BD%BF%E7%94%A8%E5%85%AC%E5%8F%B8-saas%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%AC%E5%8F%B8%E5%BB%BA%E8%AE%AE%E5%9C%A8%E7%BA%A2%E7%81%AB%E5%8F%B0app%E4%B8%8A%E5%BC%80%E9%80%9A%E6%98%BE%E7%A4%BA%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD%E3%80%82%E6%88%91%E6%83%B3%E5%8E%BB%E7%9A%84%E9%A4%90%E5%8E%85%E8%87%B3%E5%B0%91%E8%AE%A9%E9%A1%BE%E5%AE%A2%E7%9F%A5%E9%81%93%E5%8D%96%E5%95%A5%E8%8F%9C%EF%BC%8C%E5%85%B7%E4%BD%93%E5%8F%82%E8%80%83%E6%96%B0%E7%BE%8E%E5%A4%A7app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.建议对于使用公司SaaS服务的公司建议在红火台app上开通显示菜单功能。我想去的餐厅至少让顾客知道卖啥菜，具体参考新美大App</h3>
<h3><a id="3%E5%BB%BA%E8%AE%AE%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%97%A8%E8%8F%9C%E5%93%81%E3%80%81%E7%BD%91%E7%BA%A2%E8%8F%9C%EF%BC%8C%E6%AF%94%E5%A6%82%E7%83%AD%E9%97%A8%E7%9A%84%E6%B5%B7%E5%BA%95%E6%8D%9E%E5%BA%95%E6%96%99%E5%90%83%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8-app%E4%B8%AD%E6%98%BE%E7%A4%BA%E4%BE%9B%E9%A1%BE%E5%AE%A2%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 建议添加热门菜品、网红菜，比如热门的海底捞底料吃法可以在app中显示供顾客参考</h3>
<h3><a id="4%E5%BB%BA%E8%AE%AE%E6%81%A2%E5%A4%8D%E5%81%A5%E8%BA%AB%E6%AF%94%E8%B5%9B%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%AD%A3%E5%BA%A6%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%9D%A5%E4%B8%80%E5%9C%BA%EF%BC%8C%E6%8A%8A%E5%81%A5%E8%BA%AB%E5%99%A8%E6%9D%90%E7%94%A8%E8%B5%B7%E6%9D%A5%EF%BC%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 建议恢复健身比赛，每个季度都可以来一场，把健身器材用起来，</h3>
<h3><a id="5%E5%BB%BA%E8%AE%AE%E8%B7%9F%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B9%A6%E7%B1%8D%E8%B4%AD%E4%B9%B0%E5%8F%AF%E6%8A%A5%E9%94%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. 建议跟工作相关的书籍购买可报销</h3>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936845.html">后台经验总结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>根据这一段时间的开发问题，血与泪的教训，总结如下经验，请各位严格按照执行！</p>
<ol>
<li>不允许在循环里面写查询语句，正确的方式是一次查询，然后遍历结果集</li>
<li>在写注入之前先查看相关类有没有注入该类的实例，防止循环注入</li>
<li>所有的接口调用都需要打日志，日志标准是 tablebillid + 关键字 + 耗时</li>
<li>所有的注释按照 人员  ，日期，应什么需求，功能介绍四个方面描述，有参数需要写参数注释</li>
<li>代码提交方式需要申请合并，所有DDL脚本交给我处理，不允许在任何环境自行执行DDL脚本</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402936932.html">Flutter 相关网站</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="https://github.com/flutter/flutter/issues">github地址</a></p>
<p><a href="https://flutterchina.club/">Flutter中文网</a></p>
<p>三方库网站  <a href="https://pub.dev">https://pub.dev</a></p>
<h1><a id="%E4%BD%BF%E7%94%A8flutter%E6%8A%80%E6%9C%AF%E7%9A%84-app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用Flutter 技术的App</h1>
<ul>
<li>MOO 腾讯音乐App <a href="https://mp.weixin.qq.com/s/ChbXxcd_k6_CSvI6VxwTyg">https://mp.weixin.qq.com/s/ChbXxcd_k6_CSvI6VxwTyg</a></li>
<li>闲鱼App  闲鱼Flutter技术文章专栏：<a href="https://www.zhihu.com/column/xytech">https://www.zhihu.com/column/xytech</a>  被吐槽 <a href="https://maimai.cn/web/feed_detail?fid=1573956025&amp;efid=H20EJR0aOjBt9e_HmpcW5g&amp;use_rn=1">https://maimai.cn/web/feed_detail?fid=1573956025&amp;efid=H20EJR0aOjBt9e_HmpcW5g&amp;use_rn=1</a></li>
<li>飞猪App <a href="https://juejin.cn/post/6937254156776243231">https://juejin.cn/post/6937254156776243231</a></li>
<li>美团（美团外卖App上有应用，美团主要用原生+RN） <a href="https://tech.meituan.com/tags/flutter.html">https://tech.meituan.com/tags/flutter.html</a></li>
</ul>
<h1><a id="flutter%E8%B6%8B%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Flutter趋势</h1>
<p>flutter热词搜索情况 <a href="https://trends.google.com/trends/explore?date=today%205-y&amp;geo=US&amp;q=flutter">https://trends.google.com/trends/explore?date=today%205-y&amp;geo=US&amp;q=flutter</a></p>
<p><img src="media/16587402936932/16152544977518.jpg" alt="" style="width:1675px;" /><br />
<img src="media/16587402936932/16152545180865.jpg" alt="" style="width:1679px;" /></p>
<p>百度指数</p>
<p><img src="media/16587402936932/16152545369692.jpg" alt="" style="width:1317px;" /></p>
<h1><a id="%E8%AE%BE%E5%A4%87%E3%80%81%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设备、系统使用情况</h1>
<p>百度统计情况：<a href="https://tongji.baidu.com/research/app">https://tongji.baidu.com/research/app</a></p>
<p>苹果手机</p>
<p><img src="media/16587402936932/16152545486874.jpg" alt="" style="width:508px;" /></p>
<p><img src="media/16587402936932/16152545614616.jpg" alt="" style="width:473px;" /></p>
<p>安卓手机：</p>
<p><img src="media/16587402936932/16152545701527.jpg" alt="" style="width:490px;" /><br />
<img src="media/16587402936932/16152545805059.jpg" alt="" style="width:473px;" /></p>
<h1><a id="%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>系统使用情况</h1>
<p><img src="media/16587402936932/16152545904534.jpg" alt="" style="width:527px;" /><br />
<img src="media/16587402936932/16152546057902.jpg" alt="" style="width:479px;" /><br />
<img src="media/16587402936932/image-20210308223439673.png" alt="image-20210308223439673" /><br />
<img src="media/16587402936932/16152548733751.jpg" alt="" style="width:478px;" /></p>
<h1><a id="%E7%BB%93%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结论</h1>
<p>阿里巴巴淘系技术的回答 - 知乎 <a href="https://www.zhihu.com/question/374113031/answer/1252582543">https://www.zhihu.com/question/374113031/answer/1252582543</a></p>
<p>TechLead Show 的观点 <a href="https://www.youtube.com/watch?v=AvXSFUi022s">https://www.youtube.com/watch?v=AvXSFUi022s</a></p>
<p>目前存在问题：</p>
<ol>
<li><a href="https://github.com/flutter/flutter/issues">https://github.com/flutter/flutter/issues</a>  ，好多问题没有解决，同时也说明反馈的人多热度不错。</li>
<li>同时也能发现大厂的主要应用暂时没有使用Flutter，在新业务场景中开始尝试使用Flutter。</li>
<li>需要学习Dart语言，适应新的UI开发（大约需要一周多适应）</li>
</ol>
<p>目前公司产品中，我认为供应链项目，食堂App（客户端和商家端）完全可以使用Flutter进行开发，iPad点菜系统我认为不太合适。Flutter在动画和手势方面比原生还是有差距，而且在老旧设备的兼容性上面Flutter还不太行。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937057.html">529. Minesweeper（529. 扫雷游戏）</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>题目地址:<a href="https://leetcode-cn.com/problems/minesweeper/">529. 扫雷游戏</a></p>
<p>Let's play the minesweeper game (<a href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)">Wikipedia</a>, <a href="http://minesweeperonline.com/">online game</a>)!</p>
<p>You are given a 2D char matrix representing the game board. <strong>'M'</strong> represents an <strong>unrevealed</strong> mine, <strong>'E'</strong> represents an <strong>unrevealed</strong> empty square, <strong>'B'</strong> represents a ** revealed** blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this ** revealed** square, and finally <strong>'X'</strong> represents a ** revealed** mine.</p>
<p>Now given the next click position (row and column indices) among all the <strong>unrevealed</strong> squares (<strong>'M'</strong> or <strong>'E'</strong>), return the board after revealing this position according to the following rules:</p>
<ol>
<li>If a mine (<strong>'M'</strong>) is ** revealed**, then the game is over - change it to <strong>'X'</strong>.</li>
<li>If an empty square (<strong>'E'</strong>) with <strong>no adjacent mines</strong> is revealed, then change it to revealed blank (<strong>'B'</strong>) and all of its adjacent <strong>unrevealed</strong> squares should be revealed recursively.</li>
<li>If an empty square (<strong>'E'</strong>) with <strong>at least one adjacent mine</strong> is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.</li>
<li>Return the board when no more squares will be ** revealed**.</li>
</ol>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong></p>
<pre><code class="language-plain_text">[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]

Click : [3,0]
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-plain_text">[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

</code></pre>
<p><strong>Explanation:</strong><br />
<img src="media/16587402937057/15978907322780.png" alt="" style="width:532px;" /></p>
<ul>
<li><strong>Example 2:</strong></li>
</ul>
<p><strong>Input:</strong></p>
<pre><code class="language-plain_text">[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Click : [1,2]
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-plain_text">[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'X', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

</code></pre>
<p><strong>Explanation:</strong><br />
<img src="media/16587402937057/15978909318647.png" alt="" style="width:511px;" /></p>
<p><strong>Note:</strong></p>
<ol>
<li>The range of the input matrix's height and width is [1,50].</li>
<li>The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square.</li>
<li>The input board won't be a stage when game is over (some mines have been revealed).</li>
<li>For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li>
</ol>
<p>思路：<br />
深度优先</p>
<pre><code class="language-Java">public class Solution {
    // 坐标相邻的8个方向 上，下，左，右，左上，左下，右上，右下
    private int[][] dirs = {{0,1},{0,-1},{-1,0},{1,0},{-1,1},{-1,-1},{1,1},{1,-1}};
    public char[][] updateBoard(char[][] board, int[] click) {
        // 获取当前坐标
        int row = click[0], col = click[1];
        // 边界条件
        int m = board.length, n = board[0].length;

        // 如果找到M（未挖出的雷）或者X（已挖出的雷）游戏结束
        if (board[row][col] == 'M' || board[row][col] == 'X') {
            board[row][col] = 'X';
            return board;
        }

        // 找周边有几个雷
        int num = 0;
        for (int[] dir : dirs) {
            int newRow = dir[0] + row;
            int newCol = dir[1] + col;
            // 如果周围是未被揭开的雷，周围雷的数量递增
            if (newRow &gt;= 0 &amp;&amp; newCol &gt;= 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &lt; n &amp;&amp; board[newRow][newCol] == 'M') {
                num++;
            }
        }

        // 如果周围有雷
        if (num &gt; 0) {
            board[row][col] = (char) (num + '0');
            return board;
        }

        // 如果一个没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'）
        board[row][col] = 'B';
        for (int[] dir : dirs) {
            int newRow = dir[0] + row;
            int newCol = dir[1] + col;
            // 所有和其相邻的未挖出方块都应该被递归地揭露。
            if (newRow &gt;= 0 &amp;&amp; newCol &gt;= 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &lt; n &amp;&amp; board[newRow][newCol] == 'E') {
                updateBoard(board,new int[]{newRow,newCol});
            }
        }

        return board;
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937146.html">第一个Java应用程序</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>1.1 创建一个java源文件：HelloWorld.java</li>
</ul>
<pre><code class="language-plain_text">class HelloChina {
    public static void main(String[] args){
        System.out.println(&quot;Hello world&quot;);
    }
}
</code></pre>
<ul>
<li>
<p>1.2 编译<br />
javac HelloWorld.java</p>
</li>
<li>
<p>1.3 运行<br />
java HelloChina</p>
</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937231.html">xib报错</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>错误信息: Unknown class XXXX in Interface Builder file. (lldb)</p>
</blockquote>
<p>原因,Xib是在其他项目中创建的,拖进来的时候没有注意,只要修改<br />
<img src="media/16587402937231/14802974822042.jpg" alt="" /></p>
<p>修改module为项目的就好了</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937422.html">网上订餐流程</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##订餐流程</p>
<ol>
<li>现在微信端登录下单，使用账号就是PAD登录的会员手机号，然后微信下单的时候注意门店选天通苑店，这是148默认归属门店,149是紫竹桥店</li>
<li>登录话吧后台搜索你的订单，点击订单号进入订单详情，进入订单详情后点击左上角下发门店，下发成功</li>
<li>PAD端输入订单号后5位就可以拉取成功</li>
</ol>
<p>##订餐地址<br />
<a href="http://wect.haidilao.com/Cater/terminus/reservation/StoreList.html?source=weixin&amp;weixin_user_id=oh3YsvzqSXsTA-cUM1zy-mTuF1RA&amp;realname=FiPweixinlauvey&amp;mobile=&amp;cuspoint=&amp;gender=m">http://wect.haidilao.com/Cater/terminus/reservation/StoreList.html?source=weixin&amp;weixin_user_id=oh3YsvzqSXsTA-cUM1zy-mTuF1RA&amp;realname=FiPweixinlauvey&amp;mobile=&amp;cuspoint=&amp;gender=m</a></p>
<h2><a id="%E8%AF%9D%E5%90%A7%E5%90%8E%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>话吧后台</h2>
<p><a href="http://172.16.149.40:8010/Cater/web/telephoneLogin/telLoginSuc.action;jsessionid=3DB646231F6FDA9F8FE1A0BE448E0B7F">http://172.16.149.40:8010/Cater/web/telephoneLogin/telLoginSuc.action;jsessionid=3DB646231F6FDA9F8FE1A0BE448E0B7F</a></p>
<h2><a id="%E8%AF%9D%E5%90%A7%E5%90%8E%E5%8F%B0%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>话吧后台账号密码</h2>
<p><code>itfwt</code>  <code>001001</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937510.html">runtime小结</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3><a id="%E4%B8%80%E3%80%81runtime%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、runtime简介</h3>
<ul>
<li>runTime简称运行时。OC就是<code>运行时机制</code>，也就是在运行时候的一些机制，其中最主要的是消息机制。</li>
<li>对于C语言，<code>函数的调用在编译的时候会决定调用哪个函数</code>。</li>
<li>对于OC的函数，属于<code>动态调用过程</code>，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>
<li>事实证明：
<ul>
<li>在编译阶段，OC可以<code>调用任何函数</code>，即使这个函数并未实现，只要声明过就不会报错。</li>
<li>在编译阶段，C语言调用<code>未实现的函数</code>就会报错。</li>
</ul>
</li>
</ul>
<h3><a id="%E4%BA%8C%E3%80%81runtime%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、runtime作用</h3>
<h4><a id="1%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.发送消息</h4>
<ul>
<li>方法调用的本质，就是让对象发送消息。</li>
<li>objc_msgSend,只有对象才能发送消息，因此以objc开头.</li>
<li>使用<code>消息机制</code>前提，必须导入#import</li>
<li>消息机制简单使用</li>
<li>clang -rewrite-objc main.m 查看最终生成代码</li>
</ul>
<pre><code class="language-plain_text">    // 创建person对象
    Person *p = [[Person alloc] init];

    // 调用对象方法
    [p eat];

    // 本质：让对象发送消息
    objc_msgSend(p, @selector(eat));

    // 调用类方法的方式：两种
    // 第一种通过类名调用
    [Person eat];
    // 第二种通过类对象调用
    [[Person class] eat];

    // 用类名调用类方法，底层会自动把类名转换成类对象调用
    // 本质：让类对象发送消息
    objc_msgSend([Person class], @selector(eat));

</code></pre>
<ul>
<li>消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现<br />
<img src="media/16587402937510/14717888515211.jpg" alt="" /></li>
</ul>
<h4><a id="2%E4%BA%A4%E6%8D%A2%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.交换方法</h4>
<ul>
<li>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。</li>
<li>方式一:继承系统的类，重写方法.</li>
<li>方式二:使用runtime,交换方法.</li>
</ul>
<pre><code class="language-plain_text">@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。
    // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;
    // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。
    UIImage *image = [UIImage imageNamed:@&quot;123&quot;];

}

@end

@implementation UIImage (Image)
// 加载分类到内存的时候调用
+ (void)load
{
    // 交换方法

    // 获取imageWithName方法地址
    Method imageWithName = class_getClassMethod(self, @selector(imageWithName:));

    // 获取imageWithName方法地址
    Method imageName = class_getClassMethod(self, @selector(imageNamed:));

    // 交换方法地址，相当于交换实现方式
    method_exchangeImplementations(imageWithName, imageName);

}

// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.

// 既能加载图片又能打印
+ (instancetype)imageWithName:(NSString *)name
{

    // 这里调用imageWithName，相当于调用imageName
    UIImage *image = [self imageWithName:name];

    if (image == nil) {
        NSLog(@&quot;加载空的图片&quot;);
    }

    return image;
}

@end

</code></pre>
<ul>
<li>交换原理：
<ul>
<li>
<p>交换之前：<br />
<img src="media/16587402937510/14717892191490.jpg" alt="" /></p>
</li>
<li>
<p>交换之后：<br />
<img src="media/16587402937510/14717892801791.jpg" alt="" /></p>
</li>
</ul>
</li>
</ul>
<h4><a id="3%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.动态添加方法</h4>
<ul>
<li>开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</li>
<li>经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。</li>
<li>简单使用</li>
</ul>
<pre><code class="language-plain_text">@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    Person *p = [[Person alloc] init];

    // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。
    // 动态添加方法就不会报错
    [p performSelector:@selector(eat)];

}

@end

@implementation Person
// void(*)()
// 默认方法都有两个隐式参数，
void eat(id self,SEL sel)
{
    NSLog(@&quot;%@ %@&quot;,self,NSStringFromSelector(sel));
}

// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.
// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法
+ (BOOL)resolveInstanceMethod:(SEL)sel
{

    if (sel == @selector(eat)) {
        // 动态添加eat方法

        // 第一个参数：给哪个类添加方法
        // 第二个参数：添加方法的方法编号
        // 第三个参数：添加方法的函数实现（函数地址）
        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd
        class_addMethod(self, @selector(eat), eat, &quot;v@:&quot;);

    }

    return [super resolveInstanceMethod:sel];
}
@end

</code></pre>
<h4><a id="4%E7%BB%99%E5%88%86%E7%B1%BB%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.给分类添加属性</h4>
<ul>
<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>
</ul>
<pre><code class="language-plain_text">
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    // 给系统NSObject类动态添加属性name

    NSObject *objc = [[NSObject alloc] init];
    objc.name = @&quot;微指&quot;;
    NSLog(@&quot;%@&quot;,objc.name);

}

@end

// 定义关联的key
static const char *key = &quot;name&quot;;

@implementation NSObject (Property)

- (NSString *)name
{
    // 根据关联的key，获取关联的值。
    return objc_getAssociatedObject(self, key);
}

- (void)setName:(NSString *)name
{
    // 第一个参数：给哪个对象添加关联
    // 第二个参数：关联的key，通过这个key获取
    // 第三个参数：关联的value
    // 第四个参数:关联的策略
    objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end

</code></pre>
<h4><a id="5%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.字典转模型</h4>
<ul>
<li>设计模型：字典转模型的第一步
<ul>
<li>模型属性，通常需要跟字典中的key一一对应</li>
<li>问题：一个一个的生成模型属性，很慢？</li>
<li>需求：能不能自动根据一个字典，生成对应的属性。</li>
<li>解决：提供一个分类，专门根据字典生成对应的属性字符串。</li>
</ul>
</li>
</ul>
<pre><code class="language-plain_text">    @implementation NSObject (Log)

// 自动打印属性字符串
+ (void)resolveDict:(NSDictionary *)dict{

    // 拼接属性字符串代码
    NSMutableString *strM = [NSMutableString string];

    // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码
    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {

        // 类型经常变，抽出来
         NSString *type;

        if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) {
            type = @&quot;NSString&quot;;
        }else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)]){
            type = @&quot;NSArray&quot;;
        }else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)]){
            type = @&quot;int&quot;;
        }else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)]){
            type = @&quot;NSDictionary&quot;;
        }

        // 属性字符串
        NSString *str;
        if ([type containsString:@&quot;NS&quot;]) {
            str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key];
        }else{
            str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key];
        }

        // 每生成属性字符串，就自动换行。
        [strM appendFormat:@&quot;\n%@\n&quot;,str];

    }];

    // 把拼接好的字符串打印出来，就好了。
    NSLog(@&quot;%@&quot;,strM);

}

@end

</code></pre>
<ul>
<li>字典转模型的方式一：KVC</li>
</ul>
<pre><code class="language-plain_text">@implementation Status

+ (instancetype)statusWithDict:(NSDictionary *)dict
{
    Status *status = [[self alloc] init];

    [status setValuesForKeysWithDictionary:dict];

    return status;

}

@end

</code></pre>
<ul>
<li>KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。
<ul>
<li>如果不一致，就会调用<code>[ setValue:forUndefinedKey:]</code> 报<code>key</code>找不到的错。</li>
<li>分析:模型中的属性和字典的key不一一对应，系统就会调用<code>setValue:forUndefinedKey:</code>报错。</li>
<li>解决:重写对象的<code>setValue:forUndefinedKey:</code>,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。</li>
</ul>
</li>
</ul>
<pre><code class="language-plain_text">- (void)setValue:(id)value forUndefinedKey:(NSString *)key
{

}

</code></pre>
<ul>
<li>字典转模型的方式二：Runtime
<ul>
<li>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</li>
<li>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。</li>
</ul>
</li>
</ul>
<pre><code class="language-plain_text">
@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    // 解析Plist文件
    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];

    NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];

    // 获取字典数组
    NSArray *dictArr = statusDict[@&quot;statuses&quot;];

    // 自动生成模型的属性字符串
//    [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];

    _statuses = [NSMutableArray array];

    // 遍历字典数组
    for (NSDictionary *dict in dictArr) {

        Status *status = [Status modelWithDict:dict];

        [_statuses addObject:status];

    }

    // 测试数据
    NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);

}

@end

@implementation NSObject (Model)

+ (instancetype)modelWithDict:(NSDictionary *)dict
{
    // 思路：遍历模型中所有属性-》使用运行时

    // 0.创建对应的对象
    id objc = [[self alloc] init];

    // 1.利用runtime给对象中的成员属性赋值

    // class_copyIvarList:获取类中的所有成员属性
    // Ivar：成员属性的意思
    // 第一个参数：表示获取哪个类中的成员属性
    // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值
    // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。
    /* 类似下面这种写法

     Ivar ivar;
     Ivar ivar1;
     Ivar ivar2;
     // 定义一个ivar的数组a
     Ivar a[] = {ivar,ivar1,ivar2};

     // 用一个Ivar *指针指向数组第一个元素
     Ivar *ivarList = a;

     // 根据指针访问数组第一个元素
     ivarList[0];

     */
    unsigned int count;

    // 获取类中的所有成员属性
    Ivar *ivarList = class_copyIvarList(self, &amp;count);

    for (int i = 0; i 字典中的key
        // 从第一个角标开始截取
        NSString *key = [name substringFromIndex:1];

        // 根据成员属性名去字典中查找对应的value
        id value = dict[key];

        // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型
        // 判断下value是否是字典
        if ([value isKindOfClass:[NSDictionary class]]) {
            // 字典转模型
            // 获取模型的类对象，调用modelWithDict
            // 模型的类名已知，就是成员属性的类型

            // 获取成员属性类型
           NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];
          // 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot;  在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符
            // 裁剪类型字符串
            NSRange range = [type rangeOfString:@&quot;\&quot;&quot;];

           type = [type substringFromIndex:range.location + range.length];

            range = [type rangeOfString:@&quot;\&quot;&quot;];

            // 裁剪到哪个角标，不包括当前角标
          type = [type substringToIndex:range.location];

            // 根据字符串类名生成类对象
            Class modelClass = NSClassFromString(type);

            if (modelClass) { // 有对应的模型才需要转

                // 把字典转模型
                value  =  [modelClass modelWithDict:value];
            }

        }

        // 三级转换：NSArray中也是字典，把数组中的字典转换成模型.
        // 判断值是否是数组
        if ([value isKindOfClass:[NSArray class]]) {
            // 判断对应类有没有实现字典数组转模型数组的协议
            if ([self respondsToSelector:@selector(arrayContainModelClass)]) {

                // 转换成id类型，就能调用任何对象的方法
                id idSelf = self;

                // 获取数组中字典对应的模型
                NSString *type =  [idSelf arrayContainModelClass][key];

                // 生成模型
               Class classModel = NSClassFromString(type);
                NSMutableArray *arrM = [NSMutableArray array];
                // 遍历字典数组，生成模型数组
                for (NSDictionary *dict in value) {
                    // 字典转模型
                  id model =  [classModel modelWithDict:dict];
                    [arrM addObject:model];
                }

                // 把模型数组赋值给value
                value = arrM;

            }
        }

        if (value) { // 有值，才需要给模型的属性赋值
            // 利用KVC给模型中的属性赋值
            [objc setValue:value forKey:key];
        }

    }
    free(ivarList);
    return objc;
}

@end
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937607.html">collectionView遇到的问题</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>如果在自定义layout的时候调用</p>
<pre><code class="language-plain_text">- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity
</code></pre>
<p>实现吸附效果,则有可能导致</p>
<pre><code class="language-plain_text">-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath
</code></pre>
<p>不执行...</p>
<p>如果把吸附效果写在</p>
<pre><code class="language-plain_text">-(void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset
</code></pre>
<p>则没有问题...暂时没有找到比较好的解决办法...</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937694.html">使用iOS模拟器测试“磁盘空间不足”情况的实用方法是什么？</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>创建一个小磁盘映像:</p>
<pre><code class="language-plain_text">hdiutil create -size 2m -fs HFS+ /tmp/2meg.dmg
</code></pre>
<p>将其挂载到模拟器应用程序中的相关目录，例如:</p>
<pre><code class="language-plain_text">hdiutil attach /tmp/2meg.dmg -mountpoint /Users/.../Library/Developer/CoreSimulator/Devices/.../data/Applications/.../Library/Caches
</code></pre>
<p>运行应用程序并执行测试。也可以在应用运行时完成此操作。在这种情况下，您可能不想直接将其安装为<code>Caches</code>或<code>Documents</code>目录，因为这会将当前文件隐藏在那些文件夹中。改为挂载到子目录。如果在不更改应用程序路径的情况下很难做到这一点，请在将映像挂载到非空目录之上之前，将映像挂载到其他位置并复制数据。</p>
<p>卸载:</p>
<pre><code class="language-plain_text">hdiutil detach /Users/.../Library/Developer/CoreSimulator/Devi...
</code></pre>
<p>但是，请注意，如果移动安装点，则分离操作将失败。这总是发生，因为每次运行应用程序时，Apple都会在iOS 8上重命名模拟器目录。在这种情况下，请使用<code>mount</code>命令查找已安装的设备，例如<code>/dev/disk3s1 /Users/.../Library/...</code>，然后使用设备名称而不是安装点来卸载磁盘映像:</p>
<pre><code class="language-plain_text">hdiutil detach disk3s1
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937812.html">计算老虎机中奖等级-NSCountedSet</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>NSCountedSet这个一直没有用过,看到其他人使用在此记录下.</p>
</blockquote>
<p>计算老虎机中奖等级的问题：老虎机有四列，每列四个图案，如果四个相同就是等级1，三个相同就是等级2，以此类推。说是用<code>if else</code>太麻烦，有没有什么比较快捷的方法，首先想到的是用KVC中剔除重复数据的办法。比如：</p>
<pre><code class="language-plain_text">NSArray *array = @[@2, @2, @2, @1];
NSLog(@&quot;%@&quot;, [array valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;]);
</code></pre>
<p>然后得到数组的个数为2，看起来很合理，如果数组是<code>NSArray *array = @[@2, @1, @2, @1];</code>这时候计算出来的数组个数是也是2，但是正确结果应该是等级3，后来突然想起一个类:NSCountedSet</p>
<pre><code class="language-plain_text">    NSArray *array = @[@1, @2, @2, @1];
    NSCountedSet *set = [[NSCountedSet alloc]initWithArray:array];

    [set enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
        NSLog(@&quot;%@ =&gt; %d&quot;, obj, [set countForObject:obj]);
    }];

</code></pre>
<pre><code class="language-plain_text">1 =&gt; 2
2 =&gt; 2
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937890.html">Flutter 状态</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFstateless-widget" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是Stateless Widget</h2>
<p>Flutter中的statelesswidget是一个不需要状态更改的widget,它没有要管理的内部状态．</p>
<p>当描述户界面部分不衣赖于对象本身中的配置信息以及widget的build content时，无状态widget是非常有用的。</p>
<p>AboutDialog，CircleAvator和Text都是stateless widget的子类。</p>
<p>stateless widget的build方法通常只会在以下三种情况调用:</p>
<ol>
<li>将widget插入树中时</li>
<li>当widget的父节点更改配置时</li>
<li>当它依赖的inherited widget发生变化时。</li>
</ol>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFstateful-widget" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是stateful widget</h2>
<p>stateful widget是状态可变的widget。使用setstate方法管理stateful widget状态的改变。使用setstate告诉flutter框架某个状态发生了变化，flutter将会重新运行build方法，以便应用程序更新状态。</p>
<h2><a id="%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E9%82%A3%E4%B8%AA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>怎么判断应该使用那个</h2>
<ol>
<li>如果用户或者数据改变导致widget改变，那么就用有状态</li>
<li>如果是最终的或者是不可变的，那么就用无状态</li>
</ol>
<h2><a id="%E5%87%A0%E7%A7%8D%E5%8F%AF%E8%83%BD%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>几种可能性</h2>
<ul>
<li>每个widget管理自己的状态</li>
<li>父widget管理widget 状态</li>
<li>混合搭配处理</li>
</ul>
<p>解决方案：</p>
<ul>
<li>如果状态是用户数据，如复选框是否选中，switch等，最好由父widget管理</li>
<li>如果widget的状态取决于动作，比如动画，那么由widget自己管理。</li>
<li>如果还不确定谁该负责，选父widget管理子widget状态</li>
</ul>
<h2><a id="%E5%A4%9A%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多线程</h2>
<p><img src="assets/IMG_1.jpg" alt="图片" /></p>
<p><img src="assets/IMG_2.jpg" alt="图片" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402937976.html">拖拽添加</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-plain_text">//MARK: - touch
extension OrderDishImageViewCell {
    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        super.touchesBegan(touches, with: event)
   }
    
    override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        super.touchesBegan(touches, with: event)
    }
    
    override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        super.touchesEnded(touches, with: event)
    }
    
    override func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        super.touchesCancelled(touches, with: event)        
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938068.html">collectionView自定义layout</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>今天,YouTube推荐了一个自定义layout的视频( Custom Collection View Layouts in iOS),看了一下挺简单明了的,而且基本的操作都包含了.<br />
<strong>视频地址:</strong> <a href="https://www.youtube.com/watch?v=DIxyCh55SqQ">Pinterest Basic Layout - Custom Collection View Layouts in iOS - raywenderlich.com</a><br />
<strong>github地址:</strong> <a href="https://github.com/AZCoder2/Pinterest">Pinterest</a></p>
</blockquote>
<p>核心代码:</p>
<pre><code class="language-plain_text">//
//  PinterestLayout.swift
//  Pinterest
//
//  Created by Tom Ranalli on 12/25/16.
//  Copyright © 2016 Razeware LLC. All rights reserved.
//

import UIKit

// MARK: - Protocols
protocol PinterestLayoutDelegate {
  
  // Request height of photo
  func collectionView(_ collectionView:UICollectionView, heightForPhotoAtIndexPath indexPath:NSIndexPath,
                      withWidth:CGFloat) -&gt; CGFloat
  
  // Request annotation for photo
  func collectionView(_ collectionView: UICollectionView,
                      heightForAnnotationAtIndexPath indexPath: NSIndexPath, withWidth width: CGFloat) -&gt; CGFloat
}

class PinterestLayoutAttributes: UICollectionViewLayoutAttributes {
  
  // This declares the photoHeight property that the cell will use to resize its image view
  var photoHeight: CGFloat = 0.0
  
  /* This overrides copy(_with:)
   
     Subclasses of UICollectionViewLayoutAttributes need to conform to the NSCopying protocol 
     because the attribute’s objects can be copied internally. You override this method to 
     guarantee that the photoHeight property is set when the object is copied.
  */
  
  override func copy(with zone: NSZone? = nil) -&gt; Any {
    let copy = super.copy(with: zone) as! PinterestLayoutAttributes
    copy.photoHeight = photoHeight
    return copy
  }
  
  /* This overrides isEqual(_:), and it’s mandatory as well.
 
     The collection view determines whether the attributes have changed by comparing the old 
     and new attribute objects using isEqual(_:). You must implement it to compare the custom
     properties of your subclass. The code compares the photoHeight of both instances, and
     if they are equal, calls super to determine if the inherited attributes are the same;
     if the photo heights are different, it returns false
  */

  override func isEqual(_ object: Any?) -&gt; Bool {
    if let attributes = object as? PinterestLayoutAttributes {
      if( attributes.photoHeight == photoHeight  ) {
        return super.isEqual(object)
      }
    }
    return false
  }
}

// MARK: - Class definition
class PinterestLayout: UICollectionViewLayout {
  
  // MARK: - Properties
  
  // Keep reference to the delegate
  var delegate: PinterestLayoutDelegate!
  
  // Configure number of columns and cell padding
  var numberOfColumns = 2
  var cellPadding: CGFloat = 6.0
  
  // This is an array to cache the calculated attributes. 
  
  /* When you call prepareLayout(), you’ll calculate the attributes for all items and add them to the cache. When the collection view later requests the layout attributes, you can be efficient and query the cache instead of recalculating them every time
  */
  
  private var cache = [PinterestLayoutAttributes]()
  
  // This declares two properties to store the content size.
  // contentHeight is incremented as photos are added
  private var contentHeight: CGFloat  = 0.0
  
  // contentWidth is calculated based on the collection view width and its content inset.
  private var contentWidth: CGFloat {
    let insets = collectionView!.contentInset
    return collectionView!.bounds.width - (insets.left + insets.right)
  }
  
  // Variable overrides
  
  /* This overrides collectionViewContentSize variable of the abstract parent class, and returns the size of the collection view’s contents. To do this, you use both contentWidth and contentHeight calculated in the previous steps.
  */
 
  override var collectionViewContentSize: CGSize {
    return CGSize(width: contentWidth, height: contentHeight)
  }
  
  /* This overrides layoutAttributesClass variable to tell the collection view to use PinterestLayoutAttributes whenever it creates layout attributes objects.
  */
  
  override class var layoutAttributesClass: AnyClass {
    return PinterestLayoutAttributes.self
  }
  
  // MARK: - Overrides
  
  override func prepare() {
    
    // Only calculate if cache is empty
    if cache.isEmpty {
      
      /*  This declares and fills the xOffset array with the x-coordinate for every column based on the column widths.
      */
      let columnWidth = contentWidth / CGFloat(numberOfColumns)
      
      var xOffset = [CGFloat]()
      
      for column in 0 ..&lt; numberOfColumns {
        xOffset.append(CGFloat(column) * columnWidth )
      }
      
      /*  The yOffset array tracks the y-position for every column. You initialize each value in yOffset to 0, since this is the offset of the first item in each column.
      */
      var column = 0
      var yOffset = [CGFloat](repeating: 0, count: numberOfColumns)
      
      // This loops through all the items in the first section, as this particular 
      // layout has only one section
      for item in 0 ..&lt; collectionView!.numberOfItems(inSection: 0) {
        
        let indexPath = NSIndexPath(item: item, section: 0)
        
        // This is where you perform the frame calculation
        // Width is the previously calculated cellWidth, with the padding between cells removed
        let width = columnWidth - cellPadding * 2
        
        // You ask the delegate for the height of the image
        let photoHeight = delegate.collectionView(collectionView!,
                                                  heightForPhotoAtIndexPath: indexPath,
                                                  withWidth:width)

        // You ask the delegate for the height of the annotation
        let annotationHeight = delegate.collectionView(collectionView!,
                                    heightForAnnotationAtIndexPath: indexPath,
                                    withWidth: width)
        
        // Calculate the frame height based on those heights and the predefined cellPadding 
        // for the top and bottom
        let height = cellPadding +  photoHeight + annotationHeight + cellPadding
        
        // Combine this with the x and y offsets of the current column to create the
        // insetFrame used by the attribute
        let frame = CGRect(x: xOffset[column], y: yOffset[column], width: columnWidth, height: height)
        let insetFrame = frame.insetBy(dx: cellPadding, dy: cellPadding)
        
        // This creates an instance of PinterestLayoutAttributes
        let attributes = PinterestLayoutAttributes(forCellWith: indexPath as IndexPath)
        attributes.photoHeight = photoHeight
        
        // Sets its frame using insetFrame
        attributes.frame = insetFrame
        
        // Append the attributes to cache
        cache.append(attributes)
        
        // This expands contentHeight to account for the frame of the newly calculated item
        contentHeight = max(contentHeight, frame.maxY)
        
        // It then advances the yOffset for the current column based on the frame
        yOffset[column] = yOffset[column] + height
        
        // Finally, it advances the column so that the next item will be placed in the next column.
        if column &gt;= numberOfColumns - 1 {
          column = 0
        } else {
          column = column + 1
        }
        
      }
    }
  }
  
  override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {
    
    var layoutAttributes = [UICollectionViewLayoutAttributes]()
    
    //  Iterate through the attributes in cache and check if their frames intersect with rect
    for attributes in cache {
      if attributes.frame.intersects(rect) {
        layoutAttributes.append(attributes) // Add in any attributes for display
      }
    }
    return layoutAttributes
  }

}

</code></pre>
<p>比较有意思的一个计算高度方式:</p>
<pre><code class="language-plain_text">  // This provides the height of the photos
  
  /* It uses AVMakeRectWithAspectRatioInsideRect() from AVFoundation to calculate a height that retains the photo’s aspect ratio, restricted to the cell’s width.
   */
  
  func collectionView(_ collectionView:UICollectionView,
                      heightForPhotoAtIndexPath indexPath: NSIndexPath,
                      withWidth width: CGFloat) -&gt; CGFloat {
    
    let photo = photos[indexPath.item]
    let boundingRect =  CGRect(x: 0, y: 0, width: width, height: CGFloat(MAXFLOAT))
    let rect  = AVMakeRect(aspectRatio: photo.image.size, insideRect: boundingRect)
    
    return rect.size.height
  }
</code></pre>
<p>图片解压:</p>
<pre><code class="language-plain_text">extension UIImage {
  
  var decompressedImage: UIImage {
    UIGraphicsBeginImageContextWithOptions(size, true, 0)
    draw(at: CGPoint.zero)
    let decompressedImage = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return decompressedImage!
  }
  
}
</code></pre>
<p>一个从前没有用过的Api:</p>
<pre><code class="language-plain_text">  /* 
   This code calls the super implementation to make sure that the standard attributes are applied. Then, it casts the attributes object into an instance of PinterestLayoutAttributes to obtain the photo height and then changes the image view height by setting the imageViewHeightLayoutConstraint constant value.
  */
  
  override func apply(_ layoutAttributes: UICollectionViewLayoutAttributes) {
    super.apply(layoutAttributes)
    
    if let attributes = layoutAttributes as? PinterestLayoutAttributes {
      imageViewHeightLayoutConstraint.constant = attributes.photoHeight
    }
  }
</code></pre>
<p>=============完===========</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938156.html">设置placeholder颜色</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>从前设置颜色可能是这样的：</p>
<pre><code class="language-plain_text">self.textField.setValue(UIColor.white, forKeyPath: &quot;_placeholderLabel.textColor&quot;)

</code></pre>
<p>今天发现，居然有一个属性可以设置：</p>
<pre><code class="language-plain_text">self.textField.attributedPlaceholder =
            NSAttributedString(string: &quot;自定义金额&quot;,
                               attributes:
                [NSAttributedStringKey.foregroundColor: UIColor.white]
        )

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938238.html">获取崩溃信息</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>日志详细信息:</p>
<pre><code class="language-plain_text">static void exceptionHandler( NSException * exception )
{
    NSString *date = [NSString stringWithFormat:@&quot;崩溃日志-%@&quot;, [[NSDate date] description]];

    NSLog(DEBUG_CRASH, @&quot;%@ app crashed %@&quot;,date,exception.description);
	 abort();
}
</code></pre>
<p>Appdelegate中调用:</p>
<pre><code class="language-plain_text">NSSetUncaughtExceptionHandler( &amp;exceptionHandler );
</code></pre>
<p>当然也可以在日志信息中记录堆栈信息:</p>
<pre><code class="language-plain_text">[exception callStackSymbols]
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938318.html">UITableView优化方案(收集)</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##相关文章/博客<br />
<a href="http://www.cocoachina.com/ios/20150906/13212.html">一次 TableView 性能优化经历</a><br />
<a href="http://blog.jobbole.com/37984/">iOS应用性能调优的25个建议和技巧</a><br />
<a href="http://longxdragon.github.io/2015/05/26/UITableView%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/">UITableView优化技巧</a><br />
<a href="http://blog.csdn.net/shang_ri_la/article/details/25954383">UITableView 滚动流畅性优化</a> (备注:这个原始网站挂了,幸好有朋友转载过.)</p>
<p>##注意点:</p>
<p>####1. 列表卡顿问题最好真机测试，有条件的尽量选择低版本硬件和系统进行测试；</p>
<p>####2. 使用 Instruments 的 Time Profiler 工具定位造成卡顿时间消耗的位置；</p>
<p>####3. 避免 UITableView 的多次刷新( reloadData )，尤其 Xib 加载 UITableView 时避免首次自动加载；</p>
<p>####4. 为 Cell 专门定义显示 Model；</p>
<p>####5. Model 需要包含已提前计算出的 Cell 高度；</p>
<p>####6. 对于显示的 NSString，提前在 Model 中组装完成，避免在 Cell 中组装转换；</p>
<p>####7. 对于需要加载的网络图片链接，提前在 Model 中组装完成 NSURL,避免在 Cell 中组装转换；</p>
<p>####8. 尽量减少 Cell 中的逻辑判断和运算并使用正确的数据格式;</p>
<p>####9. 避免在 Cell 中反复创建 View,最好在初始化时一并创建，通过设置 Hidden 属性控制显示和隐藏;</p>
<p>####10. 对于 UIImageView ,注意加载的图片大小是否与控件大小一致，尽量保持一致；</p>
<p>####11. 正确使用 reuseIdentifier</p>
<pre><code class="language-plain_text">static NSString *CellIdentifier = @&quot;MyFancyCell&quot;;
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];

</code></pre>
<p>####12. 尽量把所有的 UIView 以及其子类控件设置为不透明（Opaque = YES）,你可以在模拟器中用Debug\Color Blended Layers选项来发现哪些view没有被设置为opaque。目标就是，能设为opaque的就全设为opaque!</p>
<p>####13. 尽量避免图片压缩，模拟器条件下使用 Debug\Color Misaligned Images 选项检查像素是否对其:如果图片边界没有与目标像素完美对齐，该功能可为图片叠加上一层品红色。如果图片使用确定的比例大小绘制，那么该功能会为图片添加一层黄色叠加。真机条件下使用 Instrument 中的 Core Animation 工具检查；<br />
####14. 使用 shadowPath 来画阴影;</p>
<pre><code class="language-plain_text">#import &lt;QuartzCore/QuartzCore.h&gt;

// Somewhere later ...
UIView *view = [[UIView alloc] init];

// Setup the shadow ...
view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);
view.layer.shadowRadius = 5.0f;
view.layer.shadowOpacity = 0.6;
</code></pre>
<p>####15. 减少 subviews 的数量;</p>
<p>####16. 尽量不使用 cellForRowAtIndexPath: ，如果你需要用到它，只用一次然后缓存结果；<br />
####17. 使用 Autorelease Pool；</p>
<pre><code class="language-plain_text">NSArray *urls = &lt;# An array of file URLs #&gt;;
for (NSURL *url in urls) {
    @autoreleasepool {
        NSError *error;
        NSString *fileContents = [NSString stringWithContentsOfURL:url
                                         encoding:NSUTF8StringEncoding error:&amp;error];
    }
}
</code></pre>
<p>####18. 选择是否需要缓存；</p>
<pre><code class="language-plain_text">UIImage *img = [UIImage imageNamed:@&quot;myImage&quot;]; // caching

// or
 UIImage *img = [UIImage imageWithContentsOfFile:@&quot;myImage&quot;]; // no caching
</code></pre>
<p>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用 imageWithContentsOfFile 足矣，这样不会浪费内存来缓存它。然而，在图片反复重用的情况下 imageNamed 是一个好得多的选择。</p>
<p>####19. 避免日期格式转换；相关日期显示应该在 Model 中定义完成。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938414.html">线程需要注意的问题</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E6%AD%BB%E9%94%81%EF%BC%88dead-lock%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>死锁（Dead Lock）</h2>
<p>第一种情况：</p>
<pre><code class="language-plain_text">let serialQueue = DispatchQueue(label:&quot;test&quot;)
serialQueue.async {
    //.....
    serialQueue.sync {
        //...
    }
}

</code></pre>
<p>第二种情况：</p>
<pre><code class="language-plain_text">let operationA = Operation()
let operationB = Operation()
operationA.addDependency(operationB)
operationB.addDependency(operationA)

</code></pre>
<p>怎样避免死锁：</p>
<ol>
<li>少用依赖</li>
<li>慎用同步</li>
</ol>
<h2><a id="%E4%BC%98%E5%85%88%E5%80%92%E7%BD%AE%EF%BC%88priority-inversion%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优先倒置（Priority Inversion）</h2>
<pre><code class="language-plain_text">var highPriorityQueue = DispatchQueue.global(qos: .userInitiated)
var lowPriorityQueue = DispatchQueue.global(qos: .utility)

let semaphore = DispatchSemaphore(value: 1)

lowPriorityQueue.async {
    semaphore.wait()
    for i in 0...10 {
        print(i)
    }
    semaphore.signal()
}

highPriorityQueue.async {
    semaphore.wait()
    for i in 11...20 {
        print(1)
    }
}

</code></pre>
<p>解决办法：<br />
同一个资源用同一个Qos</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938506.html">Flutter 图片处理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="icon" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Icon</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938588.html">网络切面化处理</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>##什么是面向切片编程</p>
<blockquote>
<p>看考&lt;禅与Objective-C 编码艺术&gt;第11章  面向切面编程.  本文中技术部分参考<a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork</a>和<a href="https://github.com/casatwy/RTNetworking">RTNetworking</a>代码实现,拜读了<a href="http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html">iOS应用架构谈 网络层设计方案</a>和猿题库的两篇使用介绍并根据根据个人理解修改部分功能实现,这篇文章主要就是进行思路的整理,一步一步制造自己想要的网络请求轮子.</p>
</blockquote>
<p>Aspect Oriented Programming (AOP,面向切面编程)在OC中意味着可以通过运行时的特性来为切面添加合适的代码.简单说可以添加类似行为:</p>
<ul>
<li>在类的特定方法调用前运行特定的代码</li>
<li>在类的特定方法调用后运行特定的代码</li>
<li>增加代码来代替原来的类的方法的实现</li>
</ul>
<p>##网络怎么切面<br />
上面已经说了什么是面向切面编程,那么网络中怎么切面?最主要的就是找到合适的方法,然后在它的前后都切一刀.由于项目中使用的是<a href="https://github.com/AFNetworking">AFNetworking</a>所以适合我们的特定方法应该是进行网络请求的关键代码,如下:</p>
<pre><code class="language-plain_text">/**
 Creates an `NSURLSessionDataTask` with the specified request.

 @param request The HTTP request for the request.
 @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.
 */
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;
</code></pre>
<p>当然,如果需要上传下载进度的话</p>
<pre><code class="language-plain_text">/**
 Creates an `NSURLSessionDataTask` with the specified request.

 @param request The HTTP request for the request.
 @param uploadProgressBlock A block object to be executed when the upload progress is updated. Note this block is called on the session queue, not the main queue.
 @param downloadProgressBlock A block object to be executed when the download progress is updated. Note this block is called on the session queue, not the main queue.
 @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.
 */
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request
                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock
                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock
                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;
</code></pre>
<p>这个应该是你的选择,这里只说下网络请求,所以就以第一种为例了.</p>
<p>我们能在网络请求之前与之后做些什么呢?</p>
<ul>
<li>操作网络请求之前(取消,判断是否重复...)</li>
<li>操作网络请求之后(缓存,错误处理...)</li>
<li>...</li>
</ul>
<p>###进行网络请求核心代码</p>
<pre><code class="language-plain_text">- (void)addRequest:(NSURLRequest *)request {
    NSLog(@&quot;\n==================================\n\nRequest Start: \n\n &quot;
          @&quot;%@\n\n==================================&quot;,
          request.URL);
    
    // 跑到这里的block的时候，就已经是主线程了。
    __block NSURLSessionDataTask *dataTask = nil;
    dataTask = [_manager
                dataTaskWithRequest:request
                completionHandler:^(NSURLResponse *_Nonnull response,
                                    id _Nullable responseObject,
                                    NSError *_Nullable error) {
                    NSNumber *requestID = @([dataTask taskIdentifier]);
                    [_requestsRecord removeObjectForKey:requestID];
                    NSData *responseData = responseObject;
                    NSString *responseString =
                    [[NSString alloc] initWithData:responseData
                                          encoding:NSUTF8StringEncoding];
                    
                    NSLog(@&quot;responseString:%@&quot;,responseString);
                    if (error) {
                        NSLog(@&quot;error: %@&quot;,error);
                        
#warning TODO: 失败回掉
                        NSLog(@&quot;这里应该进行失败回掉&quot;);
                    } else {
                        // 检查http response是否成立。
#warning TODO: 成功回掉
                        NSLog(@&quot;这里应该进行成功回掉&quot;);
                    }
                }];
    // 添加到请求列表
    NSNumber *requestId = @([dataTask taskIdentifier]);
    _requestsRecord[requestId] = dataTask;
    [dataTask resume];
}
</code></pre>
<p>###创建NSMutableURLRequest<br />
需要NSMutableURLRequest参数,所以创建一个</p>
<pre><code class="language-plain_text">    AFHTTPRequestSerializer *httpRequestSerializer = [AFHTTPRequestSerializer serializer];
    httpRequestSerializer.timeoutInterval = 20.0f;
    httpRequestSerializer.cachePolicy = NSURLRequestUseProtocolCachePolicy;
    /// 网络请求头部插入一些内容
    [httpRequestSerializer setValue:[[NSUUID UUID] UUIDString] forHTTPHeaderField:@&quot;xxxxxxxx&quot;];
    NSMutableURLRequest *request = [httpRequestSerializer requestWithMethod:@&quot;GET&quot;
                                                                  URLString:@&quot;http://www.baidu.com&quot;
                                                                      parameters:nil
                                                                           error:NULL];
</code></pre>
<p>可以看到,上面注释的地方说明我们可以在这里搞事情啊,这个稍后会用到</p>
<p>对了,不要忘记设置<code>info.plist</code></p>
<pre><code class="language-plain_text">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;
	&lt;dict&gt;
		&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;
		&lt;true/&gt;
	&lt;/dict&gt;

</code></pre>
<p>创建request然后请求,<code>[[MKNetWorkAgent sharedInstance] addRequest:request];</code>结果如下,百度HTML页面去除了部分代码:</p>
<pre><code class="language-plain_text">2016-08-02 15:36:13.721 NetWorkDemo[56429:4922365] 
==================================

Request Start: 

 http://www.baidu.com

==================================
2016-08-02 15:36:13.838 NetWorkDemo[56429:4922365] responseString:&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;!--STATUS OK--&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
        &lt;title&gt;百度一下,你就知道&lt;/title&gt;
        &lt;meta http-equiv=&quot;Cache-control&quot; content=&quot;no-cache&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            /*去掉css样式*/
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;wrap&quot;&gt;
            &lt;div class=&quot;lg&quot;&gt;
                &lt;img src=&quot;//m.baidu.com/static/index/u.png&quot; alt=&quot;百度首页&quot;&gt;
            &lt;/div&gt;
            &lt;form action=&quot;//m.baidu.com/s?&quot; method=&quot;get&quot;&gt;
                &lt;div class=&quot;word-wrap&quot;&gt;
                    &lt;input type=&quot;text&quot; name=&quot;word&quot; maxlength=&quot;64&quot; size=&quot;17&quot; id=&quot;word&quot;&gt;
                &lt;/div&gt;
                &lt;input type=&quot;submit&quot; value=&quot;百度一下&quot; class=&quot;bn&quot;&gt;
            &lt;/form&gt;
            &lt;div class=&quot;d&quot;&gt;
        		&lt;!-- 去掉了尾部 --&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
2016-08-02 15:36:13.839 NetWorkDemo[56429:4922365] 这里应该进行成功回掉
</code></pre>
<p>这说明已经能够进行网络请求了.</p>
<p>........... 2016.8.3更新.............</p>
<blockquote>
<p>随着项目的增长,有些接口我们可能需要在不同的地方调用,这是需求把请求单独拿出来.在这里我们创建一个MKBaseRequest,所有的接口都继承自base,这样就能够满足我们的需求了.</p>
</blockquote>
<p>需求出来了,怎么解决呢?<br />
首先修改进行网络请求核心代码为<code>- (void)addRequest:(MKBaseRequest *)request</code>,MKBaseRequest里面必须要提供可供访问的url,因为<code>NSURLRequest</code>的创建需要url.</p>
<p>在<code>MKBaseRequest</code>中添加:</p>
<pre><code class="language-plain_text">/// 请求的URL
- (NSString *)requestUrl;
</code></pre>
<p>使用方法而不是属性的原因就是为了方便子类的重写.<code>- (void)addRequest:(MKBaseRequest *)request</code>实现中由于没有<code>NSURLRequest</code>所以需要根据<code>MKBaseRequest</code>提供的url进行创建,添加代码:</p>
<pre><code class="language-plain_text">NSURLRequest *requestTest = [NSURLRequest requestWithURL:[NSURL URLWithString:[request requestUrl]]];
</code></pre>
<p>同理,我们还可以在<code>MKBaseRequest</code>中添加其他限制项,例如:</p>
<pre><code class="language-plain_text">/// 请求的BaseURL
- (NSString *)baseUrl;

/// 请求的cdnURL
- (NSString *)cdnUrl;

/// 请求的连接超时时间，默认为60秒
- (NSTimeInterval)requestTimeoutInterval;

/// 请求的参数列表
- (nullable id)requestArgument;

/// Http请求的方法
- (MKRequestMethod)requestMethod;

/// 是否使用cdn的host地址
- (BOOL)useCDN;
</code></pre>
<p>写到这里,如果我们很多接口都设置类似baseUrl之类的可以提取出来还有些必须的参数,在app进入的时候一起设置.这时我们需要创建<code>MKNetworkConfig</code>来管理这些内容.</p>
<p>........... 2016.8.4更新.............<br />
###本地模拟登陆<br />
做个简单的模拟登陆登陆页面:</p>
<pre><code class="language-plain_text">&lt;form action=&quot;welcome.php&quot; method=&quot;get&quot;&gt;&lt;br&gt;
    Name: &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;br&gt;
    PWD:  &lt;input type=&quot;text&quot; name=&quot;pwd&quot; /&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt;
</code></pre>
<p>welecome.php中简单的输出刚刚输入的内容.</p>
<pre><code class="language-plain_text">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Citynight&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

您输入的账号是:

&lt;?php echo $_GET[&quot;name&quot;]; ?&gt;
.&lt;br /&gt;

密码是:

&lt;?php echo $_GET[&quot;pwd&quot;]; ?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>登陆界面的样子:<br />
<img src="media/16587402938588/14703212142675.jpg" alt="" /></p>
<p>点击提交后:<br />
<img src="media/16587402938588/14703212477389.jpg" alt="" /><br />
已经能够得到正确的结果了.</p>
<p>既然网页端没有问题,那么就修改成返回json格式数据给客户端</p>
<pre><code class="language-plain_text">&lt;?php
$map = array(
    'name' =&gt; $_GET[&quot;name&quot;],
    'pwd' =&gt; $_GET[&quot;pwd&quot;]
);
echo json_encode($map);
</code></pre>
<p>测试已经能够正常返回了:<br />
<img src="media/16587402938588/14703247878224.jpg" alt="" /></p>
<h3><a id="%E6%80%8E%E6%A0%B7%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>怎样传递参数</h3>
<pre><code class="language-plain_text">/// 请求的参数列表
- (nullable id)requestArgument;
</code></pre>
<p>上面是原先设置的传递参数的方式,我感觉这样做不是很方便,比如需要传递的参数是变化的,可能就需要init的时候添加参数,这时如果参数的数量还比较多可能就比较麻烦了.<br />
我现在采用的是通过代理的方法实现.</p>
<pre><code class="language-plain_text">/// 数据源:获得所需要的参数
@protocol MKRequestParamSource &lt;NSObject&gt;
@required
- (NSDictionary *)paramsForRequest:(MKBaseRequest *)request;
@end
</code></pre>
<p>我们创建的时候如果需要参数必须设置代理,并实现</p>
<pre><code class="language-plain_text">/// request paramSource
@property (nonatomic, weak, nullable) id&lt;MKRequestParamSource&gt; paramSource;
</code></pre>
<p>这样做是模仿数据源的代理方法,比较容易理解.</p>
<blockquote>
<p>2016.8.23更<br />
###如何进行分页<br />
开发中我们经常遇到需要上拉加载更多的需求,参数中的page是动态变化的.这个轮子也对此作了处理,如下:</p>
</blockquote>
<pre><code class="language-plain_text">/// MKNetWorkAgent中添加带参数的网络请求
- (void)addRequest:(MKBaseRequest *)baseRequest WithParams:(nullable id)params;
</code></pre>
<pre><code class="language-plain_text">//MKBaseRequest 中添加方法用于获取当前状态
/* 子类重写必须写 super 否则 isLoading 状态不会更改*/
- (void)beforePerformRequestState;
/// success: 判断成功还是失败
- (void)afterPerformResponseState:(BOOL)success;
</code></pre>
<p>具体使用:<br />
<img src="media/16587402938588/14719456603156.jpg" alt="" /></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938682.html">获取当前显示的UIViewController</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-plain_text">+ (UIViewController *)getCurrentRootViewController {

    CommonTool *tool = [[CommonTool alloc]init];

    UIViewController *result;
    UIWindow *topWindow = [[UIApplication sharedApplication] keyWindow];

    if (topWindow.windowLevel != UIWindowLevelNormal){
        NSArray *windows = [[UIApplication sharedApplication] windows];
        for(topWindow in windows){
            if (topWindow.windowLevel == UIWindowLevelNormal)
                break;
        }
    }

    UIView *rootView = [topWindow subviews].firstObject;
    id nextResponder = [rootView nextResponder];

    if ([nextResponder isMemberOfClass:[UIViewController class]]){
        result = nextResponder;
    }
    else if ([nextResponder isMemberOfClass:[UITabBarController class]] | [nextResponder isMemberOfClass:[UINavigationController class]]){
        result = [tool findViewController:nextResponder];
    }
    else if ([topWindow respondsToSelector:@selector(rootViewController)] &amp;&amp; topWindow.rootViewController != nil){
        result = topWindow.rootViewController;
    }

    else{
        NSAssert(NO, @&quot;找不到顶端VC&quot;);
    }
    return result;
}

</code></pre>
<pre><code class="language-plain_text">- (UIViewController *)findViewController:(id)controller{
    if ([controller isMemberOfClass:[UINavigationController class]]) {
        return [self findViewController:[(UINavigationController *)controller visibleViewController]];
    }
    else if ([controller isMemberOfClass:[UITabBarController class]]){
        return [self findViewController:[(UITabBarController *)controller selectedViewController]];
    }
    else if ([controller isKindOfClass:[UIViewController class]]){
        return controller;
    }
    else{
        NSAssert(NO, @&quot;找不到顶端VC&quot;);
        return nil;
    }
}

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938768.html">Mac 应用图标没有在launchpad里显示</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>重置Launchpad</p>
<pre><code class="language-plain_text">rm ~/Library/Application\ Support/Dock/*.db

</code></pre>
<pre><code class="language-plain_text">killall Dock
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402938922.html">使用Swift获取应用程序的CPU使用率和内存使用量</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>原文<a href="https://qiita.com/rinov/items/f30d386fb7b8b12278a5">SwiftでアプリのCPU使用率とメモリ使用量を取得する</a></p>
<p>##介绍<br />
在一个获取系统信息的方法中，一个描述CPU和内存状态的库存在于一个获取系统信息的方法中，其中Debug附带了来自XCode的CustomFlag等。</p>
<p>当然，还有一些方法可以获取不限于Debug版本的系统信息，但大多数都是在Objective-C中编写的。也在AppleDeveloper官方论坛上</p>
<blockquote>
<p>尽管使用Swift是不可能的，但对于那些使用Objective-C 的人来说可能很难</p>
</blockquote>
<p>还有答案说。<br />
但是，没有任何优点，你可以或根本不能使用Swift。我个人认为低层实现也有以下优点。</p>
<ul>
<li>受益于可选</li>
<li>提高可读性</li>
<li>更容易共享代码（易于维护维护）</li>
</ul>
<p>所以我这次写了如何在Swift中获得CPU利用率和内存使用量。（还有关于磁盘使用情况的奖励）</p>
<h2><a id="%E5%8A%A8%E4%BD%9C%E7%A1%AE%E8%AE%A4%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动作确认环境</h2>
<p>XCode8.3.3 <br />
Swift3.1</p>
<h2><a id="cpu%E4%BD%BF%E7%94%A8%E7%8E%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CPU使用率</h2>
<pre><code class="language-plain_text">// 必須
import Foundation

// CPU使用率を0%~100%で取得
private func getCPUUsage() -&gt; Float {
    // カーネル処理の結果
    var result: Int32
    var threadList = UnsafeMutablePointer&lt;UInt32&gt;.allocate(capacity: 1)
    var threadCount = UInt32(MemoryLayout&lt;mach_task_basic_info_data_t&gt;.size / MemoryLayout&lt;natural_t&gt;.size)
    var threadInfo = thread_basic_info()

    // スレッド情報を取得
    result = withUnsafeMutablePointer(to: &amp;threadList) {
        $0.withMemoryRebound(to: thread_act_array_t?.self, capacity: 1) {
            task_threads(mach_task_self_, $0, &amp;threadCount)
        }
    }

    if result != KERN_SUCCESS { return 0 }

    // 各スレッドからCPU使用率を算出し合計を全体のCPU使用率とする
    return (0 ..&lt; Int(threadCount))
        // スレッドのCPU使用率を取得
        .flatMap { index -&gt; Float? in
            var threadInfoCount = UInt32(THREAD_INFO_MAX)
            result = withUnsafeMutablePointer(to: &amp;threadInfo) {
                $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                    thread_info(threadList[index], UInt32(THREAD_BASIC_INFO), $0, &amp;threadInfoCount)
                }
            }
            // スレッド情報が取れない = 該当スレッドのCPU使用率を0とみなす(基本nilが返ることはない)
            if result != KERN_SUCCESS { return nil }
            let isIdle = threadInfo.flags == TH_FLAGS_IDLE
            // CPU使用率がスケール調整済みのため`TH_USAGE_SCALE`で除算し戻す
            return !isIdle ? (Float(threadInfo.cpu_usage) / Float(TH_USAGE_SCALE)) * 100 : nil
        }
        // 合計算出
        .reduce(0, +)
}
</code></pre>
<p><code>Float(threadInfo.cpu_usage) / Float(TH_USAGE_SCALE)</code>已经完成了划分以确保值的精确性，因此有必要进行划分。<br />
这<code>CPU使用率 / スケール</code>是因为如果你把这个表达式放入，初步完成了下面的处理。</p>
<p><code>CPU使用率 = 0.216</code>如果存在 - &gt; 21.6％的值，则缩放因子获得10的幂，使得CPU使用率是整数。因此，在这种情况下，比例因子是1000。（<code>0.216 * 1000 = 216</code>）<br />
因此，由于这些系数系数根据值的精度而不同，因此它们必须用于每个线程的除法。</p>
<h2><a id="%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存使用情况</h2>
<pre><code class="language-plain_text">// 必須
import Foundation

// 使用者が単位を把握できるようにするため
typealias MegaByte = UInt64

// 引数にenumで任意の単位を指定できるのが好ましい e.g. unit = .auto (デフォルト引数)
func getMemoryUsed() -&gt; MegaByte? {
    // タスク情報を取得
    var info = mach_task_basic_info()
    // `info`の値からその型に必要なメモリを取得
    var count = UInt32(MemoryLayout.size(ofValue: info) / MemoryLayout&lt;integer_t&gt;.size)
    let result = withUnsafeMutablePointer(to: &amp;info) {
        task_info(mach_task_self_,
                  task_flavor_t(MACH_TASK_BASIC_INFO),
                  // `task_info`の引数にするためにInt32のメモリ配置と解釈させる必要がある
                  $0.withMemoryRebound(to: Int32.self, capacity: 1) { pointer in
                    UnsafeMutablePointer&lt;Int32&gt;(pointer)
                  }, &amp;count)
    }
    // MB表記に変換して返却
    return result == KERN_SUCCESS ? info.resident_size / 1024 / 1024 : nil
}
</code></pre>
<p>在上面的例子中，它是MB单位，但在这种情况下<code>ByteCountFormatter</code>最好使用下面的。<br />
<code>return</code>，<code>resident_size</code>获取在该点使用的实际内存使用量。*也可以在XCode中确认内存使用情况，但实际内存使用量通常会大于该值。我不知道它消耗了什么，但由于初始值只是不同，似乎通过相对观察没有问题<img src="media/16587402938922/1f646.png" alt="：ok_woman：" title="：ok_woman：" /></p>
<h2><a id="https-qiita-comrinovitemsf30d386fb7b8b12278a5-e3-83-87-e3-82-a3-e3-82-b9-e3-82-af-e4-bd-bf-e7-94-a8-e9-87-8f%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://qiita.com/rinov/items/f30d386fb7b8b12278a5#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E4%BD%BF%E7%94%A8%E9%87%8F"></a>磁盘使用情况</h2>
<pre><code class="language-plain_text">// 必須(ByteCountFormatterとFileAttributeKeyで使用)
import UIKit

// ディスクスペース種別
enum DiskSpaceType {
    case total
    case free
    case used
}

func getDiskSpace(_ type: DiskSpaceType) -&gt; String {
    // GB,MB,KB表記の文字列に変換
    let byteUnitStringConverted: (Int64) -&gt; String = { size in
        ByteCountFormatter.string(fromByteCount: size,countStyle: ByteCountFormatter.CountStyle.binary)
    }
    switch type {
    case .total:
        // ディスク合計容量
        return byteUnitStringConverted(totalSpace)
    case .free:
        // ディスク空き容量
        return byteUnitStringConverted(freeSpace)
    case .used:
        // ディスク使用量
        return byteUnitStringConverted(usedSpace)
    }
}

var totalSpace: Int64 {
    guard let attributes = systemAttributes,
        let size = (attributes[FileAttributeKey.systemSize] as? NSNumber)?.int64Value
        else { return 0 }
    return size
}

var freeSpace: Int64 {
    guard let attributes = systemAttributes,
        let size = (attributes[FileAttributeKey.systemFreeSize] as? NSNumber)?.int64Value
        else { return 0 }
    return size
}

var usedSpace: Int64 {
    return totalSpace - freeSpace
}

private var systemAttributes: [FileAttributeKey: Any]? {
    return try? FileManager.default.attributesOfFileSystem(forPath: NSHomeDirectory())
}
</code></pre>
<p>关于磁盘使用情况，<code>FileAttributeKey</code>您可以从链接的信息中获取。<code>computed property</code>我认为设置它是安全的，以便总磁盘容量也会波动。</p>
<h2><a id="%E6%91%98%E8%A6%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>摘要</h2>
<ul>
<li>Swift还具有高指针兼容性，因此您可以实现与Objective-C相当的层代码（有时您不能<img src="media/16587402938922/1f914.png" alt="：思维：" title="：思维：" />）</li>
<li>毕竟我们用Swift写了它，过程前景更好 <img src="media/16587402938922/1f60e.png" alt="：墨镜：" title="：墨镜：" /></li>
<li>写它像Swift一样很难。 <img src="media/16587402938922/2639.png" alt="：frowning2：" title="：frowning2：" /></li>
</ul>
<h2><a id="https-qiita-comrinovitemsf30d386fb7b8b12278a5-e5-8f-82-e8-80-83%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://qiita.com/rinov/items/f30d386fb7b8b12278a5#%E5%8F%82%E8%80%83"></a>参考</h2>
<p><a href="https://www.gnu.org/software/hurd/gnumach-doc/Thread-Information.html">https://www.gnu.org/software/hurd/gnumach-doc/Thread-Information.html</a></p>
<p><a href="https://forums.developer.apple.com/thread/64665">https://forums.developer.apple.com/thread/64665</a></p>
<p><a href="https://stackoverflow.com/questions/8223348/ios-get-cpu-usage-from-application">https://stackoverflow.com/questions/8223348/ios-get-cpu-usage-from-application</a></p>
<p><a href="https://stackoverflow.com/questions/787160/programmatically-retrieve-memory-usage-on-iphone">https://stackoverflow.com/questions/787160/programmatically-retrieve-memory-usage-on-iphone</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939013.html">如何解决json字符串中包含制表符</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>错误信息:</p>
<pre><code class="language-plain_text">Error Domain=NSCocoaErrorDomain Code=3840 &quot;The operation couldn’t be completed. (Cocoa error 3840.)&quot; (Unescaped control character around character 135.) UserInfo=0x170e79d00 {NSDebugDescription=Unescaped control character around character 135.}
</code></pre>
<p>如何处理:<br />
最关键的地方:</p>
<pre><code class="language-plain_text">-(NSString *)removeUnescapedCharacter:(NSString *)inputStr
{
    NSCharacterSet *controlChars = [NSCharacterSet controlCharacterSet];//获取那些特殊字符
    NSRange range = [inputStr rangeOfCharacterFromSet:controlChars];//寻找字符串中有没有这些特殊字符
    if (range.location != NSNotFound)
        {
        NSMutableString *mutable = [NSMutableString stringWithString:inputStr];
        while (range.location != NSNotFound)
            {
            [mutable deleteCharactersInRange:range];//去掉这些特殊字符
            range = [mutable rangeOfCharacterFromSet:controlChars];
            }
        return mutable;
        }
    return inputStr;
}

</code></pre>
<p>举例:</p>
<pre><code class="language-plain_text">
    NSString *responseString = [NSMutableString stringWithString:[request responseString]];
    responseString =[self removeUnescapedCharacter:responseString];
    NSData *jsonData = [responseString dataUsingEncoding:NSUTF8StringEncoding];
    NSError *error;
    NSDictionary * dic = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;error];
    
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939095.html">Carthage 不能正常更新</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>报错</p>
<pre><code class="language-plain_text">➜  PersonalMusic git:(master) carthage update
*** Cloning GCDWebServer
A shell task (/usr/bin/env git clone --bare --quiet https://github.com/swisspol/GCDWebServer.git /Users/lixzzzzzz/Library/Caches/org.carthage.CarthageKit/dependencies/GCDWebServer) failed with exit code 128:
fatal: unable to access 'https://github.com/swisspol/GCDWebServer.git/': LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443

</code></pre>
<p>解决办法：</p>
<p>清缓存</p>
<pre><code class="language-plain_text">rm -rf ~/Library/Caches/org.carthage.CarthageKit
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939177.html">ListView滑动删除Dismissible</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>我们可以在item外层包上Dismissible，这样就实现了滑动删除功能。</p>
<pre><code class="language-dart">	ListView.separated(
        itemBuilder: (context, index) {
          return Dismissible(
            key: UniqueKey(),
            background: Container(
              color: Colors.black,
            ), // 从开始滑动到结束的背景颜色
            secondaryBackground: Container(
              color: Colors.green,
            ), // 从结束滑动到开始的背景颜色
            onResize: () {
              print(&quot;-----&quot;);
            },
            resizeDuration: null,
            onDismissed: (direction) {
              print(direction);
              // 这里根据滑动方向进行判断
              if (direction == DismissDirection.startToEnd) {
                // 从开始滑动到结束
              } else if (direction == DismissDirection.endToStart) {
                // 从结束滑动到开始
              }
            },
            direction: DismissDirection
                .horizontal, // 滑动删除方向，默认是水平。list垂直的时候如果Dismissible也是垂直list就不会滚动了,未被Dismissible包裹的组件还是可以滑动的
            child: Container(
              height: 50,
              color: Colors.blue[index % 9 * 100],
            ),
          );
        },
        separatorBuilder: (context, index) {
          return Divider();
        },
        itemCount: 100);
</code></pre>
<p>注意：</p>
<ol>
<li>必须有key，这样才知道操作的是哪一个</li>
<li>必须实现onDismissed方法，这里操作数据源，否则数据不会消失，再次滚动道该位置数据还会出现。direction是滑动的方向。</li>
<li>如果按需求确认是否删除可以实现confirmDismiss</li>
</ol>
<p>其他参数：</p>
<ol>
<li>onResize 组件大小改变直到消失的时候会不停的调用</li>
<li>resizeDuration  在[onDismissed]被调用之前，该小组件将花多少时间收缩。如果为null，该小组件将不会收缩，[onDismissed]将被调用 在小组件dismiss后立即被调用。</li>
<li>movementDuration dismiss后回到初始或者完成的动画时间。</li>
<li>dismissThresholds 滑动到多少判断完成，默认是0.4也就是滑动到40%的时候就完成了。值的格式是map 即以Dismiss Direction.startToEnd: 0.4 来判断从开始到结束滑动到40%的时候就完成了。DismissDirection.endToStart: 0.7 来判断从结束滑动到开始的70%位置就完成了。</li>
<li>dismissible的滑动方向也是能修改的，默认是左右滑动，可以设置direction: DismissDirection.vertical  设置垂直方向滑动。但是这样就不能滑动列表了。</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939267.html">Python爬网站上的图片</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>以<a href="http://ppt.geekbang.org">极客邦PPT大全</a>为例,比如我想下载<a href="http://ppt.geekbang.org/slide/show/204">美团iOS客户端的构建思考与实践</a></p>
<ol>
<li>查看图片url<br />
<img src="media/16587402939267/14689832970971.jpg" alt="" /></li>
<li>图片url的格式<a href="http://7xiox7.com2.z0.glb.qiniucdn.com/576e52fb28bf9-01.jpg">http://7xiox7.com2.z0.glb.qiniucdn.com/576e52fb28bf9-01.jpg</a>  总共101张图片</li>
<li>根据这些编写Python文件</li>
</ol>
<pre><code class="language-plain_text">#!/usr/bin/python
#coding:utf-8

import urllib
import urllib2
import os

basepicurl=&quot;http://7xiox7.com2.z0.glb.qiniucdn.com/576e52fb28bf9-&quot;
save_path=&quot;/Users/mekor/Desktop/images/&quot;
for i in range(1,102,1):
	s = &quot;%02d&quot; % i
	picurl = basepicurl + s + &quot;.jpg&quot;
	imgData = urllib2.urlopen(picurl).read()
	# 给定图片存放名称
	fileName = save_path + s + &quot;.jpg&quot;
	# 文件名是否存在
	#if os.path.exists(fileName):
	output = open(fileName,'wb+')
	output.write(imgData)
	output.close()
	print &quot;Finished download&quot;+ s

print &quot;运行完成&quot;
</code></pre>
<p>这样就能够把所有的图片爬到本地了.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939357.html">Swift - 函数式编程</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>一般情况:</p>
<pre><code class="language-plain_text">struct User {
    func login(password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()

usr.login(password: passwd)
</code></pre>
<p>函数式编程</p>
<pre><code class="language-plain_text">struct User {
    func login(password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()

User.login(usr)(password: passwd)
</code></pre>
<p>由此可见: <code>usr.login(password: passwd)</code> == <code>User.login(usr)(password: passwd)</code></p>
<p>如果忽略外部参数</p>
<pre><code class="language-plain_text">struct User {
    func login(_ password: String){
        print(password)
    }
}

let passwd = &quot;123123123&quot;
let usr = User()
usr.login(passwd)
User.login(usr)(passwd)
</code></pre>
<p>这样就更简洁了</p>
<hr />
<p>--- 11.24更 --<br />
##柯里化(Currying)</p>
<pre><code class="language-plain_text">// 柯里化(Currying)

func addOne(num:Int) -&gt;Int {
    return num + 1
}

print(addOne(num: 10))

func addTo(_ adder:Int) -&gt;(_ num:Int) -&gt; Int {
    return {
        num in
        return num + adder
    }
}

let addTwo = addTo(2)

print(addTwo(6))

// 更简单的调用方式
print(addTo(9)(1))

</code></pre>
<p>----12.8----<br />
说到函数式编程,我突然想起了今天实现一个功能所用到的技术,这里只做简单记录.</p>
<p>项目中遇到一个问题:根据参数创建相应个数的视图,视图中按钮的点击事件还要回调..我一开始想用代理来做,发现如果层级结构比较深的话代理不是很好用.既然否定了代理那么怎样还能实现该效果呢?我尝试用函数(闭包).</p>
<p>需要传递的数据</p>
<pre><code class="language-plain_text">let dict = [
    [&quot;title&quot;:GLOBAL_LANGUAGE(&quot;历史锅底&quot;) ,
     &quot;subtitle&quot;:GLOBAL_LANGUAGE(&quot;上次的定制锅底,再来一单&quot;),
     &quot;imagename&quot;:&quot;OrderDishOrPot1&quot;,
     &quot;callback&quot;:historyPotsList!]  // callback 中存放的就是函数名或者闭包名
]
</code></pre>
<pre><code class="language-plain_text">let showTitle =  data[i][&quot;title&quot;] as! String
let showSubTitle = data[i][&quot;subtitle&quot;] as! String
let imageName = data[i][&quot;imagename&quot;] as! String
let callBack = data[i][&quot;callback&quot;] as! (()-&gt;()) // 这里就是我需要的闭包

//=======

callBack() // 闭包调用

</code></pre>
<p>只需要这样我就能实现需求了...函数的传递虽然不像👆所说的那样函数式编程,但是还是有必要记录下,swift跟OC比还是灵活了很多.</p>
<p>----未完待续---</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939441.html">RunLoop</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="1%E4%BB%80%E4%B9%88%E6%98%AF-runloop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 什么是runloop</h2>
<ul>
<li>Run loops 是线程相关的的基础框架的一部分。一个 run loop 就是一个事件处理 的循环,用来不停的调度工作以及处理输入事件。使用 run loop 的目的是让你的线程在有工作的时候忙于工作,而没工作的时候处于休眠状态。</li>
<li>runloop就是运行循环(内部do-while),它的基本作用就是让程序持续运行,处理App中的各种事件(触摸,定时器,Selector).</li>
<li>main函数中UIApplicationMain内部就启动了一个runloop,这样UIApplicationMain就会一直没有返回值,保持了程序的持续运行.这个默认的runloop是跟主线程相关联的.</li>
<li>runloop 只能选择一个模式(Mode)启动,如果想切换其他模式只能退出当前循环再切换其他模式.如果当前模式中没有任何Source,timer,observer就会退出runloop</li>
</ul>
<h2><a id="2-runloop%E4%B8%8E%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. RunLoop与线程</h2>
<p>每条线程都有唯一的一个与之对应的RunLoop对象,主线程的RunLoop启动的时候已经默认创建好了,其他线程的RunLoop需要主动创建(RunLoop在第一次获取的时候创建,在线程结束的时候销毁)</p>
<h2><a id="3-runloop%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. RunLoop对象</h2>
<p>####iOS中有2套API来访问和使用runloop</p>
<ul>
<li>Foundation -&gt; NSRunLoop</li>
<li>Core Foundation -&gt; CFRunLoopRef</li>
</ul>
<p>NSRunLoop和CFRunLoopRef都是runloop对象.NSRunLoop是基于CFRunLoopRef的一层OC封装</p>
<p>####获得RunLoop对象</p>
<ul>
<li>
<p>Foundation</p>
<pre><code class="language-objc">[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象
[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象
</code></pre>
</li>
<li>
<p>Core Foundation</p>
<pre><code class="language-objc">CFRunLoopGetCurrent(): // 获得当前线程的RunLoop对象
CFRunLoopGetMain(): //获得主线程的RunLoop对象
</code></pre>
</li>
</ul>
<h2><a id="4-runloop%E7%9B%B8%E5%85%B3%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. RunLoop相关类</h2>
<p>###Core Foundation中关于RunLoop的5个类</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>网上其他人博客总结(图一):<br />
<img src="media/16587402939441/14731758243846.jpg" alt="" /></p>
<p>###CFRunLoopModeRef(Run Loop 模式)<br />
<strong>CFRunLoopModeRef代表RunLoop的运行模式</strong>  一个RunLoop包含若干个Mode,每个Mode又包含若干个Source/Timer/Observer. 每次RunLoop启动时,只能指定其中一个Mode,这个Mode被称之为CurrentMode. 如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入. 这样做主要是为了分隔开不同组的Source/Timer/Observer,让他们互不影响.</p>
<p>Run loop 模式是所有要监视的输入源和定时源以及要通知的 run loop 注册观察者的集合。每次运行你的 run loop,你都要指定(无论显示还是隐式)其运行个模式。在 run loop 运行过程中,只有和模式相关的源才会被监视并允许他们传递事件消息。(类似的,只有和模式相关的观察者会通知 run loop 的进程)。和其他模式关联的源只有在 run loop 运行在其模式下才会运行,否则处于暂停状态。</p>
<p>###CFRunLoopModeRef</p>
<p><strong>系统默认注册了5个Mode:</strong></p>
<ul>
<li>
<p><strong>kCFRunLoopDefaultMode:</strong> App的默认Mode，通常主线程是在这个Mode下运行</p>
</li>
<li>
<p><strong>UITrackingRunLoopMode:</strong> 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</p>
</li>
<li>
<p><strong>UIInitializationRunLoopMode:</strong> 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</p>
</li>
<li>
<p><strong>GSEventReceiveRunLoopMode:</strong> 接受系统事件的内部 Mode，通常用不到</p>
</li>
<li>
<p><strong>kCFRunLoopCommonModes:</strong> 这是一个占位用的Mode，不是一种真正的Mode</p>
</li>
</ul>
<p>Cocoa 和 Core foundation 定义了一个默认的和一些常用的模式,通常在代码中都是用字符串来标识这些模式。当然你也可以给模式名称指定一个字符串来自定义模式.<br />
runloop一启动就会选中一种模式，当选中了一种模式之后其它的模式就都不鸟。一个mode里面可以添加多个NSTimer(见上面图一),也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。</p>
<p>###CFRunLoopSourceRef</p>
<p><strong>CFRunLoopSourceRef是事件源（输入源）</strong></p>
<p>输入源异步的发送消息给你的线程。事件来源取决于输入源的种类:基于端口的输入源和自定义输入源。基于端口的输入源监听程序相应的端口。自定义输入源则监听自定义的事件源。至于 run loop,它不关心输入源的是基于端口的输入源还是自 定义的输入源。系统会实现两种输入源供你使用。两类输入源的区别在于如何显示: 基于端口的输入源由内核自动发送,而自定义的则需要人工从其他线程发送。</p>
<p>当你创建输入源,你需要将其分配给 run loop 中的一个或多个模式。模式只会 在特定事件影响监听的源。大多数情况下,run loop 运行在默认模式下,但是你也 可以使其运行在自定义模式。若某一源在当前模式下不被监听,那么任何其生成的消 息只在 run loop 运行在其关联的模式下才会被传递。</p>
<p>以前的分法:<br />
Port-Based Sources<br />
Custom Input Sources<br />
Cocoa Perform Selector Sources</p>
<p>现在的分法:<br />
Source0：非基于Port的<br />
Source1：基于Port的</p>
<p>###CFRunLoopTimerRef<br />
<strong>CFRunLoopTimerRef是基于时间的触发器</strong></p>
<p>####NSTimer:</p>
<pre><code class="language-plain_text">- (void)timer2
{
    //NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultMode

    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];

    //更改模式
    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];

}

- (void)timer1
{
    //    [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];

    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];

    //定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作
    //    [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];

    //定时器添加到NSDefaultRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作
    //    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];

    //占位模式：common modes标记
    //被标记为common modes的模式 kCFRunLoopDefaultMode  UITrackingRunLoopMode
    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];

    //    NSLog(@&quot;%@&quot;,[NSRunLoop currentRunLoop]);
}

- (void)run
{
    NSLog(@&quot;---run---%@&quot;,[NSRunLoop currentRunLoop].currentMode);
}

- (IBAction)btnClick {

    NSLog(@&quot;---btnClick---&quot;);
}
</code></pre>
<p>####GCD中的定时器</p>
<pre><code class="language-plain_text">//0.创建一个队列
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

    //1.创建一个GCD的定时器
    /*
     第一个参数：说明这是一个定时器
     第四个参数：GCD的回调任务添加到那个队列中执行，如果是主队列则在主线程执行
     */
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);

    //2.设置定时器的开始时间，间隔时间以及精准度

    //设置开始时间，三秒钟之后调用
    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,3.0 *NSEC_PER_SEC);
    //设置定时器工作的间隔时间
    uint64_t intevel = 1.0 * NSEC_PER_SEC;

    /*
     第一个参数：要给哪个定时器设置
     第二个参数：定时器的开始时间DISPATCH_TIME_NOW表示从当前开始
     第三个参数：定时器调用方法的间隔时间
     第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0
     该参数的意义：可以适当的提高程序的性能
     注意点：GCD定时器中的时间以纳秒为单位（面试）
     */

    dispatch_source_set_timer(timer, start, intevel, 0 * NSEC_PER_SEC);

    //3.设置定时器开启后回调的方法
    /*
     第一个参数：要给哪个定时器设置
     第二个参数：回调block
     */
    dispatch_source_set_event_handler(timer, ^{
        NSLog(@&quot;------%@&quot;,[NSThread currentThread]);
    });

    //4.执行定时器
    dispatch_resume(timer);

    //注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用
    self.timer = timer;

GCD定时器补充
/*
 DISPATCH_SOURCE_TYPE_TIMER         定时响应（定时器事件）
 DISPATCH_SOURCE_TYPE_SIGNAL        接收到UNIX信号时响应

 DISPATCH_SOURCE_TYPE_READ          IO操作，如对文件的操作、socket操作的读响应
 DISPATCH_SOURCE_TYPE_WRITE         IO操作，如对文件的操作、socket操作的写响应
 DISPATCH_SOURCE_TYPE_VNODE         文件状态监听，文件被删除、移动、重命名
 DISPATCH_SOURCE_TYPE_PROC          进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号

 下面两个都属于Mach相关事件响应
    DISPATCH_SOURCE_TYPE_MACH_SEND
    DISPATCH_SOURCE_TYPE_MACH_RECV
 下面两个都属于自定义的事件，并且也是有自己来触发
    DISPATCH_SOURCE_TYPE_DATA_ADD
    DISPATCH_SOURCE_TYPE_DATA_OR
 */
</code></pre>
<p>###CFRunLoopObserverRef<br />
<strong>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</strong></p>
<p>可以监听的时间点有以下几个</p>
<pre><code class="language-plain_text">/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0),           // 即将进入 Loop
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   // 即将进入休眠
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    // 刚从休眠中唤醒
    kCFRunLoopExit = (1UL &lt;&lt; 7),            // 刚从休眠中唤醒
    kCFRunLoopAllActivities = 0x0FFFFFFFU   // 所有状态改变
};
</code></pre>
<p>如何监听:</p>
<pre><code class="language-plain_text"> //创建一个runloop监听者
    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {

        NSLog(@&quot;监听runloop状态改变---%zd&quot;,activity);
    });

    //为runloop添加一个监听者
    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);

    CFRelease(observer);
</code></pre>
<h2><a id="5-runloop%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. RunLoop处理逻辑</h2>
<p><img src="media/16587402939441/14732109138343.jpg" alt="" /><br />
<img src="media/16587402939441/14732110397325.jpg" alt="" /></p>
<p>网友整理如下:<br />
<img src="media/16587402939441/14732111027007.jpg" alt="" /></p>
<h2><a id="6-runloop%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.RunLoop应用</h2>
<ul>
<li>NSTimer</li>
<li>ImageView显示  控制方法在特定的模式下可用</li>
<li>PerformSelector</li>
<li>常驻线程 在子线程中开启一个runloop</li>
<li>自动释放池
<ul>
<li>第一次创建：进入runloop的时候</li>
<li>最后一次释放：runloop退出的时候</li>
<li>其它创建和释放：当runloop即将休眠的时候会把之前的自动释放池释放，然后重新创建一个新的释放池</li>
</ul>
</li>
</ul>
<h3><a id="%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常见问题</h3>
<blockquote>
<p>自动释放池什么时候释放?</p>
</blockquote>
<p>通过Obserber监听在runloop的状态,一旦监听到runloop即将进行睡眠等待状态(kCFRunLoopBeforeWaiting),就释放</p>
<p><img src="media/16587402939441/15167055358673.jpg" alt="" /></p>
<blockquote>
<p>在开发中如何使用runloop?</p>
</blockquote>
<ol>
<li>开启一个常驻线程(让一个子线程不进入消亡状态,等待从其他线程发来的消息,处理各种事件)举例:1&gt;在子线程中开启一个定时器 2&gt; 在子线程中进行一些场景监控</li>
<li>可以控制定时器在那种模式下运行</li>
<li>可以让某些事件(行为,任务)在特定模式下执行(performSelector)</li>
<li>可以添加observer监听runloop的一些状态,比如监听点击事件的处理(在所有点击事件处理之前做一些事情)<br />
###参考资料:</li>
</ol>
<hr />
<p>官方文档 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Threading Programming Guide</a><br />
CFRunLoopRef<a href="http://opensource.apple.com/source/CF/CF-1151.16/">源代码</a></p>
<h3><a id="%E6%9C%80%E5%90%8E%E7%BB%99%E5%87%BA%E5%87%A0%E4%B8%AA%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最后给出几个学习链接</h3>
<p><a href="http://www.jianshu.com/p/20d3bb3e8df5">RunLoop深度探究（一）</a></p>
<p><a href="http://www.jianshu.com/p/6582c47a13c8">RunLoop深度探究（二）</a></p>
<p><a href="http://www.jianshu.com/p/240683510692">RunLoop深度探究（三）</a></p>
<p><a href="http://www.jianshu.com/p/f3ed25944aef">RunLoop深度探究（四）</a></p>
<p><a href="http://www.jianshu.com/p/1c50d0b0fe1a">RunLoop深度探究（五）</a></p>
<p><a href="http://www.jianshu.com/p/dc7ce81eda23">深入理解RunLoop文章</a></p>
<p><a href="http://blog.ibireme.com/2015/05/18/runloop/">http://blog.ibireme.com/2015/05/18/runloop/</a></p>
<p><a href="http://www.jianshu.com/p/ccd379c6db98">读 Threading Programming Guide 笔记（一）</a></p>
<p><a href="http://www.jianshu.com/p/30782af3fe1a">读 Threading Programming Guide 笔记（二）</a></p>
<p><a href="http://www.jianshu.com/p/30782af3fe1a">读 Threading Programming Guide 笔记（三）</a></p>
<p><a href="http://www.jianshu.com/p/ccd379c6db98">读 Threading Programming Guide 笔记（四）</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939539.html">公司规范</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="git%E5%88%86%E6%94%AF%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Git分支建议</h2>
<blockquote>
<p>开发必读<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">http://www.ruanyifeng.com/blog/2012/07/git.html</a></p>
<p>多提交，少推送。</p>
<h5><a id="%E4%B8%A5%E6%A0%BC%E9%81%B5%E5%AE%88%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>严格遵守：</h5>
<p>填写本次修改内容</p>
<p>代码合并必须命令行合并，并且加上--no-ff参数。（文章中有详细介绍）</p>
<p>将 <strong>feature/develop_wangchao_打印bug</strong> 分支合并到当前分支命令如下：</p>
<p>git merge --no-ff feature/develop_wangchao_打印bug</p>
</blockquote>
<h5><a id="%E4%B8%8E%E6%96%87%E7%AB%A0%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与文章中的差异：</h5>
<blockquote>
<p>所有问题由组长来定属于紧急问题，还是特性问题。</p>
<blockquote>
<p>紧急问题上线流程：预发布分支--&gt;生产分支。</p>
<p>特性问题上线流程：开发分支--&gt;预发布分支--&gt;生产分支。（<strong>预发布分支</strong> 从 <strong>生产分支</strong> 拉取）</p>
</blockquote>
<p><strong>预发布分支</strong> 的的问题按照bug分支处理。</p>
<blockquote>
<p>步骤：从 <strong>预发布分支</strong> 拉取bug分支，修改完成后合并到 <strong>预发布分支</strong> ，测试通过后 <strong>预发布分支</strong> 合并到 <strong>生产分支</strong> ，在生产分支打上和 <strong>预发布分支</strong> 名称一样的标签， <strong>预发布分支</strong> 删除，<strong>bug分支</strong> 删除。</p>
</blockquote>
<p>生产环境紧急问题和bug，按照bug分支处理，步骤参考 <strong>预发布分支</strong> bug处理方式。</p>
<p>推荐git图形界面mac用sourcetree，windows用git tortoise，可以清晰看到提交记录图和提交人。</p>
<p>注意：生产分支、预发布分支分别2人有修改权限，负责代码合并，预发布分支合并到生产分支时，需要看git提交记录图，所有修改人员必须签字，说明修改部分关联的项目，分支权限定期抽查。</p>
</blockquote>
<h5><a id="%E5%BB%BA%E8%AE%AE%E5%88%86%E6%94%AF%E5%91%BD%E5%90%8D%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建议分支命名：</h5>
<blockquote>
<p>云端：</p>
<blockquote>
<pre><code class="language-plain_text">|----master                                         生产分支
|----release                                        预发布分支文件夹
        |----master20180915                         预发布分支
|----develop                                        开发分支
|----feature                                        个人分支文件夹
        |----develop_wangchao_会员结账               具体个人分支
        |----develop_shaochuanjun_微信结账           具体个人分支
|----fixbug                                         bug分支文件夹
        |----master20180915_wangchao_扫码点餐bug     具体个人bug分支
        |----master20180915_shaochuanjun_点菜bug     具体个人bug分支
</code></pre>
<p>能够直观看到个人分支的源分支（从哪个分支拉取的）。</p>
<p>feature、fixbug下的分支不允许跨源合并、跨源拉取（develop_开头的分支只能合并到develop，只能拉取develop分支），release下的分支除外。</p>
<p>实际上bug分支可以往预发布、开发分支合并，简单起见我们禁止跨源合并</p>
<p>release下的分支每次合并到master时要并行合并到develop分支。</p>
</blockquote>
<p>门店：（由于shop、shop-print和海底捞一套代码比较特殊，建议和云端命名方式一样，加上前缀文件夹huoguo或haidilao）</p>
<blockquote>
<p>hht-manage属于新火锅特有项目，建议按照云端命名基础上增加版本号。</p>
<pre><code class="language-plain_text">|----master_v1                                         生产分支
|----master_v2                                         生产分支
|----release                                        预发布分支文件夹
        |----master_v1_20180915                         预发布分支
        |----master_v2_20180915                         预发布分支
|----develop                                        开发分支
|----feature                                        个人分支文件夹
        |----develop_wangchao_会员结账               具体个人分支
        |----develop_shaochuanjun_微信结账           具体个人分支
|----fixbug                                         bug分支文件夹
        |----master20180915_wangchao_扫码点餐bug     具体个人bug分支
        |----master20180915_shaochuanjun_点菜bug     具体个人bug分支
</code></pre>
</blockquote>
<p><strong>举例：</strong></p>
<blockquote>
<p>小A要做一个新功能的步骤：</p>
<p>1、找组长确认属于什么类型问题 ----&gt; 2、属于特性问题 ----&gt; 3、从 <strong>develop</strong> 拉取分支 <strong>feature/develop_A_打印功能</strong> ----&gt; 4、修改完成后--no-ff合并到 <strong>develop</strong> 分支测试 ----&gt; 5、测试通过后找组长从生产分支拉取预发布分支 <strong>release/master20180919</strong> ，把生产环境的数据库备份到预发布环境 ----&gt; 6、组长把 <strong>feature/develop</strong> 合并到 <strong>release/master20180919</strong> ----&gt; 7、开发整理所有预发布环境没有的脚本交给组长 ----&gt; 8、组长存档 <strong>master20180919.sql</strong> 后交给运维执行 ----&gt; 9、测试通过后组长把 <strong>master20180919.sql</strong> 文件上传到 <strong>release/master20180919</strong> 分支，并合并到生产、测试环境，正式环境打上标签 <strong>master20180919</strong> ，删除 <strong>release/master20180919</strong> 分支 ----&gt; 10、运维正式环境执行目录下的 <strong>master20180919.sql</strong> 、打版。</p>
<p>注意：脚本分预制脚本（insert）、建库脚本（create、alter）</p>
</blockquote>
</blockquote>
<h2><a id="db%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DB建议</h2>
<blockquote>
<p>测试环境开放读写权限，公司白名单。</p>
<p>生产环境云端、门店数据库，白名单访问。</p>
<p>预发布环境只开放读权限，脚本需交给组长备份，组长交给运维执行。建议备份文件名和 <strong>预发布分支</strong> 名保持一致，<strong>预发布分支</strong> 合并到 <strong>生产分支</strong> 时添加到 <strong>预发布分支</strong> 的SQL文件夹下，并执行相同名称的sql文件。</p>
<p>缺：平台出工具根据时间段抽取云端指定商户、门店的数据，并做脱敏处理。</p>
</blockquote>
<h2><a id="config%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Config建议</h2>
<blockquote>
<p>项目只留address.conf，local.conf两个配置文件，local.conf引用address.conf。所有存在环境差异的配置，都放到address.conf里，不要单独创建redis.conf。</p>
<p>1、address.conf中包含所有项目的ip、端口。</p>
<p>2、打版后线上通过固定目录的address.conf来覆盖打版项目的address.conf，所有项目共用一个。</p>
<p>3、address.conf的修改只能通过运维</p>
<p><strong>例如:</strong></p>
<p>address.conf配置如下：</p>
<p>Markup</p>
<pre><code class="language-plain_text">#在文件中使用方式为：other.var1 = &quot;https://&quot;${address.db1.host}&quot;:&quot;${address.db1.port}&quot;/app/somefunction&quot;
address {
  #数据连接 地址/端口/数据库/用户名/密码
  db {
    host = &quot;10.170.195.16&quot;
    port = &quot;3306&quot;
    db_name = &quot;canyin_saas&quot;
    db_user = &quot;huoguo&quot;
    db_password = &quot;12312300&quot;
  }
  #本地登录及权限服务部署地址
  loginServer{
    host=&quot;http://test-canyinsaas.honghuotai.com&quot;
    port=&quot;8001&quot;
    path=&quot;/login&quot;
  }
  #微信appid
  wechat{
      appid=&quot;aaaaaaaaaaaa&quot;
      #微信appsecret
      appsecret=&quot;bbbbbbbbbbbbbbb&quot;
  }
  # Redis相关配置
  redis{
      ip = 127.0.0.1
      port = 6379
      passwd = 345555
      number = 0
      defaultDBNum = 0
      maxDBNum = 16
      maxActive = 1024
      maxIdle = 200
      maxWait = 1000
      testOnBorrow = false
      testOnReturn = true
  }
}
</code></pre>
<p>dev.conf配置如下</p>
<p>Markup</p>
<pre><code class="language-plain_text">    include &quot;../application.conf&quot;
    include &quot;./address.conf&quot;
    db {
      default.driver = com.mysql.jdbc.Driver
      default.url = &quot;jdbc:mysql://&quot;${address.db.host}&quot;:&quot;${address.db.port}&quot;/&quot;${address.db.db_name}&quot;?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&quot;
      default.username = ${address.db.db_user}
      default.password = ${address.db.db_password}
      default.logSql = true
    }
    # 云端shop服务
    cloudServerSocketService=${address.cloudServerSocket.host}&quot;:&quot;${address.cloudServerSocket.port}${address.loginServer.path}
    #获取所有支付方式
    user.payway.getall=${loginService}&quot;/position/businesspower/getEmpPowerList&quot;
</code></pre>
</blockquote>
<h2><a id="%E5%90%8E%E7%AB%AF%E6%8F%92%E4%BB%B6%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后端插件建议</h2>
<blockquote>
<p>插件名：Alibaba Java Coding Guidelines</p>
<p>github地址：<a href="https://github.com/alibaba/p3c/">https://github.com/alibaba/p3c/</a></p>
<blockquote>
<p>安装步骤如下：</p>
<p>打开idea--&gt;Preference--&gt;Plugins--&gt;Browse Repositories。</p>
<p>搜Alibaba Java Coding Guidelines，点击安装，重启。</p>
<p>有问题的代码会以红色/黑色波浪线标记出来，需要按照提示修改代码。</p>
</blockquote>
</blockquote>
<h2><a id="%E4%BB%A3%E7%A0%81%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码建议</h2>
<blockquote>
<p>1、 接口入参避免使用类型强转</p>
<p>2、小数禁止直接参与运算，用BigDecimal</p>
<p>3、禁止直接往缓存中存放数据（前端同样适用）</p>
</blockquote>
<p>Java</p>
<pre><code class="language-plain_text">//问题代码，无法追踪到userInfo的数据在哪里被修改。
public void doProblem(JSONObject userInfo){
    //do something
    if(RedisUtil.get(&quot;userInfo&quot;)!=null){
        //do something
        RedisUtil.del(&quot;userInfo&quot;);
    }else{
        //do something
        RedisUtil.set(&quot;userInfo&quot;,userInfo);
    }
}
//改进代码，可以在addUserInfo、deleteUserInfo方法中监控到userInfo添加、销毁。
public void doRight(JSONObject userInfo){
    //do something
    if(RedisUtil.getUserInfo()!=null){
        //do something
        RedisUtil.deleteUserInfo(&quot;userInfo&quot;);
    }else{
        //do something
        RedisUtil.addUserInfo(&quot;userInfo&quot;,userInfo);
    }
}
</code></pre>
<blockquote>
<p>4、数据库设计，下列字段必须有，model继承com.hht.common.base.model.BaseModel。</p>
<p>涉及到存操作员id的字段，全部存人员id，禁止存用户id（employId(人员id)来自pro_employee表，userId（用户id）来自hht_member表）</p>
</blockquote>
<p>Java</p>
<pre><code class="language-plain_text">    //主键
    private String id;
    //删除状态Y,N
    private String dr;
    //时间戳，每次update操作都要更新
    private Long ts;
    //创建时间，只在insert时更新
    private Long createTime;
    //创建人id
    private String creatorId;
    //修改时间，update时更新此字段
    private Long modifyTime;
    //修改人，update时修改
    private String modifierId;
    //商户id，非报表查询必须加此条件
    private String companyId;
    //门店id，门店查询必须加此条件
    private String shopId;
    //是否可用，预留，N,Y
    private String enable;
</code></pre>
<blockquote>
<p>5、更多建议参考<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">http://www.ruanyifeng.com/blog/2012/07/git.html</a>里面的《阿里巴巴Java开发手册（详尽版）.pdf》</p>
</blockquote>
<h2><a id="%E6%8E%A5%E5%8F%A3%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口建议</h2>
<blockquote>
<p>rap上的参数必须和实际接口中的参数一致，前后端并行开发时，先约定好mock数据。</p>
<p>严格按照restful规范，外部接口走token，服务之间能走token走token，走不了token走签名，不允许免认证（特殊接口除外）。</p>
</blockquote>
<h2><a id="%E6%89%93%E7%89%88%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打版建议</h2>
<blockquote>
<p>预发布、正式环境打版需填申请单</p>
<blockquote>
<p>1、组长合并代码，根据提交记录图找到所有提交人。</p>
<p>2、所有提交人签字，写上自己修改部分的关联项目，测试环境测试人员签字。（抽查）</p>
<p>3、预发布环境测试完成，期间所有脚本经过组长备份后交给运维执行。</p>
<p>4、预发布分支合并到生产环境分支，运行和预发布分支名称一样的数据库脚本文件，测试人员签字。</p>
<p>5、实施验证问题，填写或邮件确认验证情况。</p>
<p>6、申请单完成，交给产品存档。</p>
</blockquote>
<h2><a id="%E6%97%A5%E5%BF%97%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>日志建议</h2>
<p>先按照各组需求输出，规范待整理</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939622.html">basedataconfig表中用到的与无用的数据</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2><a id="%E8%BF%98%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%97%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>还在使用的字段</h2>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>bill_ratio</td>
<td>积分兑换占账单比例</td>
<td>结账 和 H5页面用到了</td>
</tr>
<tr>
<td>cardPaymentUrl</td>
<td>PAD卡包接口地址</td>
<td></td>
</tr>
<tr>
<td>dishExchangeForPAD</td>
<td>PAD积分商城地址</td>
<td></td>
</tr>
<tr>
<td>gelNailForPAD</td>
<td>PAD新美甲地址</td>
<td></td>
</tr>
<tr>
<td>integral_num</td>
<td>积分数量</td>
<td></td>
</tr>
<tr>
<td>integral_type</td>
<td>会员积分兑换验证方式(0 密码和短信；1 只短信；2 只密码)</td>
<td></td>
</tr>
<tr>
<td>iosPadVersion</td>
<td>pad版本号</td>
<td></td>
</tr>
<tr>
<td>iosUpdateDownloadURL</td>
<td>pad包下载地址</td>
<td></td>
</tr>
<tr>
<td>isUpdate</td>
<td>是否更新</td>
<td></td>
</tr>
<tr>
<td>isUseCards</td>
<td>是否使用卡包功能（0 不使用；1 使用）</td>
<td></td>
</tr>
<tr>
<td>isUserNewMJ</td>
<td>是否使用新美甲1: 是;0:否</td>
<td></td>
</tr>
<tr>
<td>money_num</td>
<td>兑换钱数</td>
<td></td>
</tr>
<tr>
<td>pos_url</td>
<td>红包地址</td>
<td></td>
</tr>
<tr>
<td>redenvelope_pop</td>
<td>红包弹窗标识（0 不使用；1 使用）</td>
<td></td>
</tr>
<tr>
<td>sslCerDownloadURL</td>
<td>证书下载地址</td>
<td></td>
</tr>
<tr>
<td>themeViewLevel</td>
<td>设置主题推荐显示顺序</td>
<td></td>
</tr>
<tr>
<td>use_integral</td>
<td>是否使用积分功能（0 不使用；1 使用）</td>
<td></td>
</tr>
<tr>
<td>validate_type</td>
<td>会员积分验证方式(0 密码和短信；1 只短信；2 只密码)</td>
<td></td>
</tr>
<tr>
<td>waiterMessage</td>
<td>服务员寄语</td>
<td></td>
</tr>
</tbody>
</table>
<h2><a id="%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E7%9A%84%E5%AD%97%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>没有用到的字段</h2>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>bill_notarize</td>
<td>打印账单是否确认账单(0 不确认 1确认)</td>
<td></td>
</tr>
<tr>
<td>cashier_email</td>
<td>卡包管理员邮箱</td>
<td></td>
</tr>
<tr>
<td>cashier_mobile</td>
<td>卡包管理员手机号</td>
<td></td>
</tr>
<tr>
<td>custom_flavor</td>
<td>是否显示定制味碟(0 不显示 1显示)</td>
<td></td>
</tr>
<tr>
<td>discountVerification</td>
<td>折扣信息是否设置登陆短信验证1是，0否</td>
<td></td>
</tr>
<tr>
<td>integral</td>
<td>生成积分</td>
<td></td>
</tr>
<tr>
<td>integralToRemind</td>
<td>积分提醒</td>
<td></td>
</tr>
<tr>
<td>integralToRemindHw</td>
<td>积分提醒外文</td>
<td></td>
</tr>
<tr>
<td>isMyFriends</td>
<td>是否显示我的好友</td>
<td></td>
</tr>
<tr>
<td>isRankingList</td>
<td>是否显示排行榜</td>
<td></td>
</tr>
<tr>
<td>isSearchGd</td>
<td>是否显示搜索锅底</td>
<td></td>
</tr>
<tr>
<td>isShowPotGuide</td>
<td>是否显示锅底引导图片(0 不显示  1显示)</td>
<td></td>
</tr>
<tr>
<td>isStandardGd</td>
<td>是否显示标准锅底</td>
<td></td>
</tr>
<tr>
<td>isStandardMyGd</td>
<td>是否显示我的锅底</td>
<td></td>
</tr>
<tr>
<td>isStandardOther</td>
<td>是否显示其他</td>
<td></td>
</tr>
<tr>
<td>isUseBankOfChina</td>
<td>是否使用中国银行（0 不使用；1 使用）</td>
<td></td>
</tr>
<tr>
<td>isUseFreeCode</td>
<td>是否使用白吃码（0 不使用；1 使用）</td>
<td></td>
</tr>
<tr>
<td>isUseIntegral</td>
<td>是否使用积分功能（0 不使用；1 使用）</td>
<td></td>
</tr>
<tr>
<td>isUseTwo</td>
<td>是否显示双语 (0 使用；1 不使用)</td>
<td></td>
</tr>
<tr>
<td>money</td>
<td>钱数</td>
<td></td>
</tr>
<tr>
<td>myBestLove</td>
<td>设置我的最爱显示顺序</td>
<td></td>
</tr>
<tr>
<td>newProductPoint</td>
<td>设置新品必点显示顺序</td>
<td></td>
</tr>
<tr>
<td>pot_name</td>
<td>锅底名字更改框(0 不显示  1显示)</td>
<td></td>
</tr>
<tr>
<td>potGuideImg</td>
<td>锅底引导图片地址</td>
<td></td>
</tr>
<tr>
<td>potHelp</td>
<td>锅底帮助开关(0关闭  1开启)</td>
<td></td>
</tr>
<tr>
<td>SMSVerificationForLever</td>
<td>根据会员星级设置登陆短信验证1星2星3星4星5星</td>
<td></td>
</tr>
<tr>
<td>tasteType</td>
<td>标准锅底口味选择：1.滑条 标识位：0    2.弹框 标识位：1</td>
<td></td>
</tr>
<tr>
<td>unify</td>
<td>是否推送锅底口味数据（锅底口味配置修改后为1需要推送，否则为0）</td>
<td></td>
</tr>
<tr>
<td>unifyPostUrl</td>
<td>锅底口味推想统一订餐推送地址</td>
<td></td>
</tr>
</tbody>
</table>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939800.html">基础拾遗</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402939800/14727432899236.jpg" alt="" /></p>
<p>##self和super区别</p>
<p>要点：</p>
<ol>
<li>self调用自己方法，super调用父类方法</li>
<li>self是类，super是预编译指令</li>
<li>【self class】和【super class】输出是一样的</li>
</ol>
<p>self和super底层实现原理：</p>
<ol>
<li>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法。</li>
<li>当使用 self 调用时，会使用 <code>objc_msgSend</code> 函数：<code> id objc_msgSend(id theReceiver, SEL theSelector, ...)</code>。第 一个参数是消息接收者，第二个参数是调用的具体类方法的 <code>selector</code>，后面是 <code>selector</code> 方法的可变参数。以 <code>[self setName:]</code> 为例，编译器会替换成调用 <code>objc_msgSend</code> 的函数调用，其中 <code>theReceiver</code> 是 <code>self</code>，<code>theSelector</code> 是 <code>@selector(setName:)</code>，这个 <code>selector</code> 是从当前 <code>self</code> 的 <code>class</code> 的方法列表开始找的 <code>setName</code>，当找到后把对应的 <code>selector</code> 传递过去。</li>
<li>当使用 <code>super</code> 调用时，会使用 <code>objc_msgSendSuper</code> 函数：<code>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</code>第一个参数是个<code>objc_super</code>的结构体，第二个参数还是类似上面的类方法的<code>selector</code>，</li>
</ol>
<pre><code class="language-plain_text">struct objc_super {
      id receiver;
      Class superClass;
};
</code></pre>
<p>当编译器遇到  <code>[super setName:]</code> 时，开始做这几个事：</p>
<p>1）构建 <code>objc_super</code> 的结构体，此时这个结构体的第一个成员变量 <code>receiver</code> 就是子类，和 <code>self</code> 相同。而第二个成员变量 <code>superClass</code> 就是指父类<br />
调用 <code>objc_msgSendSuper</code> 的方法，将这个结构体和 <code>setName</code> 的 <code>sel</code> 传递过去。</p>
<p>2）函数里面在做的事情类似这样：从 <code>objc_super</code> 结构体指向的 <code>superClass</code> 的方法列表开始找 <code>setName</code> 的 <code>selector</code>，找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 <code>selector</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402939890.html">Swift - Swift Talk: Networking</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>Swift Talk 学习笔记,<a href="https://talk.objc.io/episodes/S01E01-networking">https://talk.objc.io/episodes/S01E01-networking</a></p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940060.html">Swift - 数组中的增删改与合并</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>第一篇写了数组遍历的几种情况,这篇主要就是数组中的增删改,也是开发中常用的</p>
</blockquote>
<p>OC中数组分为可变(NSMutableArray)和不可变(NSArray) 相应的在Swift中就是 var &amp; let</p>
<p>##追加元素<br />
首先定义一个可变数组</p>
<pre><code class="language-plain_text">var array = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;]
</code></pre>
<p>追加一个元素</p>
<pre><code class="language-plain_text">// 追加元素
array.append(&quot;赵六&quot;)
print(array)
</code></pre>
<p>##修改元素<br />
通过下标进行修改</p>
<pre><code class="language-plain_text">array[0] = &quot;赵四&quot;
print(array)
</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">[&quot;赵四&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;]
</code></pre>
<p>##删除</p>
<pre><code class="language-plain_text">// 删除元素
array.remove(at: 0)
print(array)
</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">[&quot;赵四&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;]
[&quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;]
</code></pre>
<p>remove 的方法由很多,移除首/尾,移除范围...</p>
<pre><code class="language-plain_text">array.removeAll(keepingCapacity: true)
print(&quot;数组中的元素\(array) 数组容量\(array.capacity)&quot;)
</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">数组中的元素[] 数组容量6
</code></pre>
<p>##数组合并</p>
<pre><code class="language-plain_text">var arr0 = [1,2,3]
let arr1 = [3,4,5]
arr0 += arr1
print(arr0)
</code></pre>
<p>结果:</p>
<pre><code class="language-plain_text">[1, 2, 3, 3, 4, 5]
</code></pre>
<p>注意: 要合并的数组的类型必须一致,如果不一致会出错. 比如:</p>
<pre><code class="language-plain_text">var arr0:[Any] = [1,2,3]
let arr1:[Any] = [&quot;2&quot;,3,4,5]
arr0 += arr1
print(arr0)
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940149.html">scrollowView 添加tableView中遇到的位置不准确问题</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="media/16587402940149/14707230189128.jpg" alt="" /><br />
添加tableView的时候tableView的<code>frame</code>是scrollowView的<code>bounds</code><br />
<img src="media/16587402940149/Snip20160809_5.png" alt="Snip20160809_5" /><br />
显示的时候tableView和scrollowView中间相差64.</p>
<p>解决办法:</p>
<pre><code class="language-plain_text">self.edgesForExtendedLayout = UIRectEdgeNone;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="16587402940245.html">devtools 热启动</a></h1>
			<p class="meta"><time datetime="2022-07-25T17:11:33+08:00" 
			pubdate data-updated="true">2022/07/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>第一步:添加pom</p>
<pre><code class="language-plain_text">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
</code></pre>
<p>第二步 添加插件到父pom中</p>
<pre><code class="language-plain_text">  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;fork&gt;true&lt;/fork&gt;
          &lt;addResources&gt;true&lt;/addResources&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre>
<p>第三步 开启自动编译选项<br />
Setting-&gt;Build-&gt;Compiler<br />
<img src="media/16587402940245/15965240806182.jpg" alt="" style="width:475px;" /></p>
<p>第四步: 修改Registry</p>
<p>双击 Shift 选中Action 输入 Registry 打开<br />
<img src="media/16587402940245/15965244242502.jpg" alt="" style="width:655px;" /><br />
修改为选中<br />
<img src="media/16587402940245/15965245587023.jpg" alt="" style="width:950px;" /><br />
第五步: 重启IDEA</p>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="16623668836941.html">git 远程分支回滚</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16619340520854.html">CSS 排版</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16613374889545.html">前端开发环境配置</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16607216444595.html">网站SEO</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16587402963682.html">Vue3设计思想与理念</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



  














<style type="text/css">
  
/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript */
/*
 Solarized Color Schemes originally by Ethan Schoonover
 http://ethanschoonover.com/solarized

 Ported for PrismJS by Hector Matos
 Website: https://krakendev.io
 Twitter Handle: https://twitter.com/allonsykraken)
*/

/*
SOLARIZED HEX
--------- -------
base03    #002b36
base02    #073642
base01    #586e75
base00    #657b83
base0     #839496
base1     #93a1a1
base2     #eee8d5
base3     #fdf6e3
yellow    #b58900
orange    #cb4b16
red       #dc322f
magenta   #d33682
violet    #6c71c4
blue      #268bd2
cyan      #2aa198
green     #859900
*/

code[class*="language-"],
pre[class*="language-"] {
  color: #657b83; /* base00 */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;

  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  background: #073642; /* base02 */
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  background: #073642; /* base02 */
}

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
  border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdf6e3; /* base3 */
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #93a1a1; /* base1 */
}

.token.punctuation {
  color: #586e75; /* base01 */
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #268bd2; /* blue */
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.url,
.token.inserted {
  color: #2aa198; /* cyan */
}

.token.entity {
  color: #657b83; /* base00 */
  background: #eee8d5; /* base2 */
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #859900; /* green */
}

.token.function,
.token.class-name {
  color: #b58900; /* yellow */
}

.token.regex,
.token.important,
.token.variable {
  color: #cb4b16; /* orange */
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>
  
    


</body>
</html>